"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[46409],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>h});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=o.createContext({}),p=function(e){var n=o.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},l=function(e){var n=p(e.components);return o.createElement(c.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),u=p(t),h=r,d=u["".concat(c,".").concat(h)]||u[h]||m[h]||a;return t?o.createElement(d,s(s({ref:n},l),{},{components:t})):o.createElement(d,s({ref:n},l))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,s=new Array(a);s[0]=u;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<a;p++)s[p]=t[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},43018:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>p});var o=t(83117),r=(t(67294),t(3905));const a={},s="Swift Example",i={unversionedId:"interviewPrep/designPatterns/Structural_patterns/Composite/swift/readme",id:"interviewPrep/designPatterns/Structural_patterns/Composite/swift/readme",title:"Swift Example",description:"",source:"@site/docs/interviewPrep/designPatterns/Structural_patterns/Composite/swift/readme.md",sourceDirName:"interviewPrep/designPatterns/Structural_patterns/Composite/swift",slug:"/interviewPrep/designPatterns/Structural_patterns/Composite/swift/",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Composite/swift/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Structural_patterns/Composite/swift/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Example 2",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Composite/python/example2"},next:{title:"Example 2",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Composite/swift/example2"}},c={},p=[],l={toc:p};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"swift-example"},"Swift Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'/// Composite Design Pattern\n///\n/// Intent: Lets you compose objects into tree structures and then work with\n/// these structures as if they were individual objects.\n\nimport XCTest\n\n/// The base Component class declares common operations for both simple and\n/// complex objects of a composition.\nprotocol Component {\n\n    /// The base Component may optionally declare methods for setting and\n    /// accessing a parent of the component in a tree structure. It can also\n    /// provide some default implementation for these methods.\n    var parent: Component? { get set }\n\n    /// In some cases, it would be beneficial to define the child-management\n    /// operations right in the base Component class. This way, you won\'t need\n    /// to expose any concrete component classes to the client code, even during\n    /// the object tree assembly. The downside is that these methods will be\n    /// empty for the leaf-level components.\n    func add(component: Component)\n    func remove(component: Component)\n\n    /// You can provide a method that lets the client code figure out whether a\n    /// component can bear children.\n    func isComposite() -> Bool\n\n    /// The base Component may implement some default behavior or leave it to\n    /// concrete classes.\n    func operation() -> String\n}\n\nextension Component {\n\n    func add(component: Component) {}\n    func remove(component: Component) {}\n    func isComposite() -> Bool {\n        return false\n    }\n}\n\n/// The Leaf class represents the end objects of a composition. A leaf can\'t\n/// have any children.\n///\n/// Usually, it\'s the Leaf objects that do the actual work, whereas Composite\n/// objects only delegate to their sub-components.\nclass Leaf: Component {\n\n    var parent: Component?\n\n    func operation() -> String {\n        return "Leaf"\n    }\n}\n\n/// The Composite class represents the complex components that may have\n/// children. Usually, the Composite objects delegate the actual work to their\n/// children and then "sum-up" the result.\nclass Composite: Component {\n\n    var parent: Component?\n\n    /// This fields contains the conponent subtree.\n    private var children = [Component]()\n\n    /// A composite object can add or remove other components (both simple or\n    /// complex) to or from its child list.\n    func add(component: Component) {\n        var item = component\n        item.parent = self\n        children.append(item)\n    }\n\n    func remove(component: Component) {\n        // ...\n    }\n\n    func isComposite() -> Bool {\n        return true\n    }\n\n    /// The Composite executes its primary logic in a particular way. It\n    /// traverses recursively through all its children, collecting and summing\n    /// their results. Since the composite\'s children pass these calls to their\n    /// children and so forth, the whole object tree is traversed as a result.\n    func operation() -> String {\n        let result = children.map({ $0.operation() })\n        return "Branch(" + result.joined(separator: " ") + ")"\n    }\n}\n\nclass Client {\n\n    /// The client code works with all of the components via the base interface.\n    static func someClientCode(component: Component) {\n        print("Result: " + component.operation())\n    }\n\n    /// Thanks to the fact that the child-management operations are also\n    /// declared in the base Component class, the client code can work with both\n    /// simple or complex components.\n    static func moreComplexClientCode(leftComponent: Component, rightComponent: Component) {\n        if leftComponent.isComposite() {\n            leftComponent.add(component: rightComponent)\n        }\n        print("Result: " + leftComponent.operation())\n    }\n}\n\n/// Let\'s see how it all comes together.\nclass CompositeConceptual: XCTestCase {\n\n    func testCompositeConceptual() {\n\n        /// This way the client code can support the simple leaf components...\n        print("Client: I\'ve got a simple component:")\n        Client.someClientCode(component: Leaf())\n\n        /// ...as well as the complex composites.\n        let tree = Composite()\n\n        let branch1 = Composite()\n        branch1.add(component: Leaf())\n        branch1.add(component: Leaf())\n\n        let branch2 = Composite()\n        branch2.add(component: Leaf())\n        branch2.add(component: Leaf())\n\n        tree.add(component: branch1)\n        tree.add(component: branch2)\n\n        print("\\nClient: Now I\'ve got a composite tree:")\n        Client.someClientCode(component: tree)\n\n        print("\\nClient: I don\'t need to check the components classes even when managing the tree:")\n        Client.moreComplexClientCode(leftComponent: tree, rightComponent: Leaf())\n    }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Client: I've got a simple component:\nResult: Leaf\n\nClient: Now I've got a composite tree:\nResult: Branch(Branch(Leaf Leaf) Branch(Leaf Leaf))\n\nClient: I don't need to check the components classes even when managing the tree:\nResult: Branch(Branch(Leaf Leaf) Branch(Leaf Leaf) Leaf)\n")))}m.isMDXComponent=!0}}]);