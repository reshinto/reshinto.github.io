"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[72460],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>h});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=o.createContext({}),p=function(e){var n=o.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},l=function(e){var n=p(e.components);return o.createElement(c.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),d=p(t),h=r,u=d["".concat(c,".").concat(h)]||d[h]||m[h]||a;return t?o.createElement(u,s(s({ref:n},l),{},{components:t})):o.createElement(u,s({ref:n},l))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,s=new Array(a);s[0]=d;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<a;p++)s[p]=t[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},81972:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>p});var o=t(83117),r=(t(67294),t(3905));const a={},s="TypeScript Example",i={unversionedId:"interviewPrep/designPatterns/Structural_patterns/Composite/typescript/readme",id:"interviewPrep/designPatterns/Structural_patterns/Composite/typescript/readme",title:"TypeScript Example",description:"",source:"@site/docs/interviewPrep/designPatterns/Structural_patterns/Composite/typescript/readme.md",sourceDirName:"interviewPrep/designPatterns/Structural_patterns/Composite/typescript",slug:"/interviewPrep/designPatterns/Structural_patterns/Composite/typescript/",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Composite/typescript/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Structural_patterns/Composite/typescript/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Example 2",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Composite/swift/example2"},next:{title:"Decorator",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Decorator/"}},c={},p=[],l={toc:p};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"typescript-example"},"TypeScript Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'/**\n * Composite Design Pattern\n *\n * Intent: Lets you compose objects into tree structures and then work with\n * these structures as if they were individual objects.\n */\n\n/**\n * The base Component class declares common operations for both simple and\n * complex objects of a composition.\n */\nabstract class Component {\n  protected parent: Component;\n\n  /**\n   * Optionally, the base Component can declare an interface for setting and\n   * accessing a parent of the component in a tree structure. It can also\n   * provide some default implementation for these methods.\n   */\n  public setParent(parent: Component) {\n    this.parent = parent;\n  }\n\n  public getParent(): Component {\n    return this.parent;\n  }\n\n  /**\n   * In some cases, it would be beneficial to define the child-management\n   * operations right in the base Component class. This way, you won\'t need to\n   * expose any concrete component classes to the client code, even during the\n   * object tree assembly. The downside is that these methods will be empty\n   * for the leaf-level components.\n   */\n  public add(component: Component): void {}\n\n  public remove(component: Component): void {}\n\n  /**\n   * You can provide a method that lets the client code figure out whether a\n   * component can bear children.\n   */\n  public isComposite(): boolean {\n    return false;\n  }\n\n  /**\n   * The base Component may implement some default behavior or leave it to\n   * concrete classes (by declaring the method containing the behavior as\n   * "abstract").\n   */\n  public abstract operation(): string;\n}\n\n/**\n * The Leaf class represents the end objects of a composition. A leaf can\'t have\n * any children.\n *\n * Usually, it\'s the Leaf objects that do the actual work, whereas Composite\n * objects only delegate to their sub-components.\n */\nclass Leaf extends Component {\n  public operation(): string {\n    return "Leaf";\n  }\n}\n\n/**\n * The Composite class represents the complex components that may have children.\n * Usually, the Composite objects delegate the actual work to their children and\n * then "sum-up" the result.\n */\nclass Composite extends Component {\n  protected children: Component[] = [];\n\n  /**\n   * A composite object can add or remove other components (both simple or\n   * complex) to or from its child list.\n   */\n  public add(component: Component): void {\n    this.children.push(component);\n    component.setParent(this);\n  }\n\n  public remove(component: Component): void {\n    const componentIndex = this.children.indexOf(component);\n    this.children.splice(componentIndex, 1);\n\n    component.setParent(null);\n  }\n\n  public isComposite(): boolean {\n    return true;\n  }\n\n  /**\n   * The Composite executes its primary logic in a particular way. It\n   * traverses recursively through all its children, collecting and summing\n   * their results. Since the composite\'s children pass these calls to their\n   * children and so forth, the whole object tree is traversed as a result.\n   */\n  public operation(): string {\n    const results = [];\n    for (const child of this.children) {\n      results.push(child.operation());\n    }\n\n    return `Branch(${results.join("+")})`;\n  }\n}\n\n/**\n * The client code works with all of the components via the base interface.\n */\nfunction clientCode(component: Component) {\n  // ...\n\n  console.log(`RESULT: ${component.operation()}`);\n\n  // ...\n}\n\n/**\n * This way the client code can support the simple leaf components...\n */\nconst simple = new Leaf();\nconsole.log("Client: I\'ve got a simple component:");\nclientCode(simple);\nconsole.log("");\n\n/**\n * ...as well as the complex composites.\n */\nconst tree = new Composite();\nconst branch1 = new Composite();\nbranch1.add(new Leaf());\nbranch1.add(new Leaf());\nconst branch2 = new Composite();\nbranch2.add(new Leaf());\ntree.add(branch1);\ntree.add(branch2);\nconsole.log("Client: Now I\'ve got a composite tree:");\nclientCode(tree);\nconsole.log("");\n\n/**\n * Thanks to the fact that the child-management operations are declared in the\n * base Component class, the client code can work with any component, simple or\n * complex, without depending on their concrete classes.\n */\nfunction clientCode2(component1: Component, component2: Component) {\n  // ...\n\n  if (component1.isComposite()) {\n    component1.add(component2);\n  }\n  console.log(`RESULT: ${component1.operation()}`);\n\n  // ...\n}\n\nconsole.log(\n  "Client: I don\'t need to check the components classes even when managing the tree:"\n);\nclientCode2(tree, simple);\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Client: I've got a simple component:\nRESULT: Leaf\n\nClient: Now I've got a composite tree:\nRESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf))\n\nClient: I don't need to check the components classes even when managing the tree:\nRESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf)+Leaf)\n")))}m.isMDXComponent=!0}}]);