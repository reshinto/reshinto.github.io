"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[115],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>c});var n=a(67294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,i=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(a),c=l,h=d["".concat(o,".").concat(c)]||d[c]||m[c]||i;return a?n.createElement(h,r(r({ref:t},u),{},{components:a})):n.createElement(h,r({ref:t},u))}));function c(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=a.length,r=new Array(i);r[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:l,r[1]=s;for(var p=2;p<i;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},23557:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var n=a(87462),l=(a(67294),a(3905));const i={},r="Template",s={unversionedId:"interviewPrep/designPatterns/Behavioral_patterns/Template/readme",id:"interviewPrep/designPatterns/Behavioral_patterns/Template/readme",title:"Template",description:"- it is a design pattern that defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure",source:"@site/docs/interviewPrep/designPatterns/Behavioral_patterns/Template/readme.md",sourceDirName:"interviewPrep/designPatterns/Behavioral_patterns/Template",slug:"/interviewPrep/designPatterns/Behavioral_patterns/Template/",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Template/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Behavioral_patterns/Template/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"TypeScript Example",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Strategy/typescript/"},next:{title:"C++ Example",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Template/cPlusPlus/"}},o={},p=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2},{value:"Analogy",id:"analogy",level:2},{value:"Structure",id:"structure",level:2},{value:"How to use",id:"how-to-use",level:2},{value:"How to implement",id:"how-to-implement",level:2},{value:"Pros and Cons",id:"pros-and-cons",level:2},{value:"Pros",id:"pros",level:3},{value:"Cons",id:"cons",level:3},{value:"Example",id:"example",level:2}],u={toc:p};function m(e){let{components:t,...i}=e;return(0,l.kt)("wrapper",(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"template"},"Template"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"it is a design pattern that defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure")),(0,l.kt)("h2",{id:"problem"},"Problem"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"when creating a data mining app that analyzes corporate documents",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"user feed the app documents in various formats (pdf, doc, csv)"),(0,l.kt)("li",{parentName:"ul"},"and tries to extract meaningful data from these docs in a uniform format"))),(0,l.kt)("li",{parentName:"ul"},"1st version of the app could only work only with DOC files",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"next version able to support CSV files"),(0,l.kt)("li",{parentName:"ul"},"later it can extract PDF files"))),(0,l.kt)("li",{parentName:"ul"},"at some point, you realized that all 3 classes have a lot of similar code",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"while the code for dealing with various data formats was entirely different in all classes",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the code for data processing and analysis is almost identical"),(0,l.kt)("li",{parentName:"ul"},"would be great to get rid of code duplication",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"and leave the algorithm structure intact"))))))),(0,l.kt)("li",{parentName:"ul"},"there is another problem related to client code that used these classes",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it had lots of conditionals that picked a proper course of action depending on the class of the processing object"),(0,l.kt)("li",{parentName:"ul"},"if all 3 processing classes had a common interface or a base class",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"one can eliminate the conditionals in client code"),(0,l.kt)("li",{parentName:"ul"},"and use polymorphism when calling methods on a processing object")))))),(0,l.kt)("h2",{id:"solution"},"Solution"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the pattern suggest that you break down an algorithm into a series of steps",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"turn these steps into methods"),(0,l.kt)("li",{parentName:"ul"},"and put a series of calls to these methods inside a single template method"),(0,l.kt)("li",{parentName:"ul"},"the steps may either be abstract or have some default implementation"),(0,l.kt)("li",{parentName:"ul"},"to use the algorithm, the client is supposed to provide its own subclass",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"implement all abstract steps and override some of the optional ones if needed but not the template method itself"))))),(0,l.kt)("li",{parentName:"ul"},"a base class can be created for all algorithms",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the class defines a template method consisting of a series of calls to various document processing steps"))),(0,l.kt)("li",{parentName:"ul"},"at first, we can declare all steps abstract",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"forcing the subclasses to provide their own implementations for these methods"),(0,l.kt)("li",{parentName:"ul"},"for this case, subclasses already have all necessary implementations",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the only thing needed is to adjust signatures of the methods to match the methods of the superclass"))))),(0,l.kt)("li",{parentName:"ul"},"to get rid of duplicate code",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the code for opening/closing files and extracting/parsing data is different for various data formats",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"no point touching these methods"))),(0,l.kt)("li",{parentName:"ul"},"however, implementation of other steps such as analyzing raw data & composing reports is similar"),(0,l.kt)("li",{parentName:"ul"},"so it can pulled up into the base class where subclasses can share that code"))),(0,l.kt)("li",{parentName:"ul"},"there are 2 types of steps",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"abstract steps must be implemented by every subclass"),(0,l.kt)("li",{parentName:"ul"},"optional steps already have some default implementation, but still can be overridden if needed"))),(0,l.kt)("li",{parentName:"ul"},"there is another type of step, called hooks",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it is an optional step with an empty body"),(0,l.kt)("li",{parentName:"ul"},"a template method would work even if a hook isn't overridden"),(0,l.kt)("li",{parentName:"ul"},"usually hooks are placed before and after crucial steps of algorithms",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"providing subclasses with additional extension points for an algorithm")))))),(0,l.kt)("h2",{id:"analogy"},"Analogy"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the template method approach can be used in mass housing construction",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the architectural plan for building a standard house may contain several extension points that would let a potential owner adjust some details of the resulting house"))),(0,l.kt)("li",{parentName:"ul"},"each building step such as laying the foundation, framing, building walls, installing plumbing and wiring for water and electricity, can be slightly changed to make the resulting house a little bit different from others")),(0,l.kt)("h2",{id:"structure"},"Structure"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Template",src:a(40230).Z,width:"734",height:"768"})),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"The Abstract Class declares methods that act as steps of an algorithm, as well as the actual template method which calls these methods in a specific order."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The steps may either be declared abstract or have some default implementation."))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Concrete Classes can override all of the steps, but not the template method itself."))),(0,l.kt)("h2",{id:"how-to-use"},"How to use"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Use the Template Method pattern when you want to let clients extend only particular steps of an algorithm, but not the whole algorithm or its structure",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The Template Method lets you turn a monolithic algorithm into a series of individual steps which can be easily extended by subclasses while keeping intact the structure defined in a superclass"))),(0,l.kt)("li",{parentName:"ul"},"Use the pattern when you have several classes that contain almost identical algorithms with some minor differences",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"As a result, you might need to modify all classes when the algorithm changes"),(0,l.kt)("li",{parentName:"ul"},"When you turn such an algorithm into a template method, you can also pull up the steps with similar implementations into a superclass, eliminating code duplication"),(0,l.kt)("li",{parentName:"ul"},"Code that varies between subclasses can remain in subclasses")))),(0,l.kt)("h2",{id:"how-to-implement"},"How to implement"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Analyze the target algorithm to see whether you can break it into steps",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"consider which steps are common to all subclasses and which ones will always be unique"))),(0,l.kt)("li",{parentName:"ol"},"create the abstract base class and declare the template method and a set of abstract methods representing the algorithm's steps",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"outline the algorithm's structure in the template method by executing corresponding steps"),(0,l.kt)("li",{parentName:"ul"},"consider making the template method final to prevent final to prevent subclasses from overriding it"))),(0,l.kt)("li",{parentName:"ol"},"it is okay if all steps end by being abstract",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"however, some steps might benefit from having a default implementation"),(0,l.kt)("li",{parentName:"ul"},"subclasses don't have to implement those methods"))),(0,l.kt)("li",{parentName:"ol"},"think of adding hooks between the crucial steps of the algorithm"),(0,l.kt)("li",{parentName:"ol"},"for each variation of the algorithm, create a new concrete subclass",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it must implement all of the abstract steps, but may also override some of the optional ones")))),(0,l.kt)("h2",{id:"pros-and-cons"},"Pros and Cons"),(0,l.kt)("h3",{id:"pros"},"Pros"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"can let clients override only certain parts of a large algorithm",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"making them less affected by changes that happen to other parts of the algorithm"))),(0,l.kt)("li",{parentName:"ul"},"can pull the duplicate code into a superclass")),(0,l.kt)("h3",{id:"cons"},"Cons"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"some clients may be limited by the provided skeleton of an algorithm"),(0,l.kt)("li",{parentName:"ul"},"you might violate the Liskov Substitution Principle by suppressing a default step implementation via a subclass"),(0,l.kt)("li",{parentName:"ul"},"template methods tend to be harder to maintain the more steps they have")),(0,l.kt)("h2",{id:"example"},"Example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'abstract class Builder {\n  // Template method\n  public build() {\n    this.test();\n    this.lint();\n    this.assemble();\n    this.deploy();\n  }\n\n  abstract test();\n  abstract lint();\n  abstract assemble();\n  abstract deploy();\n}\n\nclass AndroidBuilder extends Builder {\n  public test() {\n    return "Running android tests";\n  }\n  public lint() {\n    return "Linting android code";\n  }\n  public assemble() {\n    return "Assembling android build";\n  }\n  public deploy() {\n    return "Deploying android build to server";\n  }\n}\n\nclass IosBuilder extends Builder {\n  public test() {\n    return "Running ios tests";\n  }\n  public lint() {\n    return "Linting ios code";\n  }\n  public assemble() {\n    return "Assembling ios build";\n  }\n  public deploy() {\n    return "Deploying ios build to server";\n  }\n}\n\nconst androidBuilder = new AndroidBuilder();\n\nandroidBuilder.build();\n// Running android tests\n// Linting android code\n// Assembling android build\n// Deploying android build to server\n\nconst iosBuilder = new IosBuilder();\n\nandroidBuilder.build();\n// Running ios tests\n// Linting ios code\n// Assembling ios build\n// Deploying ios build to server\n')))}m.isMDXComponent=!0},40230:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/template-8a81efe3cb812b5123e62bb3d45b776f.png"}}]);