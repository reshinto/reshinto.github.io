"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[82767],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var o=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,o,n=function(e,t){if(null==e)return{};var a,o,n={},r=Object.keys(e);for(o=0;o<r.length;o++)a=r[o],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)a=r[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=o.createContext({}),m=function(e){var t=o.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=m(e.components);return o.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},c=o.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=m(a),u=n,d=c["".concat(l,".").concat(u)]||c[u]||h[u]||r;return a?o.createElement(d,i(i({ref:t},p),{},{components:a})):o.createElement(d,i({ref:t},p))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,i=new Array(r);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var m=2;m<r;m++)i[m]=a[m];return o.createElement.apply(null,i)}return o.createElement.apply(null,a)}c.displayName="MDXCreateElement"},72461:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>m});var o=a(83117),n=(a(67294),a(3905));const r={},i="Memento",s={unversionedId:"interviewPrep/designPatterns/Behavioral_patterns/Memento/readme",id:"interviewPrep/designPatterns/Behavioral_patterns/Memento/readme",title:"Memento",description:"- it lets you save and restore the previous state of an object without revealing the details of its implementation",source:"@site/docs/interviewPrep/designPatterns/Behavioral_patterns/Memento/readme.md",sourceDirName:"interviewPrep/designPatterns/Behavioral_patterns/Memento",slug:"/interviewPrep/designPatterns/Behavioral_patterns/Memento/",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Memento/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Behavioral_patterns/Memento/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"TypeScript Example",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Mediator/typescript/"},next:{title:"C++ Example",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Memento/cPlusPlus/"}},l={},m=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2},{value:"Structure",id:"structure",level:2},{value:"When to use",id:"when-to-use",level:2},{value:"How to implement",id:"how-to-implement",level:2},{value:"Pros &amp; Cons",id:"pros--cons",level:2},{value:"Pros",id:"pros",level:3},{value:"Cons",id:"cons",level:3}],p={toc:m};function h(e){let{components:t,...r}=e;return(0,n.kt)("wrapper",(0,o.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"memento"},"Memento"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"it lets you save and restore the previous state of an object without revealing the details of its implementation")),(0,n.kt)("h2",{id:"problem"},"Problem"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"imagine developing a text editor app, it can do text editing, format text, and insert inline images"),(0,n.kt)("li",{parentName:"ul"},"you decided to let users undo any operations carried out on the text",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"you decided to take the direct approach for implementation"),(0,n.kt)("li",{parentName:"ul"},"before performing any operation, the app records the state of all objects and saves it in some storage"),(0,n.kt)("li",{parentName:"ul"},"later when a user decides to revert an action, the app fetches the latest snapshot from the history and uses it to restore the state of all objects",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"regarding the state snapshot, how would you produce one?"),(0,n.kt)("li",{parentName:"ul"},"you would need to go over all the fields in an object and copy their values into storage",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"however, this would only work if the object had quite relaxed access restrictions to its contents"),(0,n.kt)("li",{parentName:"ul"},"unfortunately, most real objects won't let others peek inside them that easily, which hides all significant data in private fields"))),(0,n.kt)("li",{parentName:"ul"},"assuming that our objects behave like hippies",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"prefer open relations and keeping their state public"),(0,n.kt)("li",{parentName:"ul"},"this approach would solve the immediate problem and let you produce snapshots of objects' states at will"),(0,n.kt)("li",{parentName:"ul"},"it still has some serious issues",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"in the future, you might decide to refactor some of the editor classes or add or remove some of the fields"),(0,n.kt)("li",{parentName:"ul"},"this would also require changing the classes responsible for copying the state of the affected objects"))))))),(0,n.kt)("li",{parentName:"ul"},"Considering the actual snapshots of the editor's state",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"what data does it contain",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"at a bare minimum, it must contain the actual text, cursor coordinates, current scroll position, etc"))),(0,n.kt)("li",{parentName:"ul"},"to make a snapshot, you would need to collect these values and put them into some kind of container"),(0,n.kt)("li",{parentName:"ul"},"most likely you would store lots of these container objects inside some list that would represent the history",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"containers would end up being objects of 1 class"),(0,n.kt)("li",{parentName:"ul"},"class would have almost no methods, but lots of fields that mirror the editor's state"))),(0,n.kt)("li",{parentName:"ul"},"to allow other objects to write and read data to and from a snapshot, the fields need to be public",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"that would expose all the editor's state, private or not"),(0,n.kt)("li",{parentName:"ul"},"other classes would become dependent on every little change to the snapshot class"))))))),(0,n.kt)("li",{parentName:"ul"},"this reaches a dead end",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"you either expose all internal details of classes, making them too fragile"),(0,n.kt)("li",{parentName:"ul"},"or restrict access to their state, making it impossible to produce snapshots")))),(0,n.kt)("h2",{id:"solution"},"Solution"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"the problems are caused by broken encapsulation",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"some objects try to do more than they are supposed to"),(0,n.kt)("li",{parentName:"ul"},"they try to invade the private space of other objects instead of letting these objects perform the actual action, so as to collect the data required to perform the action"))),(0,n.kt)("li",{parentName:"ul"},"Memento pattern delegates creating the state snapshots to the actual owner of that state (the originator object)",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"hence, instead of other objects trying to copy the editor's state from the outside",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"the editor class itself can make the snapshot since it has full access to its own state"))))),(0,n.kt)("li",{parentName:"ul"},"the pattern suggests storing the copy of the object's state in a special object called memento",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"the contents of the memento aren't accessible to any other object except the one that produced it"),(0,n.kt)("li",{parentName:"ul"},"other objects must communicate with mementos using a limited interface which may allow fetching the snapshot's metadata",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"but not the original object's state contained in the snapshot"))))),(0,n.kt)("li",{parentName:"ul"},"such a restrictive policy lets you store mementos inside other objects",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"usually called caretaker"),(0,n.kt)("li",{parentName:"ul"},"since the caretaker works with the memento only via the limited interface",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"it's not able to tamper with the state stored inside the memento"),(0,n.kt)("li",{parentName:"ul"},"at the same time, the originator has access to all fields inside the memento",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"allowing it to restore its previous state at will"))))))),(0,n.kt)("li",{parentName:"ul"},"in the text editor example, we can create a separate history class to act as the caretaker",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"a stack of mementos stored inside the caretaker will grow each time the editor is about to execute an operation"),(0,n.kt)("li",{parentName:"ul"},"you could render this stack within the UI, displaying the history of previously performed operations to a user"))),(0,n.kt)("li",{parentName:"ul"},"when a user triggers the undo, the history grabs the most recent memento from the stack and passes it back to the editor, requesting a roll-back",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"since the editor has full access to the memento, it changes its own state with the values taken from the memento")))),(0,n.kt)("h2",{id:"structure"},"Structure"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Memento",src:a(12919).Z,width:"1194",height:"642"}),"\n",(0,n.kt)("img",{alt:"Memento_intermediate_interface",src:a(23612).Z,width:"1638",height:"744"}),"\n",(0,n.kt)("img",{alt:"Memento_stricter_encapsulation",src:a(52155).Z,width:"1688",height:"950"})),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"The Originator class can produce snapshots of its own state, as well as restore its state from snapshots when needed.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"The Memento is a value object that acts as a snapshot of the originator\u2019s state."),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"It\u2019s a common practice to make the memento immutable and pass it the data only once, via the constructor."))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"The Caretaker knows not only \u201cwhen\u201d and \u201cwhy\u201d to capture the originator\u2019s state, but also when the state should be restored."),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"A caretaker can keep track of the originator\u2019s history by storing a stack of mementos. When the originator has to travel back in history, the caretaker fetches the topmost memento from the stack and passes it to the originator\u2019s restoration method."))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"In this implementation, the memento class is nested inside the originator."),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"This lets the originator access the fields and methods of the memento, even though they\u2019re declared private."),(0,n.kt)("li",{parentName:"ul"},"On the other hand, the caretaker has very limited access to the memento\u2019s fields and methods, which lets it store mementos in a stack but not tamper with their state.")))),(0,n.kt)("h2",{id:"when-to-use"},"When to use"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Use the Memento pattern when you want to produce snapshots of the object\u2019s state to be able to restore a previous state of the object",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"it lets you make full copies of an object\u2019s state, including private fields, and store them separately from the object"),(0,n.kt)("li",{parentName:"ul"},"While most people remember this pattern thanks to the \u201cundo\u201d use case, it\u2019s also indispensable when dealing with transactions"))),(0,n.kt)("li",{parentName:"ul"},"Use the pattern when direct access to the object\u2019s fields/getters/setters violates its encapsulation",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"it makes the object itself responsible for creating a snapshot of its state"),(0,n.kt)("li",{parentName:"ul"},"No other object can read the snapshot, making the original object\u2019s state data safe and secure")))),(0,n.kt)("h2",{id:"how-to-implement"},"How to implement"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Determine what class will play the role of the originator"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"It\u2019s important to know whether the program uses one central object of this type or multiple smaller ones"))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Create the memento class"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"One by one, declare a set of fields that mirror the fields declared inside the originator class"))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Make the memento class immutable"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"A memento should accept the data just once, via the constructor"),(0,n.kt)("li",{parentName:"ul"},"The class should have no setters"))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"If your programming language supports nested classes, nest the memento inside the originator"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"If not, extract a blank interface from the memento class and make all other objects use it to refer to the memento"),(0,n.kt)("li",{parentName:"ul"},"You may add some metadata operations to the interface, but nothing that exposes the originator\u2019s state"))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Add a method for producing mementos to the originator class"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The originator should pass its state to the memento via one or multiple arguments of the memento\u2019s constructor"),(0,n.kt)("li",{parentName:"ul"},"The return type of the method should be of the interface you extracted in the previous step (assuming that you extracted it at all)"),(0,n.kt)("li",{parentName:"ul"},"Under the hood, the memento-producing method should work directly with the memento class"))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Add a method for restoring the originator\u2019s state to its class"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"It should accept a memento object as an argument"),(0,n.kt)("li",{parentName:"ul"},"If you extracted an interface in the previous step, make it the type of the parameter"),(0,n.kt)("li",{parentName:"ul"},"In this case, you need to typecast the incoming object to the memento class, since the originator needs full access to that object"))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"The caretaker, whether it represents a command object, a history, or something entirely different, should know when to request new mementos from the originator, how to store them and when to restore the originator with a particular memento")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"The link between caretakers and originators may be moved into the memento class"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"In this case, each memento must be connected to the originator that had created it"),(0,n.kt)("li",{parentName:"ul"},"The restoration method would also move to the memento class"),(0,n.kt)("li",{parentName:"ul"},"However, this would all make sense only if the memento class is nested into originator or the originator class provides sufficient setters for overriding its state")))),(0,n.kt)("h2",{id:"pros--cons"},"Pros & Cons"),(0,n.kt)("h3",{id:"pros"},"Pros"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"You can produce snapshots of the object\u2019s state without violating its encapsulation"),(0,n.kt)("li",{parentName:"ul"},"You can simplify the originator\u2019s code by letting the caretaker maintain the history of the originator\u2019s state")),(0,n.kt)("h3",{id:"cons"},"Cons"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The app might consume lots of RAM if clients create mementos too often"),(0,n.kt)("li",{parentName:"ul"},"Caretakers should track the originator\u2019s lifecycle to be able to destroy obsolete mementos"),(0,n.kt)("li",{parentName:"ul"},"Most dynamic programming languages, such as PHP, Python and JavaScript, can\u2019t guarantee that the state within the memento stays untouched")))}h.isMDXComponent=!0},12919:(e,t,a)=>{a.d(t,{Z:()=>o});const o=a.p+"assets/images/memento-0788545a637864f3bcfa1cf9254996e7.png"},23612:(e,t,a)=>{a.d(t,{Z:()=>o});const o=a.p+"assets/images/memento_intermediate_interface-7cf6f992f480c4a42ef7af38938343f4.png"},52155:(e,t,a)=>{a.d(t,{Z:()=>o});const o=a.p+"assets/images/memento_stricter_encapsulation-5b46d8d4c48b88d6a53190f1c2bb0c4d.png"}}]);