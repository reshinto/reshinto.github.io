"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[214],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>h});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},m=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(t),h=i,d=u["".concat(s,".").concat(h)]||u[h]||c[h]||r;return t?a.createElement(d,l(l({ref:n},m),{},{components:t})):a.createElement(d,l({ref:n},m))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=u;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},4695:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(7462),i=(t(7294),t(3905));const r={},l="Object Oriented Programming",o={unversionedId:"basics/programmingParadigm/OOP/readme",id:"basics/programmingParadigm/OOP/readme",title:"Object Oriented Programming",description:"- it is a style of programming or a programming paradigm",source:"@site/docs/basics/programmingParadigm/OOP/readme.md",sourceDirName:"basics/programmingParadigm/OOP",slug:"/basics/programmingParadigm/OOP/",permalink:"/docs/basics/programmingParadigm/OOP/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/basics/programmingParadigm/OOP/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Functional Language Possibilities",permalink:"/docs/basics/programmingParadigm/FP/functionalLanguagePossibilities"},next:{title:"Object-oriented Design",permalink:"/docs/basics/programmingParadigm/OOP/OOD"}},s={},p=[{value:"4 pillars of OOP",id:"4-pillars-of-oop",level:2},{value:"Encapsulation",id:"encapsulation",level:3},{value:"Abstraction",id:"abstraction",level:3},{value:"Inheritance",id:"inheritance",level:3},{value:"Polymorphism - literally means many forms",id:"polymorphism---literally-means-many-forms",level:3},{value:"Value types vs Reference types",id:"value-types-vs-reference-types",level:2},{value:"Value types",id:"value-types",level:3},{value:"Reference types",id:"reference-types",level:3},{value:"Factory",id:"factory",level:2},{value:"Constructor",id:"constructor",level:2}],m={toc:p};function c(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"object-oriented-programming"},"Object Oriented Programming"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"it is a style of programming or a programming paradigm"),(0,i.kt)("li",{parentName:"ul"},"it combines a group of related variables and functions into a unit",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the unit is referred to as an object"),(0,i.kt)("li",{parentName:"ul"},"the variables are referred to as properties"),(0,i.kt)("li",{parentName:"ul"},"the functions are referred to as methods"))),(0,i.kt)("li",{parentName:"ul"},"e.g.: a CAR object",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'has properties of "make, model, color"'),(0,i.kt)("li",{parentName:"ul"},'and methods of "start(), stop(), move()"')))),(0,i.kt)("h2",{id:"4-pillars-of-oop"},"4 pillars of OOP"),(0,i.kt)("h3",{id:"encapsulation"},"Encapsulation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"a concept that binds together the data and functions that manipulate the data, and that keeps both safe from outside interference and misuse")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"a tool that helps to hide unimportant implementation details out of sight")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"most commonly used in the context of information hiding")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Public mutable data violates encapsulation"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"because any client of the class can change the internal state of the class object without the notification of the class"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To achieve encapsulation in the design, two components are distinguished, its public interface and the private part"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the public part should expose more about what the class does and hide unnecessary implementation details from clients"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Abstraction and encapsulation complement each other and form some more general holistic picture of the object-oriented programming paradigm")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"play a key role in fighting complexity, providing the ability to design at a higher level, abstracting from implementation details")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"example 1"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// procedural programming\nlet baseSalary = 30000;\nlet overtime = 10;\nlet rate = 20;\nfunction getWage(baseSalary, overtime, rate) {\n  return baseSalary + overtime * rate;\n}\ngetWage(baseSalary, overtime, rate);\n\n// encapsulation - this is better because getWage method does not requires any parameters\n// the fewer the number of parameters, the easier it is to use and maintain that function\nlet employee = {\n  baseSalary: 30000,\n  overtime: 10,\n  rate: 20,\n  getWage: function () {\n    return this.baseSalary + this.overtime * this.rate;\n  },\n};\nemployee.getWage();\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"example 2"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Encapsulation is violated"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Paystub {\n  private readonly employees: Employee[];\n\n  public getEmployees(): Employee[] {\n    return this.employees;\n  }\n\n  public computePayroll(): number {\n    // using this.employees for calculation\n    return 42;\n  }\n}\n\nconst p1 = new Paystub();\n// if employees data type changed, we can't add employee\nconst employees = p1.getEmployees();\n\nemployees.push(new Employee());\nemployees.push(new Employee());\n\np1.computePayroll();\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Encapsulation is not violated"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Paystub2 {\n  private readonly employees: Employee[];\n\n  public addEmployee(employee: Employee): void {\n    this.employees.push(employee);\n  }\n\n  public computePayroll(): number {\n    // using this.employees for calculation\n    return 42;\n  }\n}\n\nconst p2 = new Paystub2();\n\n// there will never be an issue when adding employee\np2.addEmployee(new Employee());\np2.addEmployee(new Employee());\n\np2.computePayroll();\n")))))),(0,i.kt)("h3",{id:"abstraction"},"Abstraction"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"it highlights some significant parts, meaningful information from a component, no matter whether it is a class or an architectural layer in the system, or a logical unit of our system")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"(summary): it is the highlighting of significant parts or exclusion of insignificant parts from consideration"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The act of representing essential features without including the background details or explanations"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In OOP, only data abstraction is considered"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"it is called as ",(0,i.kt)("inlineCode",{parentName:"li"},"abstraction")," implying a set of the most significant characteristics of an object available for the program"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"it is essential when dealing with system complexity by hiding implementation details and highlighting essential aspects of behavior")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"main idea of abstraction is to describe real life objects and how they interact in a software system")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"play a key role in fighting complexity, providing the ability to design at a higher level, abstracting from implementation details")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"can be implemented using interfaces and abstract classes")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"example 1"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'function Employee(name, age, baseSalary) {\n  this.name = name;\n  this.age = age;\n  this.baseSalary = baseSalary;\n  let monthlyBonus = 1500;\n\n  // abstraction creation\n  let calculateFinalSalary = function () {\n    let finalSalary = baseSalary + monthlyBonus;\n    console.log(finalSalary);\n  };\n\n  this.getEmployeeDetails = function () {\n    console.log(this.name);\n    calculateFinalSalary; // abstraction implementation;\n  };\n}\n\nconst employee = new Employee("John", 30, 2000);\nemployee.getEmployeeDetails();\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"example 2: implementation details, is the more unstable part of the abstraction, it can change while maintaining the public interface"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'enum CoffeeSelection {\n  FILTER_COFFEE,\n  ESPRESSO,\n  CAPPUCCINO,\n}\n\nclass CoffeeBean {\n  // implementation of CoffeeBeen\n}\n\nclass Coffee {\n  constructor(selection: CoffeeSelection, volume: number) {\n    // implementation of Coffee\n  }\n}\n\nclass Configuration {\n  constructor(weight: number, volume: number) {\n    // implementation of Configuration\n  }\n}\n\n// abstraction\n// implementation details are changed systematically, the requirements are changed systematically\n// the main thing is not to change the public interface on which clients depend\nclass CoffeeMachine {\n  private configMap: Map<CoffeeSelection, Configuration>;\n  private beans: Map<CoffeeSelection, CoffeeBean>;\n\n  constructor(beans: Map<CoffeeSelection, CoffeeBean>) {\n    this.beans = beans;\n    // create coffee configuration\n    this.configMap = new Map<CoffeeSelection, Configuration>();\n    this.configMap.set(CoffeeSelection.ESPRESSO, new Configuration(8, 28));\n    this.configMap.set(\n      CoffeeSelection.FILTER_COFFEE,\n      new Configuration(30, 480)\n    );\n  }\n\n  // The client knows that the coffee machine has only this method\n  // Everything else, all the settings of the coffee machine, initialization in the constructor of some configuration of everything else\n  // for the client this is not meaningful behavior, it should not depend on it, because it is unstable, it can change\n  public brewCoffee(selection: CoffeeSelection): Coffee {\n    const coffee = new Coffee(selection, 100);\n\n    console.log("Making coffee...");\n\n    return coffee;\n  }\n}\n\nconst main = () => {\n  // create a |Map of available coffee beans\n  const beans = new Map<CoffeeSelection, CoffeeBean>();\n\n  beans.set(\n    CoffeeSelection.ESPRESSO,\n    new CoffeeBean("My favorite espresso bean", 1000)\n  );\n  beans.set(\n    CoffeeSelection.FILTER_COFFEE,\n    new CoffeeBean("My favorite filter coffee bean", 1000)\n  );\n\n  // get a new CoffeeMachine object\n  const machine = new CoffeeMachine(beans);\n\n  // brew a fresh coffee\n  const espresso: Coffee = machine.brewCoffee(CoffeeSelection.ESPRESSO);\n};\n')))),(0,i.kt)("h3",{id:"inheritance"},"Inheritance"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"it is a mechanism that allows you to eliminate redundant code")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"it has a relationship between classes that lets you inherit or extend functionality from 1 class to another")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This is an ",(0,i.kt)("inlineCode",{parentName:"p"},"is")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"is a")," relationship"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"a relationship between a base class and descendants"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This relationship is the strongest and in statically typed languages it cannot be broken"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this must be considered when assessing the need to use inheritance in this case"),(0,i.kt)("li",{parentName:"ul"},"If inheritance were applied in a place where one could do without it",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this will make it difficult to understand and maintain code"),(0,i.kt)("li",{parentName:"ul"},"because the inheritance hierarchy can be 10 classes or more"),(0,i.kt)("li",{parentName:"ul"},"it is difficult to understand somewhere in the middle or how the last class will behave"),(0,i.kt)("li",{parentName:"ul"},"hard to understand in what places which methods are being overwritten or overridden"),(0,i.kt)("li",{parentName:"ul"},"Therefore, inheritance must be approached wisely"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"not all Object Oriented languages are the same"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"c++ supports multiple inheritance"),(0,i.kt)("li",{parentName:"ul"},"java only supports single inheritance",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"each class can extend or inherit functionality from only 1 other class"),(0,i.kt)("li",{parentName:"ul"},"classes can implement multiple interfaces"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"inheritance relationship"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Parent/Child, Base/Derived, Superclass/Subclass"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"example"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'class Person {\n  protected name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass Employee extends Person {\n  private department: string;\n\n  constructor(name: string, department: string) {\n    super(name);\n    this.department = department;\n  }\n\n  public getDetails() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n  }\n}\n\nconst howard = new Employee("Howard", "Sales");\n\nconsole.log(howard.getDetails()); // ok\nconsole.log(howard.name); // error\nconsole.log(howard.department); // error\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"3 access modifiers"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Private",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"not accessible from the outside"),(0,i.kt)("li",{parentName:"ul"},"only instances of this current class can work with these properties"),(0,i.kt)("li",{parentName:"ul"},"The Employee class has a department property"),(0,i.kt)("li",{parentName:"ul"},"only objects of the Employee class can work with this property"))),(0,i.kt)("li",{parentName:"ul"},"Protected",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"is a little wider than private"),(0,i.kt)("li",{parentName:"ul"},"only instances of the current class and classes of descendants can work with them"),(0,i.kt)("li",{parentName:"ul"},"From Employee, we can refer to name from Person"),(0,i.kt)("li",{parentName:"ul"},"they are also closed to the outside world"))),(0,i.kt)("li",{parentName:"ul"},"Public",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"public properties and methods are those that are provided to clients in the form of a public interface"),(0,i.kt)("li",{parentName:"ul"},"it should be the most stable and the most unchangeable")))))),(0,i.kt)("h3",{id:"polymorphism---literally-means-many-forms"},"Polymorphism - literally means many forms"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The provision of a single interface to entities of different types or the use of a single symbol to represent multiple different types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"it addresses an object as either super or subtype")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"writes methods that accept supertype as arguments")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"passes instances of subtypes")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"increases code flxibility and reusability")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"has 2 types"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Compile time polymorphism (static binding / static polymorphism)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"e.g.: method overloading",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"allows you to implement multiple methods within the same class that use the same name but different types/order/number of parameters"))))),(0,i.kt)("li",{parentName:"ol"},"Runtime polymorphism (dynamic binding / dynamic polymorphism)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"e.g.: method overriding",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"does not allow the compiler to determine the executed method"),(0,i.kt)("li",{parentName:"ul"},"Within an inheritance hierarchy, a subclass can override a method of its superclass",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"That enables the developer of the subclass to customize or completely replace the behavior of that method"))),(0,i.kt)("li",{parentName:"ul"},"Overriding is about same method, same signature but different classes connected through inheritance"))))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"example 1"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  makeSound() {\n    console.log("Generic animal sound");\n  }\n}\n\n// polymorphism - override the makeSound method\nclass Dog extends Animal {\n  constructor(name) {\n    super(name);\n  }\n\n  makeSound() {\n    console.log("Woof!");\n  }\n}\nconst dog = new Dog("Happy");\ndog.makeSound(); // "Woof!"\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"example 2: Static polymorphism: overloading"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'interface Hero {\n  name: string;\n  skill: string;\n  weakness: string;\n}\n\nclass HeroService {\n  protected heroes: Hero[] = [\n    {name: "Superman", skill: "fly", weakness: "cryptonit"},\n    {name: "Spiderman", skill: "spider-sense", weakness: "MJ"},\n    {name: "Batman", skill: "superhuman power", weakness: "law"},\n    {name: "Flash", skill: "run", weakness: "unknown"},\n  ];\n\n  public getHero(name: string);\n  public getHero(name: string, skill: string);\n\n  public getHero(name: string, skill?: string): Hero {\n    if (!skill) {\n      return this.heroes.find((hero) => hero.name === name);\n    }\n\n    return this.heroes.find(\n      (hero) => hero.name === name && hero.skill === skill\n    );\n  }\n}\n\nconst heroService = new HeroService();\nconst hero1 = heroService.getHero("Flash");\nconst hero2 = heroService.getHero("Superman", "fly");\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"example 3: Dynamic polymorphism: overriding"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'class HeroService {\n  // implementation of HeroService\n}\n\nclass AntiHeroService extends HeroService {\n  public getHero(weakness: string): Hero {\n    return this.heroes.find((hero) => hero.weakness === weakness);\n  }\n}\n\nconst antiHeroService = new AntiHeroService();\nconst hero = antiHeroService.getHero("law");\n')))),(0,i.kt)("h2",{id:"value-types-vs-reference-types"},"Value types vs Reference types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"primitives are copied by their value")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// example 1\nlet x = 0;\nlet y = x;\nx = 20; // y = 0, x = 20\n\n// example 2\nlet number = 10;\nfunction increase(number) {\n  number++;\n}\nincrease(number);\nconsole.log(number); // number = 10\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"objects are copied by their reference")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// example 1\nlet x = {value: 0};\nlet y = x;\nx.value = 20; // y = { value: 20 }\n\n// example 2\nlet obj = {value: 10};\nfunction increase(obj) {\n  obj.value++;\n}\nincrease(obj);\nconsole.log(obj); // { value: 11 }\n")),(0,i.kt)("h3",{id:"value-types"},"Value types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"number, string, boolean, symbol, undefined, null")),(0,i.kt)("h3",{id:"reference-types"},"Reference types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"object, function, array")),(0,i.kt)("h2",{id:"factory"},"Factory"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'// normal code - needs to make multiple of the same objects if have different radius value\nconst circle = {\n  radius: 1,\n  draw: function () {\n    console.log("draw");\n  },\n};\ncircle.draw();\n\n// factory function - only need to change the value in the parameter during initialization\nfunction createCircle(radius) {\n  return {\n    radius,\n    draw: function () {\n      console.log("draw");\n    },\n  };\n}\n\nconst circle = createCircle(1);\ncircle.draw();\n')),(0,i.kt)("h2",{id:"constructor"},"Constructor"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'// constructor function\nfunction Circle(radius) {\n  this.radius = radius;\n  this.draw = function () {\n    console.log("draw");\n  };\n}\n\nconst circle = new Circle(1);\ncircle.draw();\n')))}c.isMDXComponent=!0}}]);