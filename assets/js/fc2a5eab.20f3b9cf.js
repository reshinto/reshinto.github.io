"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[39846],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,h=u["".concat(s,".").concat(d)]||u[d]||c[d]||i;return n?a.createElement(h,l(l({ref:t},m),{},{components:n})):a.createElement(h,l({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},20937:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(83117),r=(n(67294),n(3905));const i={},l="Object Oriented Programming",o={unversionedId:"interviewPrep/programmingParadigm/OOP/readme",id:"interviewPrep/programmingParadigm/OOP/readme",title:"Object Oriented Programming",description:"- it is a style of programming or a programming paradigm",source:"@site/docs/interviewPrep/programmingParadigm/OOP/readme.md",sourceDirName:"interviewPrep/programmingParadigm/OOP",slug:"/interviewPrep/programmingParadigm/OOP/",permalink:"/docs/interviewPrep/programmingParadigm/OOP/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/programmingParadigm/OOP/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Main Concepts",permalink:"/docs/interviewPrep/programmingParadigm/FP/mainConcepts"},next:{title:"Object-oriented Design",permalink:"/docs/interviewPrep/programmingParadigm/OOP/OOD"}},s={},p=[{value:"4 pillars of OOP",id:"4-pillars-of-oop",level:2},{value:"Encapsulation",id:"encapsulation",level:3},{value:"Abstraction",id:"abstraction",level:3},{value:"Inheritance",id:"inheritance",level:3},{value:"Polymorphism - literally means many forms",id:"polymorphism---literally-means-many-forms",level:3},{value:"Value types vs Reference types",id:"value-types-vs-reference-types",level:2},{value:"Value types",id:"value-types",level:3},{value:"Reference types",id:"reference-types",level:3},{value:"Factory",id:"factory",level:2},{value:"Constructor",id:"constructor",level:2}],m={toc:p};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"object-oriented-programming"},"Object Oriented Programming"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"it is a style of programming or a programming paradigm"),(0,r.kt)("li",{parentName:"ul"},"it combines a group of related variables and functions into a unit",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the unit is referred to as an object"),(0,r.kt)("li",{parentName:"ul"},"the variables are referred to as properties"),(0,r.kt)("li",{parentName:"ul"},"the functions are referred to as methods"))),(0,r.kt)("li",{parentName:"ul"},"e.g.: a CAR object",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},'has properties of "make, model, color"'),(0,r.kt)("li",{parentName:"ul"},'and methods of "start(), stop(), move()"')))),(0,r.kt)("h2",{id:"4-pillars-of-oop"},"4 pillars of OOP"),(0,r.kt)("h3",{id:"encapsulation"},"Encapsulation"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a concept that binds together the data and functions that manipulate the data, and that keeps both safe from outside interference and misuse")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a tool that helps to hide unimportant implementation details out of sight")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"most commonly used in the context of information hiding")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Public mutable data violates encapsulation"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"because any client of the class can change the internal state of the class object without the notification of the class"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"To achieve encapsulation in the design, two components are distinguished, its public interface and the private part"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the public part should expose more about what the class does and hide unnecessary implementation details from clients"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Abstraction and encapsulation complement each other and form some more general holistic picture of the object-oriented programming paradigm")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"play a key role in fighting complexity, providing the ability to design at a higher level, abstracting from implementation details")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"example 1"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// procedural programming\nlet baseSalary = 30000;\nlet overtime = 10;\nlet rate = 20;\nfunction getWage(baseSalary, overtime, rate) {\n  return baseSalary + overtime * rate;\n}\ngetWage(baseSalary, overtime, rate);\n\n// encapsulation - this is better because getWage method does not requires any parameters\n// the fewer the number of parameters, the easier it is to use and maintain that function\nlet employee = {\n  baseSalary: 30000,\n  overtime: 10,\n  rate: 20,\n  getWage: function () {\n    return this.baseSalary + this.overtime * this.rate;\n  },\n};\nemployee.getWage();\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"example 2"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Encapsulation is violated"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Paystub {\n  private readonly employees: Employee[];\n\n  public getEmployees(): Employee[] {\n    return this.employees;\n  }\n\n  public computePayroll(): number {\n    // using this.employees for calculation\n    return 42;\n  }\n}\n\nconst p1 = new Paystub();\n// if employees data type changed, we can't add employee\nconst employees = p1.getEmployees();\n\nemployees.push(new Employee());\nemployees.push(new Employee());\n\np1.computePayroll();\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Encapsulation is not violated"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Paystub2 {\n  private readonly employees: Employee[];\n\n  public addEmployee(employee: Employee): void {\n    this.employees.push(employee);\n  }\n\n  public computePayroll(): number {\n    // using this.employees for calculation\n    return 42;\n  }\n}\n\nconst p2 = new Paystub2();\n\n// there will never be an issue when adding employee\np2.addEmployee(new Employee());\np2.addEmployee(new Employee());\n\np2.computePayroll();\n")))))),(0,r.kt)("h3",{id:"abstraction"},"Abstraction"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"it highlights some significant parts, meaningful information from a component, no matter whether it is a class or an architectural layer in the system, or a logical unit of our system")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"(summary): it is the highlighting of significant parts or exclusion of insignificant parts from consideration"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The act of representing essential features without including the background details or explanations"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In OOP, only data abstraction is considered"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"it is called as ",(0,r.kt)("inlineCode",{parentName:"li"},"abstraction")," implying a set of the most significant characteristics of an object available for the program"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"it is essential when dealing with system complexity by hiding implementation details and highlighting essential aspects of behavior")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"main idea of abstraction is to describe real life objects and how they interact in a software system")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"play a key role in fighting complexity, providing the ability to design at a higher level, abstracting from implementation details")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"can be implemented using interfaces and abstract classes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"example 1"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'function Employee(name, age, baseSalary) {\n  this.name = name;\n  this.age = age;\n  this.baseSalary = baseSalary;\n  let monthlyBonus = 1500;\n\n  // abstraction creation\n  let calculateFinalSalary = function () {\n    let finalSalary = baseSalary + monthlyBonus;\n    console.log(finalSalary);\n  };\n\n  this.getEmployeeDetails = function () {\n    console.log(this.name);\n    calculateFinalSalary; // abstraction implementation;\n  };\n}\n\nconst employee = new Employee("John", 30, 2000);\nemployee.getEmployeeDetails();\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"example 2: implementation details, is the more unstable part of the abstraction, it can change while maintaining the public interface"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'enum CoffeeSelection {\n  FILTER_COFFEE,\n  ESPRESSO,\n  CAPPUCCINO,\n}\n\nclass CoffeeBean {\n  // implementation of CoffeeBeen\n}\n\nclass Coffee {\n  constructor(selection: CoffeeSelection, volume: number) {\n    // implementation of Coffee\n  }\n}\n\nclass Configuration {\n  constructor(weight: number, volume: number) {\n    // implementation of Configuration\n  }\n}\n\n// abstraction\n// implementation details are changed systematically, the requirements are changed systematically\n// the main thing is not to change the public interface on which clients depend\nclass CoffeeMachine {\n  private configMap: Map<CoffeeSelection, Configuration>;\n  private beans: Map<CoffeeSelection, CoffeeBean>;\n\n  constructor(beans: Map<CoffeeSelection, CoffeeBean>) {\n    this.beans = beans;\n    // create coffee configuration\n    this.configMap = new Map<CoffeeSelection, Configuration>();\n    this.configMap.set(CoffeeSelection.ESPRESSO, new Configuration(8, 28));\n    this.configMap.set(\n      CoffeeSelection.FILTER_COFFEE,\n      new Configuration(30, 480)\n    );\n  }\n\n  // The client knows that the coffee machine has only this method\n  // Everything else, all the settings of the coffee machine, initialization in the constructor of some configuration of everything else\n  // for the client this is not meaningful behavior, it should not depend on it, because it is unstable, it can change\n  public brewCoffee(selection: CoffeeSelection): Coffee {\n    const coffee = new Coffee(selection, 100);\n\n    console.log("Making coffee...");\n\n    return coffee;\n  }\n}\n\nconst main = () => {\n  // create a |Map of available coffee beans\n  const beans = new Map<CoffeeSelection, CoffeeBean>();\n\n  beans.set(\n    CoffeeSelection.ESPRESSO,\n    new CoffeeBean("My favorite espresso bean", 1000)\n  );\n  beans.set(\n    CoffeeSelection.FILTER_COFFEE,\n    new CoffeeBean("My favorite filter coffee bean", 1000)\n  );\n\n  // get a new CoffeeMachine object\n  const machine = new CoffeeMachine(beans);\n\n  // brew a fresh coffee\n  const espresso: Coffee = machine.brewCoffee(CoffeeSelection.ESPRESSO);\n};\n')))),(0,r.kt)("h3",{id:"inheritance"},"Inheritance"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"it is a mechanism that allows you to eliminate redundant code")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"it has a relationship between classes that lets you inherit or extend functionality from 1 class to another")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"This is an ",(0,r.kt)("inlineCode",{parentName:"p"},"is")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"is a")," relationship"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"a relationship between a base class and descendants"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"This relationship is the strongest and in statically typed languages it cannot be broken"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"this must be considered when assessing the need to use inheritance in this case"),(0,r.kt)("li",{parentName:"ul"},"If inheritance were applied in a place where one could do without it",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"this will make it difficult to understand and maintain code"),(0,r.kt)("li",{parentName:"ul"},"because the inheritance hierarchy can be 10 classes or more"),(0,r.kt)("li",{parentName:"ul"},"it is difficult to understand somewhere in the middle or how the last class will behave"),(0,r.kt)("li",{parentName:"ul"},"hard to understand in what places which methods are being overwritten or overridden"),(0,r.kt)("li",{parentName:"ul"},"Therefore, inheritance must be approached wisely"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"not all Object Oriented languages are the same"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"c++ supports multiple inheritance"),(0,r.kt)("li",{parentName:"ul"},"java only supports single inheritance",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"each class can extend or inherit functionality from only 1 other class"),(0,r.kt)("li",{parentName:"ul"},"classes can implement multiple interfaces"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"inheritance relationship"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Parent/Child, Base/Derived, Superclass/Subclass"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"example"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'class Person {\n  protected name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass Employee extends Person {\n  private department: string;\n\n  constructor(name: string, department: string) {\n    super(name);\n    this.department = department;\n  }\n\n  public getDetails() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n  }\n}\n\nconst howard = new Employee("Howard", "Sales");\n\nconsole.log(howard.getDetails()); // ok\nconsole.log(howard.name); // error\nconsole.log(howard.department); // error\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"3 access modifiers"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Private",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"not accessible from the outside"),(0,r.kt)("li",{parentName:"ul"},"only instances of this current class can work with these properties"),(0,r.kt)("li",{parentName:"ul"},"The Employee class has a department property"),(0,r.kt)("li",{parentName:"ul"},"only objects of the Employee class can work with this property"))),(0,r.kt)("li",{parentName:"ul"},"Protected",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"is a little wider than private"),(0,r.kt)("li",{parentName:"ul"},"only instances of the current class and classes of descendants can work with them"),(0,r.kt)("li",{parentName:"ul"},"From Employee, we can refer to name from Person"),(0,r.kt)("li",{parentName:"ul"},"they are also closed to the outside world"))),(0,r.kt)("li",{parentName:"ul"},"Public",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"public properties and methods are those that are provided to clients in the form of a public interface"),(0,r.kt)("li",{parentName:"ul"},"it should be the most stable and the most unchangeable")))))),(0,r.kt)("h3",{id:"polymorphism---literally-means-many-forms"},"Polymorphism - literally means many forms"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The provision of a single interface to entities of different types or the use of a single symbol to represent multiple different types")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"it addresses an object as either super or subtype")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"writes methods that accept supertype as arguments")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"passes instances of subtypes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"increases code flexibility and reusability")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"has 2 types"),(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"Compile time polymorphism (static binding / static polymorphism)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"e.g.: method overloading",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"allows you to implement multiple methods within the same class that use the same name but different types/order/number of parameters"))))),(0,r.kt)("li",{parentName:"ol"},"Runtime polymorphism (dynamic binding / dynamic polymorphism)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"e.g.: method overriding",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"does not allow the compiler to determine the executed method"),(0,r.kt)("li",{parentName:"ul"},"Within an inheritance hierarchy, a subclass can override a method of its superclass",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"That enables the developer of the subclass to customize or completely replace the behavior of that method"))),(0,r.kt)("li",{parentName:"ul"},"Overriding is about same method, same signature but different classes connected through inheritance"))))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"example 1"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  makeSound() {\n    console.log("Generic animal sound");\n  }\n}\n\n// polymorphism - override the makeSound method\nclass Dog extends Animal {\n  constructor(name) {\n    super(name);\n  }\n\n  makeSound() {\n    console.log("Woof!");\n  }\n}\nconst dog = new Dog("Happy");\ndog.makeSound(); // "Woof!"\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"example 2: Static polymorphism: overloading"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'interface Hero {\n  name: string;\n  skill: string;\n  weakness: string;\n}\n\nclass HeroService {\n  protected heroes: Hero[] = [\n    {name: "Superman", skill: "fly", weakness: "cryptonit"},\n    {name: "Spiderman", skill: "spider-sense", weakness: "MJ"},\n    {name: "Batman", skill: "superhuman power", weakness: "law"},\n    {name: "Flash", skill: "run", weakness: "unknown"},\n  ];\n\n  public getHero(name: string);\n  public getHero(name: string, skill: string);\n\n  public getHero(name: string, skill?: string): Hero {\n    if (!skill) {\n      return this.heroes.find((hero) => hero.name === name);\n    }\n\n    return this.heroes.find(\n      (hero) => hero.name === name && hero.skill === skill\n    );\n  }\n}\n\nconst heroService = new HeroService();\nconst hero1 = heroService.getHero("Flash");\nconst hero2 = heroService.getHero("Superman", "fly");\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"example 3: Dynamic polymorphism: overriding"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'class HeroService {\n  // implementation of HeroService\n}\n\nclass AntiHeroService extends HeroService {\n  public getHero(weakness: string): Hero {\n    return this.heroes.find((hero) => hero.weakness === weakness);\n  }\n}\n\nconst antiHeroService = new AntiHeroService();\nconst hero = antiHeroService.getHero("law");\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"in java"),(0,r.kt)("table",{parentName:"li"},(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Method Overloading"),(0,r.kt)("th",{parentName:"tr",align:null},"Method Overriding"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"it is a compile-time polymorphism"),(0,r.kt)("td",{parentName:"tr",align:null},"it is a run-time polymorphism")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"It helps to increase the readability of the program"),(0,r.kt)("td",{parentName:"tr",align:null},"It is used to grant the specific implementation of the method which is already provided by its parent class or superclass")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"It occurs within the class"),(0,r.kt)("td",{parentName:"tr",align:null},"It is performed in two classes with inheritance relationships")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"it may or may not require inheritance"),(0,r.kt)("td",{parentName:"tr",align:null},"it always needs inheritance")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"methods must have the same name and different signatures"),(0,r.kt)("td",{parentName:"tr",align:null},"methods must have the same name and same signature")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"the return type can or can not be the same, but we just have to change the parameter"),(0,r.kt)("td",{parentName:"tr",align:null},"the return type must be the same or co-variant")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Static binding is being used for overloaded methods"),(0,r.kt)("td",{parentName:"tr",align:null},"Dynamic binding is being used for overriding methods")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"It gives better performance. The reason behind this is that the binding of overridden methods is being done at runtime"),(0,r.kt)("td",{parentName:"tr",align:null},"Poor performance")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Private and final methods can be overloaded"),(0,r.kt)("td",{parentName:"tr",align:null},"Private and final methods can\u2019t be overridden")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Argument list should be different while doing method overloading"),(0,r.kt)("td",{parentName:"tr",align:null},"Argument list should be same in method overriding")))))),(0,r.kt)("h2",{id:"value-types-vs-reference-types"},"Value types vs Reference types"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"primitives are copied by their value")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// example 1\nlet x = 0;\nlet y = x;\nx = 20; // y = 0, x = 20\n\n// example 2\nlet number = 10;\nfunction increase(number) {\n  number++;\n}\nincrease(number);\nconsole.log(number); // number = 10\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"objects are copied by their reference")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// example 1\nlet x = {value: 0};\nlet y = x;\nx.value = 20; // y = { value: 20 }\n\n// example 2\nlet obj = {value: 10};\nfunction increase(obj) {\n  obj.value++;\n}\nincrease(obj);\nconsole.log(obj); // { value: 11 }\n")),(0,r.kt)("h3",{id:"value-types"},"Value types"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"number, string, boolean, symbol, undefined, null")),(0,r.kt)("h3",{id:"reference-types"},"Reference types"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"object, function, array")),(0,r.kt)("h2",{id:"factory"},"Factory"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'// normal code - needs to make multiple of the same objects if have different radius value\nconst circle = {\n  radius: 1,\n  draw: function () {\n    console.log("draw");\n  },\n};\ncircle.draw();\n\n// factory function - only need to change the value in the parameter during initialization\nfunction createCircle(radius) {\n  return {\n    radius,\n    draw: function () {\n      console.log("draw");\n    },\n  };\n}\n\nconst circle = createCircle(1);\ncircle.draw();\n')),(0,r.kt)("h2",{id:"constructor"},"Constructor"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'// constructor function\nfunction Circle(radius) {\n  this.radius = radius;\n  this.draw = function () {\n    console.log("draw");\n  };\n}\n\nconst circle = new Circle(1);\ncircle.draw();\n')))}c.isMDXComponent=!0}}]);