"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[80336],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>p});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=r.createContext({}),u=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(o.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,o=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=u(n),p=a,v=d["".concat(o,".").concat(p)]||d[p]||f[p]||s;return n?r.createElement(v,l(l({ref:t},c),{},{components:n})):r.createElement(v,l({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,l=new Array(s);l[0]=d;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var u=2;u<s;u++)l[u]=n[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},36884:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>f,frontMatter:()=>s,metadata:()=>i,toc:()=>u});var r=n(83117),a=(n(67294),n(3905));const s={},l="Find Closest Value In BST",i={unversionedId:"interviewPrep/codingTests/easy/binarySearchTrees/findClosestValueInBST",id:"interviewPrep/codingTests/easy/binarySearchTrees/findClosestValueInBST",title:"Find Closest Value In BST",description:"Write a function that takes in a Binary Search Tree (BST) and a target integer",source:"@site/docs/interviewPrep/codingTests/easy/binarySearchTrees/findClosestValueInBST.md",sourceDirName:"interviewPrep/codingTests/easy/binarySearchTrees",slug:"/interviewPrep/codingTests/easy/binarySearchTrees/findClosestValueInBST",permalink:"/docs/interviewPrep/codingTests/easy/binarySearchTrees/findClosestValueInBST",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/codingTests/easy/binarySearchTrees/findClosestValueInBST.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Validate Subsequence",permalink:"/docs/interviewPrep/codingTests/easy/arrays/validateSubsequence"},next:{title:"Branch Sums",permalink:"/docs/interviewPrep/codingTests/easy/binaryTrees/branchSums"}},o={},u=[],c={toc:u};function f(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"find-closest-value-in-bst"},"Find Closest Value In BST"),(0,a.kt)("p",null,"Write a function that takes in a Binary Search Tree (BST) and a target integer\nvalue and returns the closest value to that target value contained in the BST."),(0,a.kt)("p",null,"You can assume that there will only be one closest value."),(0,a.kt)("p",null,"Each BST node has an integer value, a\nleft child node, and a right child node. A node is\nsaid to be a valid BST node if and only if it satisfies the BST\nproperty: its value is strictly greater than the values of every\nnode to its left; its value is less than or equal to the values\nof every node to its right; and its children nodes are either valid\nBST nodes themselves or None / null"),(0,a.kt)("p",null,"Sample Input"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"tree =   10\n       /     \\\n      5      15\n    /   \\   /   \\\n   2     5 13   22\n /           \\\n1            14\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"target = 12")),(0,a.kt)("p",null,"Sample Output\n13"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"# This is the class of the input tree. Do not edit.\nclass BST:\n  def __init__(self, value):\n    self.value = value\n    self.left = None\n    self.right = None\n\n\n# solution 1\ndef findClosestValueInBst(tree, target):\n  # Write your code here.\n  current = tree\n  closest = tree.value\n  while current:\n    if abs(target - closest) > abs(current.value - target):\n      closest = current.value\n    if target > current.value:\n      current = current.right\n    elif target < current.value:\n      current = current.left\n    else:\n      break\n  return closest\n\n\n# solution 2\ndef findClosestValueInBst(tree, target):\n  # Write your code here.\n  return traverse(tree, target, tree.value)\n\n\ndef traverse(current, target, closest):\n  if current is None:\n    return closest\n  if abs(target - closest) > abs(current.value - target):\n    closest = current.value\n  if target > current.value:\n    return traverse(current.right, target, closest)\n  elif target < current.value:\n    return traverse(current.left, target, closest)\n  else:\n    return closest\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"// This is the class of the input tree. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// solution 1\nfunction findClosestValueInBst(tree, target) {\n  // Write your code here.\n  return traverse(tree, target, tree.value);\n}\n\nfunction traverse(current, target, closest) {\n  while (current) {\n    if (Math.abs(target - closest) > Math.abs(target - current.value)) {\n      closest = current.value;\n    }\n    if (target > current.value) {\n      current = current.right;\n    } else if (target < current.value) {\n      current = current.left;\n    } else {\n      break;\n    }\n  }\n  return closest;\n}\n\n// solution 2\nfunction findClosestValueInBst(tree, target) {\n  // Write your code here.\n  return traverse(tree, target, tree.value);\n}\n\nfunction traverse(current, target, closest) {\n  if (!current) {\n    return closest;\n  }\n  if (Math.abs(target - closest) > Math.abs(target - current.value)) {\n    closest = current.value;\n  }\n  if (target > current.value) {\n    return traverse(current.right, target, closest);\n  } else if (target < current.value) {\n    return traverse(current.left, target, closest);\n  } else {\n    return closest;\n  }\n}\n")))}f.isMDXComponent=!0}}]);