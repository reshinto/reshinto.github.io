"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[7273],{3905:(e,n,r)=>{r.d(n,{Zo:()=>c,kt:()=>f});var t=r(67294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function l(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var d=t.createContext({}),u=function(e){var n=t.useContext(d),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},c=function(e){var n=u(e.components);return t.createElement(d.Provider,{value:n},e.children)},s={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,a=e.originalType,d=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=u(r),f=i,p=h["".concat(d,".").concat(f)]||h[f]||s[f]||a;return r?t.createElement(p,o(o({ref:n},c),{},{components:r})):t.createElement(p,o({ref:n},c))}));function f(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=h;var l={};for(var d in n)hasOwnProperty.call(n,d)&&(l[d]=n[d]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var u=2;u<a;u++)o[u]=r[u];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}h.displayName="MDXCreateElement"},19092:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>s,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var t=r(87462),i=(r(67294),r(3905));const a={},o="Binary Search",l={unversionedId:"interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/binarySearch",id:"interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/binarySearch",title:"Binary Search",description:"- input data has to be sorted before binary search could be done",source:"@site/docs/interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/binarySearch.md",sourceDirName:"interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms",slug:"/interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/binarySearch",permalink:"/docs/interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/binarySearch",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/binarySearch.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Divide & Conquer",permalink:"/docs/interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/"},next:{title:"Insert Value Into Binary Search Tree",permalink:"/docs/interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/insertValueIntoBST"}},d={},u=[{value:"Iterative solution",id:"iterative-solution",level:2}],c={toc:u};function s(e){let{components:n,...r}=e;return(0,i.kt)("wrapper",(0,t.Z)({},c,r,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"binary-search"},"Binary Search"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"input data has to be sorted before binary search could be done")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"find the index of the value 10 in a list of numbers\n\n\ninput:\n  arr = [-1, 0, 1, 2, 3, 4, 7, 9, 10, 20]\n  leftIndex = 0\n  rightIndex = 9\n  findValue = 10\noutput: 8\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"before working on the recursion, need to think about the following",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"What is the base case / stopping condition?"))),(0,i.kt)("li",{parentName:"ul"},"What is the smallest amount of work I can do in each iteration?")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function binarySearch(arr, leftIndex, rightIndex, findValue) {\n  if (leftIndex > rightIndex) return -1;\n\n  const midIndex = Math.floor((leftIndex + rightIndex) / 2);\n  if (findValue === arr[midIndex]) return midIndex;\n\n  if (findValue < arr[midIndex])\n    return binarySearch(arr, leftIndex, midIndex - 1, findValue);\n\n  return binarySearch(arr, midIndex + 1, rightIndex, findValue);\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"input:\n  arr = [-1, 0, 1, 2, 3, 4, 7, 9, 10, 20]\n  leftIndex = 0\n  rightIndex = 9\n  findValue = 10\n\ncurrent leftIndex is 0 and rightIndex is 9 when function is called,\nsince leftIndex is not more than rightIndex,\nand midIndex is 4, value is 3\nfindValue is larger than mid value\nthe return value is added to the call stack\n\n|---------------------------------|\n| binarySearch(arr, 4 + 1, 9, 10) |\n|---------------------------------|\n\nmove to the next recursion call\ncurrent leftIndex is 5 and rightIndex is 9 when function is called,\nsince leftIndex is not more than rightIndex,\nand midIndex is 7, value is 9\nfindValue is larger than mid value\nthe return value is added to the call stack\n\n|---------------------------------|\n| binarySearch(arr, 7 + 1, 9, 10) |\n| binarySearch(arr, 5, 9, 10)     |\n|---------------------------------|\n\nmove to the next recursion call\ncurrent leftIndex is 8 and rightIndex is 9 when function is called,\nsince leftIndex is not more than rightIndex,\nand midIndex is 8, value is 10\nfindValue is equal to mid value\nthe return value is the midIndex\nsince arr value at the return index is equal to the findValue,\nit will start executing by poping the top stack frame from the call stack\n\nreturn result: 8\n|---------------------------------|\n| 8                               |\n| binarySearch(arr, 5, 9, 10)     |\n|---------------------------------|\n\nreturn result: 8\n|---------------------------------|\n|                                 |\n| 8                               |\n|---------------------------------|\n\nreturn result: 8\n|---------------------------------|\n|                                 |\n|                                 |\n|---------------------------------|\n")),(0,i.kt)("h2",{id:"iterative-solution"},"Iterative solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function binarySearch(arr, findValue) {\n  let leftIndex = 0;\n  let rightIndex = arr.length - 1;\n\n  while (leftIndex <= rightIndex) {\n    const midIndex = Math.floor((leftIndex + rightIndex) / 2);\n    if (findValue === arr[midIndex]) return midIndex;\n    if (findValue < arr[midIndex]) {\n      rightIndex = midIndex - 1;\n    } else if (findValue > arr[midIndex]) {\n      leftIndex = midIndex + 1;\n    }\n  }\n  return -1;\n}\n")))}s.isMDXComponent=!0}}]);