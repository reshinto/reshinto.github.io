"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[2377],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(67294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),m=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=m(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=m(a),h=l,d=c["".concat(s,".").concat(h)]||c[h]||u[h]||r;return a?n.createElement(d,i(i({ref:t},p),{},{components:a})):n.createElement(d,i({ref:t},p))}));function h(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,i=new Array(r);i[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var m=2;m<r;m++)i[m]=a[m];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},69489:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>m});var n=a(87462),l=(a(67294),a(3905));const r={},i="Memory Management",o={unversionedId:"languageSpecific/java/memoryManagement",id:"languageSpecific/java/memoryManagement",title:"Memory Management",description:"Java Memory",source:"@site/docs/languageSpecific/java/memoryManagement.md",sourceDirName:"languageSpecific/java",slug:"/languageSpecific/java/memoryManagement",permalink:"/docs/languageSpecific/java/memoryManagement",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/languageSpecific/java/memoryManagement.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java Version Manager - jEnv",permalink:"/docs/languageSpecific/java/jenv-manage-java-versions"},next:{title:"Parallel, Concurrent and Multithreading",permalink:"/docs/languageSpecific/java/parallelConcurrentMultithreading"}},s={},m=[{value:"Java Memory",id:"java-memory",level:2},{value:"The Stack",id:"the-stack",level:3},{value:"The Heap",id:"the-heap",level:3},{value:"Values and References",id:"values-and-references",level:2},{value:"Escaping references",id:"escaping-references",level:2},{value:"Garbage Collection",id:"garbage-collection",level:2},{value:"String pools",id:"string-pools",level:3},{value:"Garbage eligibility",id:"garbage-eligibility",level:3},{value:"gc and finalize methods",id:"gc-and-finalize-methods",level:3},{value:"Soft leaks",id:"soft-leaks",level:3},{value:"Generational Garbage Collection",id:"generational-garbage-collection",level:3},{value:"PermGen and Metaspace",id:"permgen-and-metaspace",level:3},{value:"Tuning the Virtual Machine",id:"tuning-the-virtual-machine",level:2},{value:"Heap Size",id:"heap-size",level:3},{value:"PermGen size",id:"permgen-size",level:3},{value:"Garbage collection and generation sizes",id:"garbage-collection-and-generation-sizes",level:3},{value:"Generating heap dumps",id:"generating-heap-dumps",level:3},{value:"Choosing a garbage collector",id:"choosing-a-garbage-collector",level:3}],p={toc:m};function u(e){let{components:t,...r}=e;return(0,l.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"memory-management"},"Memory Management"),(0,l.kt)("h2",{id:"java-memory"},"Java Memory"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"when app run, need access to some of computer's memory to store the objects that we create and hold in memory"),(0,l.kt)("li",{parentName:"ul"},"rules",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"objects are stored on the heap"),(0,l.kt)("li",{parentName:"ul"},"variables are a reference to the object which is stored on the stack"),(0,l.kt)("li",{parentName:"ul"},"local variables are stored on the stack")))),(0,l.kt)("h3",{id:"the-stack"},"The Stack"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"every thread has its own stack"),(0,l.kt)("li",{parentName:"ul"},"it is managed by the Java Virtual Machine (JVM)"),(0,l.kt)("li",{parentName:"ul"},"java knows exactly when data on the stack can be destoryed"),(0,l.kt)("li",{parentName:"ul"},"used for local primitive variables",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g.: ints and doubles"))),(0,l.kt)("li",{parentName:"ul"},"stack works as First In Last Out structure (FILO)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"each time a function is called, java pushes the local variables for that function on to the stack"),(0,l.kt)("li",{parentName:"ul"},"the local variables are automatically popped from the stack when it reaches the close of the block that create that variable"))),(0,l.kt)("li",{parentName:"ul"},"data on the stack can only be seen by the thread that owns the stack"),(0,l.kt)("li",{parentName:"ul"},"the stack is a tightly managed structure and java can maintain very tight scoping rules with the stack"),(0,l.kt)("li",{parentName:"ul"},"stacks are great for local variables because we want a local variable to have a short lifetime")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public class Main {\n  public static void main(String[] args) {\n    int value = 7;\n    value = calculate(value);\n  }\n  public static int calculate(int data) {\n    int tempValue = data + 3;\n    int newValue = tempValue * 2;\n    return newValue;\n  }\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"           ______________________      ______________________\n           | newValue = 20      |      |                    |\n_____      | tempValue = 10     |      |                    |      _____\n|   |  ->  | data = 7           |  ->  |                    |  ->  |   |\n-----      | value = 7          |      | value = 7          |      -----\n           | args = empty array |      | args = empty array |\n           ----------------------      ----------------------\n")),(0,l.kt)("h3",{id:"the-heap"},"The Heap"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"it allows us to store data that has a longer lifetime than a single code block or function"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g.: objects that need to be shared across multiple methods"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"it is all the memory of the app except for the data on the stacks")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"in an app, there is 1 heap which is shared across all the threads and a number of stacks 1 for each thread")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"since most objects are quite big and that most programs will want to pass around objects between blocks of code"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"by placing objects on the heap, it makes it easy to pass them around"),(0,l.kt)("li",{parentName:"ul"},"thus, all threads and code blocks in the app can potentially access the heap"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"in java, all objects are stored on the heap"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g.: strings, integer objects"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"for the objects on the heap, there will be a pointer to the object"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it is the variable reference stored on the stack"),(0,l.kt)("li",{parentName:"ul"},"basically a variable would be created on the stack which points to the object stored in the heap"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"simple example"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'int age = 21;\nString name = "Hello";\n')),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},'stack             heap\n____________     _____________________________\n| name ----|--   |                            |\n| age = 21 |  \\--|---\x3e  String name = "Hello" |\n------------     ------------------------------\n'))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"complicated example"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'public class Main {\n  public static void main(String[] args) {\n    List<String> myList = new ArrayList<String>();\n    myList.add("One");\n    myList.add("Two");\n    myList.add("Three");\n    printList(myList);\n  }\n  public static void printList(List<String> data) {\n    String value = data.get(1);\n    data.add("Four");\n    System.out.println(value);\n  }\n}\n')),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},"stack      heap\n______     ______\n|    |     |    |\n------     ------\n")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},"List<String> myList = new ArrayList<String>();\n\nstack          heap\n__________     __________\n| myList-|-----|-> List |\n----------     ----------\n")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},'myList.add("One");  // myList.add(new String("One"));\nmyList.add("Two");  // myList.add(new String("Two"));\nmyList.add("Three");  // myList.add(new String("Three"));\n\nstack          heap\n__________     ___________________________\n| myList-|-----|-> List                  |\n----------     |    0 ----\x3e String One   |\n               |    1 ----\x3e String Two   |\n               |    2 ----\x3e String Three |\n               ---------------------------\n')),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},"public static void printList(List<String> data)\n\nstack          heap\n__________     ___________________________\n| data---|-----|-> List                  |\n| myList-|-----|->  0 ----\x3e String One   |\n----------     |    1 ----\x3e String Two   |\n               |    2 ----\x3e String Three |\n               ---------------------------\n")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},"String value = data.get(1);\n\nstack          heap\n__________     _______________________________\n| value--|-----|---------------------------  |\n| data---|-----|-> List                   |  |\n| myList-|-----|->  0 ----\x3e String One    |  |\n----------     |    1 ----\x3e String Two  <--  |\n               |    2 ----\x3e String Three     |\n               -------------------------------\n")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},'data.add("Four");  // data.add(new String("Four"));\n\nstack          heap\n__________     _______________________________\n| value--|-----|---------------------------  |\n| data---|-----|-> List                   |  |\n| myList-|-----|->  0 ----\x3e String One    |  |\n----------     |    1 ----\x3e String Two  <--  |\n               |    2 ----\x3e String Three     |\n               |    3 ----\x3e String Four      |\n               -------------------------------\n')),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},"stack          heap\n__________     _______________________________\n| myList-|-----|-> List                      |\n----------     |    0 ----\x3e String One       |\n               |    1 ----\x3e String Two       |\n               |    2 ----\x3e String Three     |\n               |    3 ----\x3e String Four      |\n               -------------------------------\n")))),(0,l.kt)("h2",{id:"values-and-references"},"Values and References"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"passing values"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public class Main {\n  public static void main(String[] args) {\n    int localValue = 5;\n    calculate(localValue);\n    System.out.println(localValue);  // 5\n  }\n  public static void calculate(int calValue) {\n    calValue = calValue * 100;\n  }\n}\n"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"passing references"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'public class Main {\n  public static void main(String[] args) {\n    Customer c = new Customer("Sally");\n    renameCustomer(c);\n    System.out.println(c.getName());  // Diane\n  }\n  public static void renameCustomer(Customer cust) {\n    cust.setName("Diane");\n  }\n}\n')),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},'Customer c = new Customer("Sally");\n\nstack     heap\n_____     _______________________________\n| c-|-----|-> Customer                  |\n-----     |     name-----\x3e String Sally |\n          -------------------------------\n')),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},'cust.setName("Diane");\n\nstack     heap\n________     _______________________________\n| cust-|-----|->                           |\n| c----|-----|-> Customer --\x3e String Diane |\n--------     |     name       String Sally |\n             -------------------------------\n')),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},"System.out.println(c.getName());\n\nstack     heap\n________     _______________________________\n| c----|-----|-> Customer --\x3e String Diane |\n--------     |     name       String Sally |\n             -------------------------------\n")),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"after java changes the pointer from the name in the Customer object to the new string",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the original string object is no longer referenced from anywhere"),(0,l.kt)("li",{parentName:"ul"},"thus, it can be garbage collected at some point in the future"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"final keyword"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"once it has been assigned, it can never be altered"),(0,l.kt)("li",{parentName:"ul"},"closest thing to a constant")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'// method 1\nfinal Customer c = new Customer("John");\n\n// method 2: due to this, it is different from a traditional constant value from other programming languages\nfinal Customer c;\nc = new Customer("John");\n\n// this is allowed because java does not have const correctness\nc.setName("Peter");  // modifying values inside the same object is allowed\n\nc = new Customer("Susan");  // this will raise a compile error, final keyword prevents the change of reference to the object in the Heap\n')),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"it does not prevent the following side effect due to lack of const correctness"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'public class Main {\n  public static void main(String[] args) {\n    final Customer c = new Customer("John");\n    System.out.println(c.getName());  // John\n    System.out.println(c.getName());  // XXX\n  }\n}\n\npublic class Customer {\n  public Customer(String name) {\n    this.name = name;\n  }\n  public String getName() {\n    String temp = this.name;\n    this.name = "XXX";\n    return temp;\n  }\n}\n')))))),(0,l.kt)("h2",{id:"escaping-references"},"Escaping references"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"returning of reference variables that allows outsiders to modify value which is not expected")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"we should avoid escaping references in order to prevent people from accidentally having access to variables that they shouldn't be able to change")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"bad example"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.Map;\nimport java.util.HashMap;\n\npublic class CustomerRecords {\n  private Map<String, Customer> records;\n\n  public CustomerRecords() {\n    this.records = new HashMap<String, Customer>();\n  }\n\n  public void addCustomer(Customer c) {\n    this.records.put(c.getName(), c);\n  }\n\n  public Map<String, Customer> getCustomers() {\n    return this.records;  // this is the escaping reference\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    CustomerRecords records = new CustomerRecords();\n\n    records.addCustomer(new Customer("John"));\n    records.addCustomer(new Customer("Simon"));\n\n    records.getCustomers().clear();  // not what you wanted to allow\n\n    for (Customer next: records.getCustomers().values()) {  // data will be empty\n      System.out.println(next);\n    }\n  }\n}\n')),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"solution 1: make ",(0,l.kt)("inlineCode",{parentName:"p"},"CustomerRecords")," as an iterable class and provide an iterator to the objects that we want to be able to iterate through"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.Iterator;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class CustomerRecords implements Iterable<Customer> {\n  private Map<String, Customer> records;\n\n  public CustomerRecords() {\n    this.records = new HashMap<String, Customer>();\n  }\n\n  public void addCustomer(Customer c) {\n    this.records.put(c.getName(), c);\n  }\n\n  @Override\n  public Iterator<Customer> iterator() {\n    return records.values().iterator();\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    CustomerRecords records = new CustomerRecords();\n\n    records.addCustomer(new Customer("John"));\n    records.addCustomer(new Customer("Simon"));\n\n    records.iterator().remove();  // this method is available thus is not the best solution\n\n    for (Customer next: records) {  // data will be empty\n      System.out.println(next);\n    }\n  }\n}\n'))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"solution 2: better solution, return a new instance of the collection"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.Map;\nimport java.util.HashMap;\n\npublic class CustomerRecords implements Iterable<Customer> {\n  private Map<String, Customer> records;\n\n  public CustomerRecords() {\n    this.records = new HashMap<String, Customer>();\n  }\n\n  public void addCustomer(Customer c) {\n    this.records.put(c.getName(), c);\n  }\n\n  public Map<String, Customer> getCustomers() {\n    return new HashMap<String, Customer>(this.records);\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    CustomerRecords records = new CustomerRecords();\n\n    records.addCustomer(new Customer("John"));\n    records.addCustomer(new Customer("Simon"));\n\n    records.getCustomers().clear();  // this will only remove the copied version\n    for (Customer next: records.getCustomers().values()) {  // get a new copy with the data\n      System.out.println(next);  // work fine\n    }\n  }\n}\n'))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"solution 3: best solution, return an immutable collection"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Collections;\n\npublic class CustomerRecords implements Iterable<Customer> {\n  private Map<String, Customer> records;\n\n  public CustomerRecords() {\n    this.records = new HashMap<String, Customer>();\n  }\n\n  public void addCustomer(Customer c) {\n    this.records.put(c.getName(), c);\n  }\n\n  public Map<String, Customer> getCustomers() {\n    return Collections.unmodifiableMap(this.records);\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    CustomerRecords records = new CustomerRecords();\n\n    records.addCustomer(new Customer("John"));\n    records.addCustomer(new Customer("Simon"));\n\n    records.getCustomers().clear();  // this will raise an error during runtime\n    for (Customer next: records.getCustomers().values()) {\n      System.out.println(next);\n    }\n  }\n}\n')))))),(0,l.kt)("h2",{id:"garbage-collection"},"Garbage Collection"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"garbage collector cannot be modified",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"however, we need to write code that avoids memory leaks"),(0,l.kt)("li",{parentName:"ul"},"or learn how to monitor the app's memory usage and effectiveness of the garbage collector",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"this helps to detect and correct potential memory leaks"))))),(0,l.kt)("li",{parentName:"ul"},"problem about the ",(0,l.kt)("inlineCode",{parentName:"li"},"stack")," is that its scope is tight and is based on code blocks ",(0,l.kt)("inlineCode",{parentName:"li"},"{...}"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"often we want an object to live for a longer period of time than its enclosing scope",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"which is when we want to share objects between code blocks")))))),(0,l.kt)("h3",{id:"string-pools"},"String pools"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"unlike other languages, in java, all objects are stored in the ",(0,l.kt)("inlineCode",{parentName:"p"},"heap")," without giving the developers a choice"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"reason is due to 1 of the design goals of java during the mid 1990s",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"to simiplify choices and where possible, to provide a single, clean way of doing things"))),(0,l.kt)("li",{parentName:"ul"},"in modern JVM, it is more efficient and clever, as it is able to detech an object being created is not going to be shared (doesn't go outside the code block in which its created), thus creating it on the stack"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"example"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"reason for the following example is because java will see that the 2nd string object has identical value to the first string, thus there was no need to create a new string object in the ",(0,l.kt)("inlineCode",{parentName:"li"},"heap")),(0,l.kt)("li",{parentName:"ul"},"there is no harm in both of the stack variables pointing to the same object on the ",(0,l.kt)("inlineCode",{parentName:"li"},"heap")," because strings are immutable"),(0,l.kt)("li",{parentName:"ul"},"thus although in the code, we think that 2 string objects were created, however, there is only 1 in reality")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'public class Main {\n  public static void main(String[] args) {\n    String one = "hello";\n    String two = "hello";\n\n    if (one == two) {  // comparing the references\n      System.out.println("they are the same object");  // this will get printed\n    } else {\n      System.out.println("they are not the same object");\n    }\n\n    String three = new String("hello");\n    if (one == three) {\n      System.out.println("they are the same object");\n    } else {\n      System.out.println("they are not the same object");  // this will get printed\n    }\n\n    String four = new String("hello").intern();\n    if (one == four) {\n      System.out.println("they are the same object");  // this will get printed\n    } else {\n      System.out.println("they are not the same object");\n    }\n  }\n}\n'))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Basically, JVM optimizes the creation of objects"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it sometimes places objects on the stack"),(0,l.kt)("li",{parentName:"ul"},"with strings, it might not create duplicate objects")))),(0,l.kt)("h3",{id:"garbage-eligibility"},"Garbage eligibility"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"in java, once an object is no longer needed, it gets removed automatically"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"java avoids memory leaks by"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"running on a virtual machine"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"when calling the ",(0,l.kt)("inlineCode",{parentName:"li"},"new")," keyword in Java to create a new object",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"memory is not being taken from the Operating System"),(0,l.kt)("li",{parentName:"ul"},"memory is acquired by the virtual machine",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the virtual machine is another computer program written in C",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the C program will control the request for memory for objects from the OS and controls the freeing of memory when objects are no longer needed"))))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"adopting a Garbage Collection strategy"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"it was invested in 1959 with the LISP programming language")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"idea of garbage collection is that programmers ask for objects to be allocated on the heap"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"but do not need to free them when they are finished")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"instead, an automatic process analyzes the heap and aims to work out which objects are no longer needed"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"any unneeded objects can be deleted"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"it follows a rule"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"any object on the heap which cannot be reached through a reference from the stack is eligible for garbage collection\n",(0,l.kt)("img",{alt:"Garbage collection 1",src:a(99270).Z,width:"1086",height:"644"})),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("img",{alt:"Garbage collection 2",src:a(22037).Z,width:"1104",height:"650"})),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("img",{alt:"Garbage collection 3",src:a(29380).Z,width:"1078",height:"660"}))))))))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"in C, C++ or similar languages, programmer have to indicate that the object is no longer required with the ",(0,l.kt)("inlineCode",{parentName:"p"},"free()")," function"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"in visual basic, need to set object equal to null to clear the reference of the object"),(0,l.kt)("li",{parentName:"ul"},"not doing so will cause the memory that is being used to store the object to be never released",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it will still remain even when the program finishes running"),(0,l.kt)("li",{parentName:"ul"},"only way is to restart the computer in order to free the memory"),(0,l.kt)("li",{parentName:"ul"},"this is referred to as ",(0,l.kt)("inlineCode",{parentName:"li"},"memory leak"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"objects that are not freed continue to consume memory",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"this will result in more memory being used over time"),(0,l.kt)("li",{parentName:"ul"},"computer will start to slow down, and eventually crash")))))))))),(0,l.kt)("h3",{id:"gc-and-finalize-methods"},"gc and finalize methods"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'public class Customer {\n  private String name;\n\n  public Customer(String name) {\n    this.name = name;\n  }\n\n  // this method gets called when garbage collection is occurring\n  public void finalize() {\n    System.out.println("Object is being garbage collected");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Runtime runtime = Runtime.getRuntime();\n\n    long availableBytes = runtime.freeMemory();\n    System.out.println("Total memory: " + availableBytes / 1024 + "kb");\n\n    for (int i=0; i<1000000; i++) {\n      // these are instantly availabel for garbage collection\n      // because as soon as the loop is closed, the object is no longer referenced by a variable on the stack\n      Customer customer = new Customer("Customer " + i);\n    }\n\n    availableBytes = runtime.freeMemory();\n    System.out.println("Total memory before gc: " + availableBytes / 1024 + "kb");\n\n    // suggest garbage collection to run, but no guarantee\n    // it might appear to have run\n    System.gc();\n\n    availableBytes = runtime.freeMemory();\n    System.out.println("Total memory after gc: " + availableBytes / 1024 + "kb");\n  }\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the ",(0,l.kt)("inlineCode",{parentName:"li"},"gc")," method suggests that the JVM runs the garbage collection process",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"although it tells the JVM to run the garbage collection, there's no guarantee that the JVM will do it"),(0,l.kt)("li",{parentName:"ul"},"usually it is not a good idea to run the ",(0,l.kt)("inlineCode",{parentName:"li"},"gc")," command",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"during garbage collection process",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it will temporarily stop all threads in app from running"),(0,l.kt)("li",{parentName:"ul"},"while garbage collection takes place, the app is temporarily suspended",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it won't resume until garbage collection is complete"))),(0,l.kt)("li",{parentName:"ul"},"garbage collection should be quick and infrequent"))))))),(0,l.kt)("li",{parentName:"ul"},"the ",(0,l.kt)("inlineCode",{parentName:"li"},"finalize")," method",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it is the process when an object is actually garbage collected",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it would physically removes the object from the heap, rather than making becomes eligible for garbage collection"))),(0,l.kt)("li",{parentName:"ul"},"seems to be useful, but is actually pretty useless"),(0,l.kt)("li",{parentName:"ul"},"because we won't know if it will definitely and when it would run"),(0,l.kt)("li",{parentName:"ul"},"what we should never do is to close an open resource in the ",(0,l.kt)("inlineCode",{parentName:"li"},"finalize")," method",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"because you will never know when the resource is going to get closed"))),(0,l.kt)("li",{parentName:"ul"},"basically if the garbage collection didn't run, the ",(0,l.kt)("inlineCode",{parentName:"li"},"finalize")," method will not be called"),(0,l.kt)("li",{parentName:"ul"},"good use case of ",(0,l.kt)("inlineCode",{parentName:"li"},"finalize")," method is to check if all resources has been closed",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'public class File() {\n  public void closeFile() {\n    file.close();\n  }\n  public void finalize() {\n    if (file.isOpen()) {\n      logger.warn("Resource was not closed")\n    }\n  }\n}\n')))))),(0,l.kt)("h3",{id:"soft-leaks"},"Soft leaks"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"it is when an object is referenced on the stack even though it will never be used again"),(0,l.kt)("li",{parentName:"ul"},"it is where you have written code, or a 3rd party library that you are using contains code that somehow keeps an object live even though you are never going to use it again",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it should be garbage, but java never considers it as such because it's referenced from somewhere on the stack")))),(0,l.kt)("h3",{id:"generational-garbage-collection"},"Generational Garbage Collection"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"modern garbage collectors uses a clever mechanism to remove objects from the heap which are no longer reachable"),(0,l.kt)("li",{parentName:"ul"},"rather than searching for all the objects to remove, instead, it looks for all the objects that need to be retained and rescues them"),(0,l.kt)("li",{parentName:"ul"},"algorithm is ",(0,l.kt)("inlineCode",{parentName:"li"},"mark and sweep"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"its a 2 stage process",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"marking stage",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the program's execution is first paused",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"also refers to as a ",(0,l.kt)("inlineCode",{parentName:"li"},"stop the world event")),(0,l.kt)("li",{parentName:"ul"},"all threads in the app are paused"),(0,l.kt)("li",{parentName:"ul"},"the garbage collector then checks every single live reference",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"done by looking at every variable on the stack and follows its reference"),(0,l.kt)("li",{parentName:"ul"},"the object that it finds at the end of the reference is marked as being alive",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"then it follows any other references that the object has and also marks those as being alive"))))))),(0,l.kt)("li",{parentName:"ul"},"marking cannot work properly if there are any threads still executing"))),(0,l.kt)("li",{parentName:"ol"},"sweeping stage",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"once all objects that are referenced are marked for keeping, a full scan of the heap takes place, and the stages of all of the objects is checked",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the memory occupied by those objects not marked can be freed up"),(0,l.kt)("li",{parentName:"ul"},"objects that are being kept, are moved into a single contiguous block of memory",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"this stops the heap from becoming fragmented over time and makes it easier and quicker for the virtual machine to find memory to allocate to future objects"))))))))))),(0,l.kt)("li",{parentName:"ul"},"thus garbage collector doesn't really collect any garbage",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it actually collects the objects which are not eligible for garbage collection"),(0,l.kt)("li",{parentName:"ul"},"this means that the garbage collection process is faster than bulk garbage"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"generational garbage collection")," helps to avoid the app from becoming frozen during the garbage collection process"),(0,l.kt)("li",{parentName:"ul"},"most objects in Java live for a very short period of time",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"if an object survives 1 garbage collection, its more likely to live forever"))),(0,l.kt)("li",{parentName:"ul"},"its faster to collect when there's a lot of garbage, when there are fewer objects that are surviving"),(0,l.kt)("li",{parentName:"ul"},"thus, ",(0,l.kt)("inlineCode",{parentName:"li"},"generational garbage collection")," is a way of organizing the heap"),(0,l.kt)("li",{parentName:"ul"},"the heap is organized into 2 sections",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"young generation",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"also know as ",(0,l.kt)("inlineCode",{parentName:"li"},"minor collection")),(0,l.kt)("li",{parentName:"ul"},"typically smaller",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"but can be trimmed"))),(0,l.kt)("li",{parentName:"ul"},"new objects are created in the young generation space"),(0,l.kt)("li",{parentName:"ul"},"the young generation will fill up quite quickly as its small"),(0,l.kt)("li",{parentName:"ul"},"when full, the garbage collection takes place, but only on the young generation"),(0,l.kt)("li",{parentName:"ul"},"because most objects don't survive for long",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the young generation which is full of new objects is probably mostly garbage"),(0,l.kt)("li",{parentName:"ul"},"thus the process to garbage collect young generation should be very quick"),(0,l.kt)("li",{parentName:"ul"},"as a result, we will not notice the app freezing while this takes place"))),(0,l.kt)("li",{parentName:"ul"},"all surviving objects are then copied to the old generation",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"this frees up the younger generation for new objects to be added"))))),(0,l.kt)("li",{parentName:"ol"},"old generation",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"also known as ",(0,l.kt)("inlineCode",{parentName:"li"},"major collection")),(0,l.kt)("li",{parentName:"ul"},"garbage collection also runs on the old generation",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"but only if it's needed"))),(0,l.kt)("li",{parentName:"ul"},"it would be a lot slower, as it's much bigger block of memory to sweep"),(0,l.kt)("li",{parentName:"ul"},"there will be many objects still alive, so the sweep will take longer and the moving of all surviving objects into a contiguous part of the memory will take longer")))))),(0,l.kt)("h3",{id:"permgen-and-metaspace"},"PermGen and Metaspace"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Java 6",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"there is a further part of the heap called ",(0,l.kt)("inlineCode",{parentName:"li"},"PermGen")," (Permanent Generation)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"objects in the PermGen will survive forever"),(0,l.kt)("li",{parentName:"ul"},"the PermGen is never garbage collected",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"thus is PermGen runs out of space, app will crash",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"an error message ",(0,l.kt)("inlineCode",{parentName:"li"},"ran out of PermGen space")," will occur"),(0,l.kt)("li",{parentName:"ul"},"this means that the app has too many classes or internalized strings",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"this is not caused by memory leaks or faults in the code"),(0,l.kt)("li",{parentName:"ul"},"only way to avoid PermGen errors is to increase the size of the allocated memory for PermGen within the Heap"))))),(0,l.kt)("li",{parentName:"ul"},"in a server, each time an app is redeploy, a new metadata of all the classes will be created",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the old data will also remain but never referred to and never get cleared out"),(0,l.kt)("li",{parentName:"ul"},"this means that if redeployment is done too many times, eventually it will run out of PermGen space"))),(0,l.kt)("li",{parentName:"ul"},"solution is to always stop and restart the server after redeployment"))),(0,l.kt)("li",{parentName:"ul"},"2 types of object that goes into PermGen",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"internalized strings",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"strings which are placed into a pool for reuse"))),(0,l.kt)("li",{parentName:"ul"},"new class creation",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the metadata for that class is placed in the PermGen",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it is some memory needed to store information about the class"))),(0,l.kt)("li",{parentName:"ul"},"it is not the instance of the class",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"an object for that is created in the heap"))))))))))),(0,l.kt)("li",{parentName:"ul"},"java 7",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"internalized strings are no longer stored in the PermGen"),(0,l.kt)("li",{parentName:"ul"},"internalized strings are stored in the Heap",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"thus allowing it to be garbage collected")))))),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Java 7 and 8 PermGen",src:a(47346).Z,width:"1110",height:"652"})),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"java 8",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"PermGen is removed from the Heap, a new separate ",(0,l.kt)("inlineCode",{parentName:"li"},"MetaSpace")," is created where the field classes are placed"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"MetaSpace")," is not part of the heap, it is allocated out of the computer's native memory",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"so maximum available space for the MetaSpace is the total available system memory for the computer"),(0,l.kt)("li",{parentName:"ul"},"there is now an option to cap the maximum size for the MetaSpace",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"if there is no cap, the JVM will just grow the MetaSpace as it needs to"))),(0,l.kt)("li",{parentName:"ul"},"when classes are no longer creatable, the meta data related to those classes is then removed",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"everytime a server is redeployed, the old class meta data in the MetaSpace will get removed")))))))),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Java 8 MetaSpace",src:a(47161).Z,width:"1322",height:"660"})),(0,l.kt)("h2",{id:"tuning-the-virtual-machine"},"Tuning the Virtual Machine"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"it is by providing command line arguments to the Java Runtime so that 1 or more non default settings is applied to the app")),(0,l.kt)("h3",{id:"heap-size"},"Heap Size"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"k")," for kb, ",(0,l.kt)("inlineCode",{parentName:"li"},"m")," for mb, ",(0,l.kt)("inlineCode",{parentName:"li"},"g")," for gb"),(0,l.kt)("li",{parentName:"ul"},"arguments that start with ",(0,l.kt)("inlineCode",{parentName:"li"},"X")," are non standard arguments",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"this means that they are not guaranteed to be implemented on every runtime"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"-Xmx")," set the maximum heap size",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"example",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"-Xmx512m"))),(0,l.kt)("li",{parentName:"ul"},"useful in assiting the detection of potential memory leaks"),(0,l.kt)("li",{parentName:"ul"},"might want to set a low maximum heap size to test whether the app will run satisfactorily in a memory constrained environment"),(0,l.kt)("li",{parentName:"ul"},"default heap size can be found via the javadocs",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"in java 8, the default heap size is usually a quarter of the computer's total memory"),(0,l.kt)("li",{parentName:"ul"},"on a client or a server, max default heap size is 256 mb",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the total heap size will not be allocated when app starts"),(0,l.kt)("li",{parentName:"ul"},"the default starting size is ",(0,l.kt)("inlineCode",{parentName:"li"},"1/64")," of the total memory of the computer, with a min initial size of 8 mb"))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"-Xms")," set the starting heap size",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"there will be some performance impact each time the heap needs to increase its memory from starting size to total size"),(0,l.kt)("li",{parentName:"ul"},"thus setting heap size to the mimum that the app normally needs is goo in performance critical circumstances"),(0,l.kt)("li",{parentName:"ul"},"if running a server app where there won't be other apps competing with the memory of the machine, setting the max and starting heap sizes to be the same is ok")))),(0,l.kt)("h3",{id:"permgen-size"},"PermGen size"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"not valid for java 8 and above"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"K")," for kb, ",(0,l.kt)("inlineCode",{parentName:"li"},"M")," for mb, ",(0,l.kt)("inlineCode",{parentName:"li"},"G")," for gb"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"-XX:MaxPermSize")," set the size of the PermGen",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"example",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"-XX:MaxPermSize=256M")))))),(0,l.kt)("h3",{id:"garbage-collection-and-generation-sizes"},"Garbage collection and generation sizes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"k")," for kb, ",(0,l.kt)("inlineCode",{parentName:"li"},"m")," for mb, ",(0,l.kt)("inlineCode",{parentName:"li"},"g")," for gb"),(0,l.kt)("li",{parentName:"ul"},"useful if want to monitor how often garbage collection is taking place in the app"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"-verbose:gc")," print to the console when a garbage collection takes place"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"-Xmn")," set the size of the young generation",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"example",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"-Xmn256m"))),(0,l.kt)("li",{parentName:"ul"},"this options sets the total and initial size of the young generation at the same time",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"thus the overall and initial heap size needs to be sufficiently greater than the young generation size"))),(0,l.kt)("li",{parentName:"ul"},"Oracle recommends that the size of the young generation should be between half and a quarter of the overall heap size")))),(0,l.kt)("h3",{id:"generating-heap-dumps"},"Generating heap dumps"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"use this option when app crashes with an ",(0,l.kt)("inlineCode",{parentName:"li"},"out of memory error")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"-XX:HeapDumpOnOutOfMemory")," creates a heap dump file",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"we can then load this file into the Apache Memory Analyzer to find out what went wrong")))),(0,l.kt)("h3",{id:"choosing-a-garbage-collector"},"Choosing a garbage collector"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Oracle Virtual Machine has 3 types of collector",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"Serial",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"uses a single thread to perform all the garbage collection work"),(0,l.kt)("li",{parentName:"ul"},"take note that during garbage collection, the app is paused",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"so it doesn't matter how many threads are in the app"),(0,l.kt)("li",{parentName:"ul"},"whether its single threaded or multi threaded, all threads will be on hold while garbage collector runs"))),(0,l.kt)("li",{parentName:"ul"},"the garbage collector will need to compete with other apps for processing time"),(0,l.kt)("li",{parentName:"ul"},"serial collector is the best choice for a single processor computer and for apps with small amounts of data"),(0,l.kt)("li",{parentName:"ul"},"select option with ",(0,l.kt)("inlineCode",{parentName:"li"},"-XX:+UseSerialGC")))),(0,l.kt)("li",{parentName:"ol"},"Parallel",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it will perform garbage collections on the young generation",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"which are called minor collections in parallel"),(0,l.kt)("li",{parentName:"ul"},"this means that it will have multiple threads all performing the garbage collection process"))),(0,l.kt)("li",{parentName:"ul"},"it is an useful option if have multiple processors on the computer, or processors that are able to process multiple threads at the same time"),(0,l.kt)("li",{parentName:"ul"},"the option is good for larger data sets as it gives better performance that the ",(0,l.kt)("inlineCode",{parentName:"li"},"serial")," collector"),(0,l.kt)("li",{parentName:"ul"},"the collector is sometimes called the ",(0,l.kt)("inlineCode",{parentName:"li"},"throughput")," collector"),(0,l.kt)("li",{parentName:"ul"},"select option with ",(0,l.kt)("inlineCode",{parentName:"li"},"-XX:+UseParallelGC")))),(0,l.kt)("li",{parentName:"ol"},"Mostly Concurrent",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"performs most of its work concurrently"),(0,l.kt)("li",{parentName:"ul"},"it is the closest that we can get to a real-time garbage collection"),(0,l.kt)("li",{parentName:"ul"},"this is where it pauses the app to do the marking of objects, then resumes the app while the sweep phase takes place"),(0,l.kt)("li",{parentName:"ul"},"basially the ",(0,l.kt)("inlineCode",{parentName:"li"},"stop the world")," part of the garbage collection process is minimized"),(0,l.kt)("li",{parentName:"ul"},"there are 2 Mostly Concurrent collectors to choose from",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"Mark Sweep Collector",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"-XX:+UseConcMarkSweepGC"))),(0,l.kt)("li",{parentName:"ol"},"G One Collector",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"-XX+UseG1GC"))))))))),(0,l.kt)("li",{parentName:"ul"},"which garbage collector is used on the computer by default?",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"java makes the choice based on the hardware"),(0,l.kt)("li",{parentName:"ul"},"can find out by running ",(0,l.kt)("inlineCode",{parentName:"li"},"-XX:+PrintCommandLineFlags")," to find out which is default")))))}u.isMDXComponent=!0},99270:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/garbageCollection1-f0779df1a9b65481762615b095e3dd9c.png"},22037:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/garbageCollection2-3a23f6880dc9624afd26ac3a34d7da01.png"},29380:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/garbageCollection3-6bae224fa203a02bc4351feda56bfd4e.png"},47346:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/java6And7PermGen-fea2f0f8f340021f746e60548600191f.png"},47161:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/java8MetaSpace-2038f78778ac5e9c94408017aede7236.png"}}]);