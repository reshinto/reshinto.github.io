"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[3435],{3905:(e,n,o)=>{o.d(n,{Zo:()=>u,kt:()=>g});var t=o(67294);function d(e,n,o){return n in e?Object.defineProperty(e,n,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[n]=o,e}function r(e,n){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),o.push.apply(o,t)}return o}function i(e){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?r(Object(o),!0).forEach((function(n){d(e,n,o[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))}))}return e}function a(e,n){if(null==e)return{};var o,t,d=function(e,n){if(null==e)return{};var o,t,d={},r=Object.keys(e);for(t=0;t<r.length;t++)o=r[t],n.indexOf(o)>=0||(d[o]=e[o]);return d}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)o=r[t],n.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(d[o]=e[o])}return d}var s=t.createContext({}),l=function(e){var n=t.useContext(s),o=n;return e&&(o="function"==typeof e?e(n):i(i({},n),e)),o},u=function(e){var n=l(e.components);return t.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},p=t.forwardRef((function(e,n){var o=e.components,d=e.mdxType,r=e.originalType,s=e.parentName,u=a(e,["components","mdxType","originalType","parentName"]),p=l(o),g=d,m=p["".concat(s,".").concat(g)]||p[g]||c[g]||r;return o?t.createElement(m,i(i({ref:n},u),{},{components:o})):t.createElement(m,i({ref:n},u))}));function g(e,n){var o=arguments,d=n&&n.mdxType;if("string"==typeof e||d){var r=o.length,i=new Array(r);i[0]=p;var a={};for(var s in n)hasOwnProperty.call(n,s)&&(a[s]=n[s]);a.originalType=e,a.mdxType="string"==typeof e?e:d,i[1]=a;for(var l=2;l<r;l++)i[l]=o[l];return t.createElement.apply(null,i)}return t.createElement.apply(null,o)}p.displayName="MDXCreateElement"},75915:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var t=o(87462),d=(o(67294),o(3905));const r={},i="Merge Two Sorted Linked Lists",a={unversionedId:"interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/mergeTwoSortedLinkedLists",id:"interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/mergeTwoSortedLinkedLists",title:"Merge Two Sorted Linked Lists",description:"- before working on the recursion, need to think about the following",source:"@site/docs/interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/mergeTwoSortedLinkedLists.md",sourceDirName:"interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms",slug:"/interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/mergeTwoSortedLinkedLists",permalink:"/docs/interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/mergeTwoSortedLinkedLists",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/mergeTwoSortedLinkedLists.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Merge Sort",permalink:"/docs/interviewPrep/algorithms_and_techniques/divide_&_conquer_algorithms/mergeSort"},next:{title:"Dynamic Programming",permalink:"/docs/interviewPrep/algorithms_and_techniques/dynamic_programming/"}},s={},l=[{value:"Iterative solution",id:"iterative-solution",level:2}],u={toc:l};function c(e){let{components:n,...o}=e;return(0,d.kt)("wrapper",(0,t.Z)({},u,o,{components:n,mdxType:"MDXLayout"}),(0,d.kt)("h1",{id:"merge-two-sorted-linked-lists"},"Merge Two Sorted Linked Lists"),(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre"},"input1: node1 -> node8 -> node22 -> node40\ninput2: node4 -> node11 -> node16 -> node20\noutput: node1 -> node4 -> node8 -> node11 -> node16 -> node20 -> node22 -> node40\n")),(0,d.kt)("ul",null,(0,d.kt)("li",{parentName:"ul"},"before working on the recursion, need to think about the following",(0,d.kt)("ul",{parentName:"li"},(0,d.kt)("li",{parentName:"ul"},"What is the base case / stopping condition?"))),(0,d.kt)("li",{parentName:"ul"},"What is the smallest amount of work I can do in each iteration?")),(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-javascript"},"function sortedMerge(nodeA, nodeB) {\n  // return nodeB if nodeA does not exist\n  if (!nodeA) {\n    return nodeB;\n  }\n  // return nodeA if nodeB does not exist\n  if (!nodeB) {\n    return nodeA;\n  }\n\n  if (nodeA.value < nodeB.value) {\n    nodeA.next = sortedMerge(nodeA.next, nodeB);\n    return nodeA;\n  } else {\n    nodeB.next = sortedMerge(nodeA, nodeB.next);\n    return nodeB;\n  }\n}\n")),(0,d.kt)("ul",null,(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("p",{parentName:"li"},"supporting code"),(0,d.kt)("pre",{parentName:"li"},(0,d.kt)("code",{parentName:"pre",className:"language-javascript"},'class Node {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n\n  setNext(node) {\n    this.next = node;\n  }\n\n  getNext() {\n    return this.next;\n  }\n}\n\nfunction printLinkedList(node) {\n  let tmp = node;\n  let result = "";\n  while (tmp) {\n    result += tmp.value + " ";\n    tmp = tmp.getNext();\n  }\n  console.log(result);\n}\n')))),(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre"},"nodeA: node1 -> node8 -> node22 -> node40\nnodeB: node4 -> node11 -> node16 -> node20\n\nsince node1 and node4 are both not null, base case is skipped\nwhen comparing node1 and node4, 1 is less than 4\nset node1 next to return value by adding to the stack\n|-----------------------------|\n|  sortedMerge(node8, node4)  |\n|-----------------------------|\n\nsince node8 and node4 are both not null, base case is skipped\nwhen comparing node8 and node4, 4 is less than 8\nset node4 next to return value by adding to the stack\n|-----------------------------|\n|  sortedMerge(node8, node11) |\n|  sortedMerge(node8, node4)  |\n|-----------------------------|\n\nsince node8 and node11 are both not null, base case is skipped\nwhen comparing node8 and node11, 8 is less than 11\nset node8 next to return value by adding to the stack\n|------------------------------|\n|  sortedMerge(node22, node11) |\n|  sortedMerge(node8, node11)  |\n|  sortedMerge(node8, node4)   |\n|------------------------------|\n\nsince node22 and node11 are both not null, base case is skipped\nwhen comparing node22 and node11, 11 is less than 22\nset node11 next to return value by adding to the stack\n|------------------------------|\n|  sortedMerge(node22, node16) |\n|  sortedMerge(node22, node11) |\n|  sortedMerge(node8, node11)  |\n|  sortedMerge(node8, node4)   |\n|------------------------------|\n\nsince node22 and node16 are both not null, base case is skipped\nwhen comparing node22 and node16, 16 is less than 22\nset node16 next to return value by adding to the stack\n|------------------------------|\n|  sortedMerge(node22, node20) |\n|  sortedMerge(node22, node16) |\n|  sortedMerge(node22, node11) |\n|  sortedMerge(node8, node11)  |\n|  sortedMerge(node8, node4)   |\n|------------------------------|\n\nsince node22 and node20 are both not null, base case is skipped\nwhen comparing node22 and node20, 20 is less than 22\nset node20 next to return value by adding to the stack\n|------------------------------|\n|  sortedMerge(node22, null)   |\n|  sortedMerge(node22, node20) |\n|  sortedMerge(node22, node16) |\n|  sortedMerge(node22, node11) |\n|  sortedMerge(node8, node11)  |\n|  sortedMerge(node8, node4)   |\n|------------------------------|\n\nsince nodeB is null, base case is activated and returns node22\n|------------------------------|\n|  node22                      |\n|  sortedMerge(node22, node20) |\n|  sortedMerge(node22, node16) |\n|  sortedMerge(node22, node11) |\n|  sortedMerge(node8, node11)  |\n|  sortedMerge(node8, node4)   |\n|------------------------------|\nnode20 next = node22\nnode20 -> node22 -> node40\n\n|------------------------------|\n|  node20                      |\n|  sortedMerge(node22, node16) |\n|  sortedMerge(node22, node11) |\n|  sortedMerge(node8, node11)  |\n|  sortedMerge(node8, node4)   |\n|------------------------------|\nnode16 next = node20\nnode16 -> node20 -> node22 -> node40\n\n|------------------------------|\n|  node16                      |\n|  sortedMerge(node22, node11) |\n|  sortedMerge(node8, node11)  |\n|  sortedMerge(node8, node4)   |\n|------------------------------|\nnode11 next = node16\nnode11 -> node16 -> node20 -> node22 -> node40\n\n|------------------------------|\n|  node11                      |\n|  sortedMerge(node8, node11)  |\n|  sortedMerge(node8, node4)   |\n|------------------------------|\nnode8 next = node11\nnode8 -> node11 -> node16 -> node20 -> node22 -> node40\n\n|------------------------------|\n|  node8                       |\n|  sortedMerge(node8, node4)   |\n|------------------------------|\nnode4 next = node8\nnode4 -> node8 -> node11 -> node16 -> node20 -> node22 -> node40\n\n|------------------------------|\n|  node4                       |\n|------------------------------|\nnode1 next = node4\nnode1 -> node4 -> node8 -> node11 -> node16 -> node20 -> node22 -> node40\n\noutput: node1 -> node4 -> node8 -> node11 -> node16 -> node20 -> node22 -> node40\n")),(0,d.kt)("h2",{id:"iterative-solution"},"Iterative solution"),(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-javascript"},"function sortedMerge(nodeA, nodeB) {\n  let dummyNode = new Node(0); // a dummy first node to hang the result on\n  let tail = dummyNode; // tail points to the last result node\n  while (true) {\n    if (!nodeA) {\n      // use nodeB if nodeA runs out\n      tail.next = nodeB;\n      break;\n    }\n    if (!nodeB) {\n      // use nodeA if nodeB runs out\n      tail.next = nodeA;\n      break;\n    }\n    // Compare data of 2 lists, append the smaller list into tail and advance the head to the next Node\n    if (nodeA.value <= nodeB.value) {\n      tail.next = nodeA;\n      nodeA = nodeA.next;\n    } else {\n      tail.next = nodeB;\n      nodeB = nodeB.next;\n    }\n    tail = tail.next; // Advance the tail\n  }\n  return dummyNode.next;\n}\n")))}c.isMDXComponent=!0}}]);