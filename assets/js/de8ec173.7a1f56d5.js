"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[4985],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>p});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=c(a),p=r,d=m["".concat(s,".").concat(p)]||m[p]||h[p]||i;return a?n.createElement(d,o(o({ref:t},u),{},{components:a})):n.createElement(d,o({ref:t},u))}));function p(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},41483:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var n=a(87462),r=(a(67294),a(3905));const i={},o="Strategy",l={unversionedId:"interviewPrep/designPatterns/Behavioral_patterns/Strategy/readme",id:"interviewPrep/designPatterns/Behavioral_patterns/Strategy/readme",title:"Strategy",description:"- it lets you define a family of algorithms, put each of them into a separate class and make their objects interchangeable",source:"@site/docs/interviewPrep/designPatterns/Behavioral_patterns/Strategy/readme.md",sourceDirName:"interviewPrep/designPatterns/Behavioral_patterns/Strategy",slug:"/interviewPrep/designPatterns/Behavioral_patterns/Strategy/",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Strategy/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Behavioral_patterns/Strategy/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"State",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/State/"},next:{title:"C++ Example",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Strategy/cPlusPlus/"}},s={},c=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2},{value:"Analogy",id:"analogy",level:2},{value:"Structure",id:"structure",level:2},{value:"How to use",id:"how-to-use",level:2},{value:"How to implement",id:"how-to-implement",level:2},{value:"Pros &amp;&amp; Cons",id:"pros--cons",level:2},{value:"Pros",id:"pros",level:3},{value:"Cons",id:"cons",level:3},{value:"Example",id:"example",level:2}],u={toc:c};function h(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"strategy"},"Strategy"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"it lets you define a family of algorithms, put each of them into a separate class and make their objects interchangeable"),(0,r.kt)("li",{parentName:"ul"},"Allows switching between algorithms or strategies depending on situation")),(0,r.kt)("h2",{id:"problem"},"Problem"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"when creating a navigation app for travelers",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the app is centered around a map which helped users quickly orient themselves in any city"),(0,r.kt)("li",{parentName:"ul"},"1 of the most requested features for the app is automatic route planning",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"a user should be able to enter an address and see the fastest route to that destination displayed on the map"))),(0,r.kt)("li",{parentName:"ul"},"the 1st version of the app could only build the routes over roads",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"however, not everyone likes to drive on their vacation"),(0,r.kt)("li",{parentName:"ul"},"the next update, you added an option to build walking routes"),(0,r.kt)("li",{parentName:"ul"},"then you add another option to let people use public transport in their routes"),(0,r.kt)("li",{parentName:"ul"},"later you add route building for cyclists"),(0,r.kt)("li",{parentName:"ul"},"later another option for building route for all tourist attractions"))),(0,r.kt)("li",{parentName:"ul"},"from a business perspective the app is a success",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"but the technical part caused many headaches",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"each time you add a new routing algorithm, the main class of the navigator doubled in size"),(0,r.kt)("li",{parentName:"ul"},"becoming too hard to maintain"))))),(0,r.kt)("li",{parentName:"ul"},"any change to 1 of the algorithms, whether it is a simple bug fix, or a slight adjustment of the street score",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"affected the whole class, increasing the chance of creating an error in already working code"))),(0,r.kt)("li",{parentName:"ul"},"in addition, teamwork became inefficient",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"teammates would complain that they spend too much time resolving merge conflicts"),(0,r.kt)("li",{parentName:"ul"},"implementing a new features requires you to change the same huge class conflicting with the code produced by other people")))))),(0,r.kt)("h2",{id:"solution"},"Solution"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the strategy pattern suggest that you take a class that does something specific in a lot of different ways",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"and extract all of these algorithms into separate classes called strategies"))),(0,r.kt)("li",{parentName:"ul"},"the original class called context must have a field for storing a reference to 1 of the strategies",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the context delegates the work to a linked strategy object instead of executing it on its own"))),(0,r.kt)("li",{parentName:"ul"},"the context isn't responsible for selecting an appropriate algorithm for the job",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"instead, the client passes the desired strategy to the context"),(0,r.kt)("li",{parentName:"ul"},"the context doesn't know much about the strategies"),(0,r.kt)("li",{parentName:"ul"},"it works with all strategies through the same generic interface",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"which only exposes a single method for triggering the algorithm encapsulated within the selected strategy"))))),(0,r.kt)("li",{parentName:"ul"},"this way the context becomes independent of concrete strategies",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"so you can add new algorithms or modify existing 1s without changing the code of the context or other strategies"))),(0,r.kt)("li",{parentName:"ul"},"in the navigation app, each routing algorithm can be extracted to its own class with a single buildRoute method",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the method accepts an origin and destination and returns a collection of the route's checkpoints"))),(0,r.kt)("li",{parentName:"ul"},"even though given the same arguments, each routing class might build a different route",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the main navigator class doesn't really care which algorithm is selected since its primary job is to render a set of checkpoints on the map"),(0,r.kt)("li",{parentName:"ul"},"the class has a method for switching the active routing strategy",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"so its clients such as the buttons in the user interface can replace the currently selected routing behavior with another one")))))),(0,r.kt)("h2",{id:"analogy"},"Analogy"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"imagine that you have to get to the airport",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"you can catch a bus, order a cab, or get on the bicycle"))),(0,r.kt)("li",{parentName:"ul"},"these are your transportation strategies"),(0,r.kt)("li",{parentName:"ul"},"you can pick one of the strategies depending on factors such as budget or time constraints")),(0,r.kt)("h2",{id:"structure"},"Structure"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Strategy",src:a(6229).Z,width:"922",height:"794"})),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The Context maintains a reference to one of the concrete strategies and communicates with this object only via the strategy interface.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The Strategy interface is common to all concrete strategies."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"It declares a method the context uses to execute a strategy."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Concrete Strategies implement different variations of an algorithm the context uses.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The context calls the execution method on the linked strategy object each time it needs to run the algorithm."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The context doesn\u2019t know what type of strategy it works with or how the algorithm is executed."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The Client creates a specific strategy object and passes it to the context."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The context exposes a setter which lets clients replace the strategy associated with the context at runtime.")))),(0,r.kt)("h2",{id:"how-to-use"},"How to use"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Use the Strategy pattern when you want to use different variants of an algorithm within an object and be able to switch from one algorithm to another during runtime",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The Strategy pattern lets you indirectly alter the object\u2019s behavior at runtime by associating it with different sub-objects which can perform specific sub-tasks in different ways"))),(0,r.kt)("li",{parentName:"ul"},"Use the Strategy when you have a lot of similar classes that only differ in the way they execute some behavior",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The Strategy pattern lets you extract the varying behavior into a separate class hierarchy and combine the original classes into one, thereby reducing duplicate code"))),(0,r.kt)("li",{parentName:"ul"},"Use the pattern to isolate the business logic of a class from the implementation details of algorithms that may not be as important in the context of that logic",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The Strategy pattern lets you isolate the code, internal data, and dependencies of various algorithms from the rest of the code"),(0,r.kt)("li",{parentName:"ul"},"Various clients get a simple interface to execute the algorithms and switch them at runtime"))),(0,r.kt)("li",{parentName:"ul"},"Use the pattern when your class has a massive conditional operator that switches between different variants of the same algorithm",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The Strategy pattern lets you do away with such a conditional by extracting all algorithms into separate classes, all of which implement the same interface"),(0,r.kt)("li",{parentName:"ul"},"The original object delegates execution to one of these objects, instead of implementing all variants of the algorithm")))),(0,r.kt)("h2",{id:"how-to-implement"},"How to implement"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"In the context class, identify an algorithm that\u2019s prone to frequent changes",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"It may also be a massive conditional that selects and executes a variant of the same algorithm at runtime"))),(0,r.kt)("li",{parentName:"ol"},"Declare the strategy interface common to all variants of the algorithm"),(0,r.kt)("li",{parentName:"ol"},"One by one, extract all algorithms into their own classes",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"They should all implement the strategy interface"))),(0,r.kt)("li",{parentName:"ol"},"In the context class, add a field for storing a reference to a strategy object",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Provide a setter for replacing values of that field"),(0,r.kt)("li",{parentName:"ul"},"The context should work with the strategy object only via the strategy interface"),(0,r.kt)("li",{parentName:"ul"},"The context may define an interface which lets the strategy access its data"))),(0,r.kt)("li",{parentName:"ol"},"Clients of the context must associate it with a suitable strategy that matches the way they expect the context to perform its primary job")),(0,r.kt)("h2",{id:"pros--cons"},"Pros && Cons"),(0,r.kt)("h3",{id:"pros"},"Pros"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You can swap algorithms used inside an object at runtime"),(0,r.kt)("li",{parentName:"ul"},"You can isolate the implementation details of an algorithm from the code that uses it"),(0,r.kt)("li",{parentName:"ul"},"You can replace inheritance with composition"),(0,r.kt)("li",{parentName:"ul"},"Open/Closed Principle",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"You can introduce new strategies without having to change the context")))),(0,r.kt)("h3",{id:"cons"},"Cons"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If you only have a couple of algorithms and they rarely change, there\u2019s no real reason to overcomplicated the program with new classes and interfaces that come along with the pattern"),(0,r.kt)("li",{parentName:"ul"},"Clients must be aware of the differences between strategies to be able to select a proper one"),(0,r.kt)("li",{parentName:"ul"},"A lot of modern programming languages have functional type support that lets you implement different versions of an algorithm inside a set of anonymous functions"),(0,r.kt)("li",{parentName:"ul"},"Then you could use these functions exactly as you\u2019d have used the strategy objects, but without bloating your code with extra classes and interfaces")),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// The strategy interface declares operations common\n// to all supported versions of some algorithm.\ninterface Strategy {\n  execute(a: number, b: number): number;\n}\n\n// Concrete strategies implement the algorithm while following\n// the base strategy interface. The interface makes them\n// interchangable in the context.\nclass ConcreteStrategyAdd implements Strategy {\n  execute(a, b) {\n    return a + b;\n  }\n}\n\nclass ConcreteStrategySubstract implements Strategy {\n  execute(a, b) {\n    return a - b;\n  }\n}\n\nclass ConcreteStrategyMultiply implements Strategy {\n  execute(a, b) {\n    return a * b;\n  }\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// The context defines the interface of interest to clients.\nclass Context {\n  private strategy: Strategy;\n\n  setStrategy(s: Strategy) {\n    this.strategy = s;\n  }\n  // The context delegates some work to the strategy object\n  // instead of implementing multiple versions of the\n  // algorithm on its own.\n  executeStrategy(a: number, b: number) {\n    return this.strategy.execute(a, b);\n  }\n}\n\nlet ctx = new Context();\n\nctx.setStrategy(new ConcreteStrategyAdd());\nctx.executeStrategy(5, 2); // 7\n")))}h.isMDXComponent=!0},6229:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/strategy-e275c58bc44aa090bd3d73da053f2aa9.png"}}]);