"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[1185],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(a),m=r,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||i;return a?n.createElement(h,l(l({ref:t},p),{},{components:a})):n.createElement(h,l({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var u=2;u<i;u++)l[u]=a[u];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},90433:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var n=a(83117),r=(a(67294),a(3905));const i={},l="Database Scaling",o={unversionedId:"interviewPrep/system_design/database_scaling",id:"interviewPrep/system_design/database_scaling",title:"Database Scaling",description:"- an important topic for any system design",source:"@site/docs/interviewPrep/system_design/database_scaling.md",sourceDirName:"interviewPrep/system_design",slug:"/interviewPrep/system_design/database_scaling",permalink:"/docs/interviewPrep/system_design/database_scaling",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/system_design/database_scaling.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Data Partitioning",permalink:"/docs/interviewPrep/system_design/data_partitioning"},next:{title:"Distributed System Characteristics",permalink:"/docs/interviewPrep/system_design/distributed_systems_key_characteristics"}},s={},u=[{value:"Key Information",id:"key-information",level:2},{value:"Basic Scaling Techniques",id:"basic-scaling-techniques",level:2},{value:"Indexes",id:"indexes",level:3},{value:"Denormalization",id:"denormalization",level:3},{value:"Connection Pooling",id:"connection-pooling",level:3},{value:"Caching",id:"caching",level:3},{value:"Vertical Scaling",id:"vertical-scaling",level:3},{value:"Replication and Partitioning",id:"replication-and-partitioning",level:2},{value:"Read Replicas",id:"read-replicas",level:3},{value:"Sharding (a type of partitioning)",id:"sharding-a-type-of-partitioning",level:3},{value:"Vertical Partitioning",id:"vertical-partitioning",level:3},{value:"When to consider NoSQL",id:"when-to-consider-nosql",level:2}],p={toc:u};function d(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"database-scaling"},"Database Scaling"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"an important topic for any system design",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"because for any large scale applications, the database is usually going to be where the performance bottleneck is",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"because while the application servers are stateless, it can be scaled horizontally as much as required"),(0,r.kt)("li",{parentName:"ul"},"these servers are going to hit the database for retrieving and writing of data")))))),(0,r.kt)("h2",{id:"key-information"},"Key Information"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"most web apps are read heavy, around 95% +",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"e.g.: twitter (tweets), facebook (posts), google (searches)")))),(0,r.kt)("h2",{id:"basic-scaling-techniques"},"Basic Scaling Techniques"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"used to improve the performance of the database")),(0,r.kt)("h3",{id:"indexes"},"Indexes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"create an index based on a certain column that's frequently accessed",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"e.g.: user id")))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"pros"),(0,r.kt)("th",{parentName:"tr",align:null},"cons"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"speeds up read performance by creating an index that speeds up the lookup"),(0,r.kt)("td",{parentName:"tr",align:null},"writes and updates become slightly slower, because everytime a row is updated, you also have to potentially modify the index")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"thus it does not have to do a full table scans across the database"),(0,r.kt)("td",{parentName:"tr",align:null},"requires more storage for a table that's indexed because you have to store the index itself")))),(0,r.kt)("h3",{id:"denormalization"},"Denormalization"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"it go against a standard best practices with relational databases"),(0,r.kt)("li",{parentName:"ul"},"add redundant data to tables so that it reduces the amount of joins you need to do")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"pros"),(0,r.kt)("th",{parentName:"tr",align:null},"cons"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"improves the read performance"),(0,r.kt)("td",{parentName:"tr",align:null},"sacrificing write performance")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"risk inconsistent data across tables, because all tables have to have the same data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"code becomes harder to write as you would need to deal with the situation where you not only write to 1 table, but you have to update that data place that column is now located. Usually its abstracted away by some library")))),(0,r.kt)("h3",{id:"connection-pooling"},"Connection Pooling"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"similar to car pooling where everyone rides in the same car to save resources or money"),(0,r.kt)("li",{parentName:"ul"},"allow multiple application threads to use the same database connection",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"in this case, instead of every application thread using its own connection",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"they are pooled together and use the same one"))))),(0,r.kt)("li",{parentName:"ul"},"which saves on overhead of independent database connections")),(0,r.kt)("h3",{id:"caching"},"Caching"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"serve traffic from memory rather than having to read from disk"),(0,r.kt)("li",{parentName:"ul"},"not directly related to database"),(0,r.kt)("li",{parentName:"ul"},"cache sits in front of database to handle serving content"),(0,r.kt)("li",{parentName:"ul"},"can't cache everything",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"dynamic data that is frequently updated would not work well"))),(0,r.kt)("li",{parentName:"ul"},"e.g.: Redis, Memcached"),(0,r.kt)("li",{parentName:"ul"},"best way to scale the database is to not let traffic reach the database at all",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"according to facebook, 99% of their requests are served from cache")))),(0,r.kt)("h3",{id:"vertical-scaling"},"Vertical Scaling"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"get a bigger server with faster processor or more memory"),(0,r.kt)("li",{parentName:"ul"},"easiest solution when starting out")),(0,r.kt)("h2",{id:"replication-and-partitioning"},"Replication and Partitioning"),(0,r.kt)("h3",{id:"read-replicas"},"Read Replicas"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"duplicate the database and set it as the master server dedicated only to writes"),(0,r.kt)("li",{parentName:"ul"},"create replica servers to handle reads"),(0,r.kt)("li",{parentName:"ul"},"have to handle making sure new data reaches replicas"),(0,r.kt)("li",{parentName:"ul"},"have built in fault tolerance as even if any of the replica were to go down, there would be backups to take its place")),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://github.com/reshinto/Basic_technologies_revision/raw/master/interviewPrep/system_design/images/replicas.png",alt:"alt text",title:"replicas"})),(0,r.kt)("h3",{id:"sharding-a-type-of-partitioning"},"Sharding (a type of partitioning)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"also called as horizontal partitioning"),(0,r.kt)("li",{parentName:"ul"},"schema of table stays the same, but it's now split across multiple DBs",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"reason for this is because if read replica is set up, you need to handle more writes",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"can split the task",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"e.g.: names of users from A-M goes to the first shard, while users from N-Z goes to the second shard")))))))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"pros"),(0,r.kt)("th",{parentName:"tr",align:null},"cons"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"can hanlde more traffic"),(0,r.kt)("td",{parentName:"tr",align:null},"Hot Keys situation where some keys does not have as much traffic compared to the others leading to uneven traffic")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"no joins across shards because the data is separate, if we attempt to join them, it would be very slow")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"famous example of hot key senario",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"instagram: justin bieber user id had way more traffic than an average user",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"thus there is no good way to handle the traffic whenever he posts a picture, the servers would go crazy"))))),(0,r.kt)("li",{parentName:"ul"},"some cases, there's no way good way to handle sharding, just have to deal with it")),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://github.com/reshinto/Basic_technologies_revision/raw/master/interviewPrep/system_design/images/sharding.png",alt:"alt text",title:"sharding"})),(0,r.kt)("h3",{id:"vertical-partitioning"},"Vertical Partitioning"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"divide up the schema of database into separate tables",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"typically done by functionality if there is 1 big row of user data",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"data that does not make sense to be used together would make sense to split them apart so that you do not retrieve a bunch of data that is not required"))))),(0,r.kt)("li",{parentName:"ul"},"best when most data in row isn't needed for most queries")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"pros"),(0,r.kt)("th",{parentName:"tr",align:null},"cons"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"generally it is easier to implement than sharding"),(0,r.kt)("td",{parentName:"tr",align:null},"could potentially end up having to shard or horizontally partition anyway, which would get complicated because the data has already been vertically partitioned")))),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://github.com/reshinto/Basic_technologies_revision/raw/master/interviewPrep/system_design/images/verticalPartitioning.png",alt:"alt text",title:"Vertical Partitioning"})),(0,r.kt)("h2",{id:"when-to-consider-nosql"},"When to consider NoSQL"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"when the benefit of relational database is gone",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"e.g.: normalized data, strong consistency, simple data model"))),(0,r.kt)("li",{parentName:"ul"},"when you made a lot of trade offs trying to scale, it becomes unrecognizable compared to a standard SQL setup"),(0,r.kt)("li",{parentName:"ul"},"the reason why you would choose a NoSQL isn't because NoSQL is magical",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"you choose it because you know up front what you are sacrificing and what specifically you need for your application that you can make a trade off",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"when you start of with a relational databases, you thought you would stay with all the best practices"),(0,r.kt)("li",{parentName:"ul"},"but by the time you end up scaling, you have lost all of it"))))),(0,r.kt)("li",{parentName:"ul"},"examples:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"when dealing with transactions and banking, you would want consistency with SQL"),(0,r.kt)("li",{parentName:"ul"},"for stuff like google or social media where you don't need perfect consistency right away, you could make those trade offs for scale with NoSQL")))))}d.isMDXComponent=!0}}]);