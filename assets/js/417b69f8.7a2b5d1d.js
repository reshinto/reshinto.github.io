"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[8251],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=u(n),h=a,m=p["".concat(s,".").concat(h)]||p[h]||c[h]||l;return n?r.createElement(m,o(o({ref:t},d),{},{components:n})):r.createElement(m,o({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=p;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var u=2;u<l;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},54656:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var r=n(83117),a=(n(67294),n(3905));const l={},o="Trees",i={unversionedId:"interviewPrep/data_structures/13Trees/readme",id:"interviewPrep/data_structures/13Trees/readme",title:"Trees",description:"- a special type of graph",source:"@site/docs/interviewPrep/data_structures/13Trees/readme.md",sourceDirName:"interviewPrep/data_structures/13Trees",slug:"/interviewPrep/data_structures/13Trees/",permalink:"/docs/interviewPrep/data_structures/13Trees/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/data_structures/13Trees/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Graph Example",permalink:"/docs/interviewPrep/data_structures/12Graphs/typescript/graph"},next:{title:"B-Trees",permalink:"/docs/interviewPrep/data_structures/13Trees/bTrees/"}},s={},u=[{value:"Types of trees",id:"types-of-trees",level:2},{value:"Binary Trees",id:"binary-trees",level:3},{value:"Binary Search Tree (BST)",id:"binary-search-tree-bst",level:4},{value:"K-ary Tree",id:"k-ary-tree",level:4},{value:"Perfect Binary Tree",id:"perfect-binary-tree",level:4},{value:"Complete Binary Tree",id:"complete-binary-tree",level:4},{value:"Balanced Binary Tree",id:"balanced-binary-tree",level:4},{value:"Full Binary Tree",id:"full-binary-tree",level:4},{value:"Heaps",id:"heaps",level:3},{value:"Min Heaps",id:"min-heaps",level:4},{value:"Max Heaps",id:"max-heaps",level:4},{value:"Ternary Tree",id:"ternary-tree",level:3},{value:"Tries",id:"tries",level:3},{value:"AVL Trees",id:"avl-trees",level:3},{value:"Red Black Trees",id:"red-black-trees",level:3},{value:"standard operations and complexities",id:"standard-operations-and-complexities",level:2},{value:"Storing all types of tree: O(N) space",id:"storing-all-types-of-tree-on-space",level:3},{value:"Traversing through the entire tree: O(N) time",id:"traversing-through-the-entire-tree-on-time",level:3},{value:"Traversing 1 subtree at every step for a balance binary tree: O(log N) time on average",id:"traversing-1-subtree-at-every-step-for-a-balance-binary-tree-olog-n-time-on-average",level:3},{value:"Search, Insert, Delete",id:"search-insert-delete",level:3},{value:"Traversal Types",id:"traversal-types",level:2},{value:"Breath First Traversal",id:"breath-first-traversal",level:3},{value:"Depth First Traversal",id:"depth-first-traversal",level:3},{value:"Inorder (Left, Root, Right)",id:"inorder-left-root-right",level:4},{value:"Preorder (Root, Left, Right)",id:"preorder-root-left-right",level:4},{value:"Postorder (Left, Right, Root)",id:"postorder-left-right-root",level:4},{value:"Binary Search",id:"binary-search",level:2},{value:"Min and Max of Binary Search Trees",id:"min-and-max-of-binary-search-trees",level:2},{value:"Min",id:"min",level:3},{value:"Max",id:"max",level:3},{value:"Successor",id:"successor",level:2},{value:"Insertions",id:"insertions",level:2},{value:"Deletion",id:"deletion",level:2}],d={toc:u};function c(e){let{components:t,...l}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"trees"},"Trees"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"a special type of graph"),(0,a.kt)("li",{parentName:"ul"},"trees excel at storing data hierarchically and are commonly used as a means of testing your knowledge of recursion during coding interviews"),(0,a.kt)("li",{parentName:"ul"},"it is a data structure that consists of nodes, each with some value and pointers to child-nodes",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"which recursively form subtrees in the tree"))),(0,a.kt)("li",{parentName:"ul"},"the 1st node in a tree is referred to as the root of the tree",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"while the nodes at the bottom of a tree (the nodes with no child-nodes) are referred to as leaf nodes or leaves"),(0,a.kt)("li",{parentName:"ul"},"the paths between the root of a tree and its leaves are called branches"),(0,a.kt)("li",{parentName:"ul"},"the height of a tree is the length of its longest branch"),(0,a.kt)("li",{parentName:"ul"},"the depth of a tree node is its distance from its tree's root",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"also known as the node's level in the tree"))))),(0,a.kt)("li",{parentName:"ul"},"a tree is effectively a graph that's connected, directed, and acyclic",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"has an explicit root node, and whose nodes all have a single parent (except for the root node)"),(0,a.kt)("li",{parentName:"ul"},"in most implementations of trees, tree nodes don't have a pointer to their parent, but can if desired")))),(0,a.kt)("h2",{id:"types-of-trees"},"Types of trees"),(0,a.kt)("h3",{id:"binary-trees"},"Binary Trees"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the root node has 2 child nodes"),(0,a.kt)("li",{parentName:"ul"},"every other nodes have up to 2 child nodes"),(0,a.kt)("li",{parentName:"ul"},"the structure of a binary tree is such that many of its operations have a logarithmic time complexity, making binary tree a commonly used data structure")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class Node:\n  def __init__(self, value):\n    self.value = value\n    self.left = None\n    self.right = None\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class Node<T> {\n  constructor(public value: T) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n")),(0,a.kt)("h4",{id:"binary-search-tree-bst"},"Binary Search Tree (BST)"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"it is a node-based binary tree data structure which has the following properties"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The left subtree of a node contains only nodes with values smaller than the node's value"),(0,a.kt)("li",{parentName:"ul"},"The right subtree of a node contains only nodes with values bigger than the node's value"),(0,a.kt)("li",{parentName:"ul"},"The left and right subtree each must also be a binary search tree or be null"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"If a node is to be inserted into a tree, it is compared with current node (starting from the root)"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If the node's value is less than current, we send it down to left subtree"),(0,a.kt)("li",{parentName:"ul"},"If node's value is greater than or equal to current",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"it is sent to the right subtree"),(0,a.kt)("li",{parentName:"ul"},"This process is repeated for each encountered node")))))),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Binary Search Tree",src:n(53279).Z,width:"1094",height:"580"})),(0,a.kt)("h4",{id:"k-ary-tree"},"K-ary Tree"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"a tree where every node (including the root) have up to k child nodes",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"e.g.: a binary tree is a k-ary tree where k === 2")))),(0,a.kt)("h4",{id:"perfect-binary-tree"},"Perfect Binary Tree"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"a binary tree whose interior nodes all have 2 child nodes and whose leaf nodes all have the same depth",(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"        1\n    /         \\\n   2           3\n  /  \\       /   \\\n 4    5     6     7\n /\\   /\\    /\\    /\\\n8  9 10 11 12 13 14 15\n")))),(0,a.kt)("h4",{id:"complete-binary-tree"},"Complete Binary Tree"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"a binary tree that's almost perfect"),(0,a.kt)("li",{parentName:"ul"},"its interior nodes all have 2 child nodes"),(0,a.kt)("li",{parentName:"ul"},"but its leaf nodes don't necessarily all have the same depth"),(0,a.kt)("li",{parentName:"ul"},"furthermore, the nodes in the last level of a complete binary tree are as far left as possible",(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"      1\n    /   \\\n   2     3\n  / \\   / \\\n 4   5 6   7\n /\\\n8  9\n"))),(0,a.kt)("li",{parentName:"ul"},"a binary tree is incomplete if the nodes in its last level aren't as far left as possible",(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"      1\n    /   \\\n   2     3\n  / \\   / \\\n 4   5 6   7\n    /   \\\n   8     9\n")))),(0,a.kt)("h4",{id:"balanced-binary-tree"},"Balanced Binary Tree"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"       1\n     /    \\\n    2      3\n   / \\    / \\\n  4   5  6   7\n / \\        /\n10  9      8\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"a binary tree whose nodes all have left and right subtrees whose heights differ by no more than 1"),(0,a.kt)("li",{parentName:"ul"},"a balanced binary tree is such that the logarithmic time complexity ",(0,a.kt)("inlineCode",{parentName:"li"},"O(log n)")," of its operations is maintained"),(0,a.kt)("li",{parentName:"ul"},"e.g.: inserting a node at the bottom of the following imbalanced binary tree's left subtree would clearly not be a logarithmic-time operation, since it would involve traversing through most of the tree's nodes",(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"         1\n       /  \\\n      2    3\n     /\n    4\n   /\n  8\n /\n10\n")))),(0,a.kt)("h4",{id:"full-binary-tree"},"Full Binary Tree"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"a binary tree whose nodes all have either 2 child nodes or 0 child nodes",(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"  1\n / \\\n2   3\n   / \\\n  6   7\n / \\\n8   9\n")))),(0,a.kt)("h3",{id:"heaps"},"Heaps"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"they are typically binary heaps"),(0,a.kt)("li",{parentName:"ul"},"a special type of binary trees, where every node in the tree satisfies the min or max heap property")),(0,a.kt)("h4",{id:"min-heaps"},"Min Heaps"),(0,a.kt)("h4",{id:"max-heaps"},"Max Heaps"),(0,a.kt)("h3",{id:"ternary-tree"},"Ternary Tree"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the root node has 3 child nodes"),(0,a.kt)("li",{parentName:"ul"},"every other nodes have up to 3 child nodes")),(0,a.kt)("h3",{id:"tries"},"Tries"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"a tree like data structure that typically stores characters in a string")),(0,a.kt)("h3",{id:"avl-trees"},"AVL Trees"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"able to rebalance themselves to obtain the log N complexity")),(0,a.kt)("h3",{id:"red-black-trees"},"Red Black Trees"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"able to rebalance themselves to obtain the log N complexity")),(0,a.kt)("h2",{id:"standard-operations-and-complexities"},"standard operations and complexities"),(0,a.kt)("h3",{id:"storing-all-types-of-tree-on-space"},"Storing all types of tree: O(N) space"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"N is the total number of nodes in the tree")),(0,a.kt)("h3",{id:"traversing-through-the-entire-tree-on-time"},"Traversing through the entire tree: O(N) time"),(0,a.kt)("h3",{id:"traversing-1-subtree-at-every-step-for-a-balance-binary-tree-olog-n-time-on-average"},"Traversing 1 subtree at every step for a balance binary tree: O(log N) time on average"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"if the tree is skewed, it becomes O(N) time on worst")),(0,a.kt)("h3",{id:"search-insert-delete"},"Search, Insert, Delete"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"for Binary Search Tree: ",(0,a.kt)("inlineCode",{parentName:"li"},"O(h)"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"h is the height of the BST"))),(0,a.kt)("li",{parentName:"ul"},"for skewed tree: ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n)"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"n is the number of nodes")))),(0,a.kt)("h2",{id:"traversal-types"},"Traversal Types"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Using Recursion")),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"pros"),(0,a.kt)("th",{parentName:"tr",align:null},"cons"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"The code may be easier to write"),(0,a.kt)("td",{parentName:"tr",align:null},"Recursive functions are generally slower than non-recursive function")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"To solve such problems which are naturally recursive such as tower of Hanoi"),(0,a.kt)("td",{parentName:"tr",align:null},"It may require a lot of memory space to hold intermediate results on the system stacks")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Reduce unnecessary calling of function"),(0,a.kt)("td",{parentName:"tr",align:null},"Hard to analyze or understand the code")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Extremely useful when applying the same solution"),(0,a.kt)("td",{parentName:"tr",align:null},"It is not more efficient in terms of space and time complexity")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Recursion reduce the length of code"),(0,a.kt)("td",{parentName:"tr",align:null},"The computer may run out of memory if the recursive calls are not properly checked")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"It is very useful in solving the data structure problem"),(0,a.kt)("td",{parentName:"tr",align:null})),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Stacks evolutions and infix, prefix, postfix evaluations etc"),(0,a.kt)("td",{parentName:"tr",align:null})))),(0,a.kt)("h3",{id:"breath-first-traversal"},"Breath First Traversal"),(0,a.kt)("h3",{id:"depth-first-traversal"},"Depth First Traversal"),(0,a.kt)("h4",{id:"inorder-left-root-right"},"Inorder (Left, Root, Right)"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"example",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"3, 5, 6, 9, 11, 12"))),(0,a.kt)("li",{parentName:"ul"},"prints the values in the left subtree, then the value of the root subtree, then the right subtree")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Traverse the left subtree, i.e., call Inorder(left-subtree)"),(0,a.kt)("li",{parentName:"ol"},"Visit the root."),(0,a.kt)("li",{parentName:"ol"},"Traverse the right subtree, i.e., call Inorder(right-subtree)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def in_order(current_node):\n  if current_node:\n    in_order(current_node.left)\n    print(current_node.value)\n    in_order(current_node.right)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function inOrder(node: Node | null) {\n  if (node) {\n    inOrder(node.left);\n    console.log(node.value);\n    inOrder(node.right);\n  }\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def in_order(root):\n  if root is None:\n    return\n\n  node_stack = []\n  node_stack.append(root)\n\n  while(len(node_stack) > 0):\n    current_node = node_stack.pop()\n\n    # Note that right child is pushed first so that left is processed first\n    if current_node.right:\n      node_stack.append(current_node.right)\n\n    print(current_node.value)\n\n    if current_node.left:\n      node_stack.append(current_node.left)\n")),(0,a.kt)("h4",{id:"preorder-root-left-right"},"Preorder (Root, Left, Right)"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"example",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"9, 5, 3, 6, 12, 11"))),(0,a.kt)("li",{parentName:"ul"},"prints the root value, then value in left subtree, then value in right subtree")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Visit the root."),(0,a.kt)("li",{parentName:"ol"},"Traverse the left subtree, i.e., call Preorder(left-subtree)"),(0,a.kt)("li",{parentName:"ol"},"Traverse the right subtree, i.e., call Preorder(right-subtree)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def pre_order(current_node):\n  if current_node:\n    print(current_node.value)\n    pre_order(current_node.left)\n    pre_order(current_node.right)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function preOrder(node: Node | null) {\n  if (node) {\n    console.log(node.value);\n    preOrder(node.left);\n    preOrder(node.right);\n  }\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def pre_order(root):\n  if root is None:\n    return\n\n  node_stack = []\n  node_stack.append(root)\n\n  while(len(node_stack) > 0):\n    current = node_stack.pop()\n    print(current.value)\n\n    # Note that right child is pushed first so that left is processed first\n    if current.right:\n      node_stack.append(current.right)\n    if current.left:\n      node_stack.append(current.left)\n")),(0,a.kt)("h4",{id:"postorder-left-right-root"},"Postorder (Left, Right, Root)"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"example",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"3, 6, 5, 11, 12, 9"))),(0,a.kt)("li",{parentName:"ul"},"prints the value of the left subtree, then the value of the right subtree, then the root value")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Traverse the left subtree, i.e., call Postorder(left-subtree)"),(0,a.kt)("li",{parentName:"ol"},"Traverse the right subtree, i.e., call Postorder(right-subtree)"),(0,a.kt)("li",{parentName:"ol"},"Visit the root.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def post_order(current_node):\n  if current_node:\n    post_order(current_node.left)\n    post_order(current_node.right)\n    print(current_node.value)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function postOrder(node: TreeNode | null) {\n  if (node) {\n    postOrder(node.left);\n    postOrder(node.right);\n    console.log(node.value);\n  }\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def post_order(root):\n  if root is None:\n    return\n\n  node_stack = []\n  node_stack.append(root)\n\n  while(len(node_stack) > 0):\n    current = node_stack.pop()\n\n    # Note that right child is pushed first so that left is processed first\n    if current.right:\n      node_stack.append(current.right)\n    if current.left:\n      node_stack.append(current.left)\n\n    print(current.value)\n")),(0,a.kt)("h2",{id:"binary-search"},"Binary Search"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def binary_search(current, target):\n  if current is None:\n    return None\n\n  if current.value == target:\n    return current\n\n  if target > current.value:\n    return binary_search(current.right, target)\n\n  if target < current.value:\n    return binary_search(current.left, target)\n\n  return None\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function binarySearch(current: Node | null, target: number): Node | null {\n  if (current === null) {\n    return null;\n  }\n\n  if (target === current.value) {\n    return current;\n  }\n\n  if (target > current.value) {\n    return binarySearch(current.right, target);\n  }\n\n  if (target < current.value) {\n    return binarySearch(current.left, target);\n  }\n\n  return null;\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def binary_search(tree, target):\n  current = tree\n  while current:\n    if current.value == target:\n      return current.value\n    if target > current.value:\n      current = current.right\n    elif target < current.value:\n      current = current.left\n    else:\n      break\n  return None\n")),(0,a.kt)("h2",{id:"min-and-max-of-binary-search-trees"},"Min and Max of Binary Search Trees"),(0,a.kt)("h3",{id:"min"},"Min"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"value is a minimum by following left child pointers from the root until we encounter a null")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function treeMinimum(node: Node) {\n  while (node.left) {\n    node = node.left;\n  }\n\n  return node;\n}\n")),(0,a.kt)("h3",{id:"max"},"Max"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"value is a maximum by following right child pointers from the root until we encounter a null")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function treeMaximum(node: Node) {\n  while (node.right) {\n    node = node.right;\n  }\n\n  return node;\n}\n")),(0,a.kt)("h2",{id:"successor"},"Successor"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"it is the node with the smallest value greater than targetNode.value")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function getSuccessor(tree: Node, targetNode: Node) {\n  if (tree === targetNode) {\n    return null;\n  }\n\n  if (targetNode.right) {\n    return treeMinimum(targetNode.right);\n  }\n\n  let successor = null;\n  let currentNode: Node | null = tree;\n\n  while (currentNode) {\n    if (currentNode.value <= targetNode.value) {\n      currentNode = currentNode.right;\n    } else {\n      successor = currentNode;\n      currentNode = currentNode.left;\n    }\n  }\n\n  return successor;\n}\n")),(0,a.kt)("h2",{id:"insertions"},"Insertions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function insertNode(tree: Node | null, node: Node) {\n  if (!tree) {\n    return node;\n  }\n\n  let leafNode: Node | null = tree;\n  let leafNodeParent: Node = tree;\n\n  while (leafNode) {\n    leafNodeParent = leafNode;\n\n    leafNode = node.value < leafNode.value ? leafNode.left : leafNode.right;\n  }\n\n  if (node.value < leafNodeParent.value) {\n    leafNodeParent.left = node;\n  } else {\n    leafNodeParent.right = node;\n  }\n}\n")),(0,a.kt)("h2",{id:"deletion"},"Deletion"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The overall strategy for deleting a node node from a binary search tree tree has three basic cases"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"If node is leaf (has no children)"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"then remove it by modifying its parent to replace node with null as its child")),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("img",{alt:"Tree deletion No Children",src:n(97703).Z,width:"936",height:"360"}))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"If node has just one child"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"then elevate that child to take nodes position in the tree by modifying node parent to replace node by nodes child")),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("img",{alt:"Tree deletion One Child",src:n(89453).Z,width:"936",height:"484"}))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"If node has two children"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"then find node successor parent",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"must be in node right subtree"),(0,a.kt)("li",{parentName:"ul"},"and have parent take nodes position in the tree"))),(0,a.kt)("li",{parentName:"ul"},"The rest of nodes original right subtree becomes parents new right subtree, and nodes left subtree becomes parents new left subtree"),(0,a.kt)("li",{parentName:"ul"},"This case is the tricky because it matters whether parent is nodes right child")),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("img",{alt:"Tree deletion Two Children",src:n(86960).Z,width:"934",height:"562"})))))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function deleteNode(tree: Node | null, value: number): Node | null {\n  if (tree === null) {\n    return tree;\n  }\n\n  if (value < tree.value) {\n    tree.left = deleteNode(tree.left, value);\n  } else if (value > tree.value) {\n    tree.right = deleteNode(tree.right, value);\n  }\n  // this is the node to be deleted\n  else {\n    // node with only one child or no child\n    if (tree.left === null) {\n      return tree.right;\n    }\n\n    if (tree.right === null) {\n      return tree.left;\n    }\n\n    // node with two children: get the inorder predecessor (largest in the left subtree)\n    tree.value = treeMaximum(tree.left).value;\n\n    // delete the inorder predecessor\n    tree.left = deleteNode(tree.left, tree.value);\n  }\n\n  return tree;\n}\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"full Binary Search Tree example"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"utils"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"enum Compare {\n  LessThan = -1,\n  BiggerThan = 1,\n  Equals = 0,\n}\n\nfunction compare<T>(a: T, b: T): number {\n  if (a === b) {\n    return Compare.Equals;\n  }\n  return a < b ? Compare.LessThan : Compare.BiggerThan;\n}\n")))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export class Node<T> {\n  public left: Node<T> = null;\n  public right: Node<T> = null;\n\n  constructor(public value: T) {\n    this.value = value;\n  }\n\n  public toString() {\n    return `${this.value}`;\n  }\n}\n")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class BinarySearchTree<T> {\n  protected root: Node<T> = null;\n\n  /**\n   * @description: insert element\n   */\n  public insert(value: T) {\n    if (this.root === null) {\n      // edge case: insert into root node\n      this.root = new Node(value);\n    } else {\n      // recursively find the insertion position\n      this.insertNode(this.root, value);\n    }\n  }\n\n  /**\n   * @description: recursive insertion method\n   */\n  protected insertNode(node: Node<T>, value: T) {\n    if (compare(value, node.value) === Compare.LessThan) {\n      // If the value is smaller than node.value, go to the left\n      if (node.left === null) {\n        // Baseline condition: the left side is empty and directly assigned\n        node.left = new Node(value);\n      } else {\n        // otherwise recurse\n        this.insertNode(node.left, value);\n      }\n      // If the value is larger than node.value, go to the right\n    } else if (node.right === null) {\n      // Baseline condition: the right side is empty and directly assigned\n      node.right = new Node(value);\n    } else {\n      // otherwise recurse\n      this.insertNode(node.right, value);\n    }\n  }\n\n  /**\n   * @description: return the root node\n   */\n  public getRoot() {\n    return this.root;\n  }\n\n  /**\n   * @description: search element\n   */\n  public search(value: T) {\n    // call recursive search element method\n    return this.searchNode(this.root, value);\n  }\n\n  /**\n   * @description: recursive search element method\n   */\n  private searchNode(node: Node<T>, value: T): boolean {\n    // Baseline condition: return false when null is found\n    if (node === null) {\n      return false;\n    }\n\n    if (compare(value, node.value) === Compare.LessThan) {\n      // value is smaller than node.value, look left\n      return this.searchNode(node.left, value);\n    } else if (compare(value, node.value) === Compare.BiggerThan) {\n      // value is bigger than node.value, look right\n      return this.searchNode(node.right, value);\n    }\n    // value is equal to node.value, element is found\n    return true;\n  }\n\n  public inOrderTraverse(callback: Function) {\n    this.inOrderTraverseNode(this.root, callback);\n  }\n\n  private inOrderTraverseNode(node: Node<T>, callback: Function) {\n    if (node !== null) {\n      this.inOrderTraverseNode(node.left, callback);\n      callback(node.value);\n      this.inOrderTraverseNode(node.right, callback);\n    }\n  }\n\n  public preOrderTraverse(callback: Function) {\n    this.preOrderTraverseNode(this.root, callback);\n  }\n\n  private preOrderTraverseNode(node: Node<T>, callback: Function) {\n    if (node !== null) {\n      callback(node.value);\n      this.preOrderTraverseNode(node.left, callback);\n      this.preOrderTraverseNode(node.right, callback);\n    }\n  }\n\n  postOrderTraverse(callback: Function) {\n    this.postOrderTraverseNode(this.root, callback);\n  }\n\n  private postOrderTraverseNode(node: Node<T>, callback: Function) {\n    if (node !== null) {\n      this.postOrderTraverseNode(node.left, callback);\n      this.postOrderTraverseNode(node.right, callback);\n      callback(node.value);\n    }\n  }\n\n  /**\n   * @description: return smallest element in tree\n   */\n  public min() {\n    // call iterator method\n    return this.minNode(this.root);\n  }\n\n  /**\n   * @description: returns the smallest element under the specified subtree\n   */\n  protected minNode(node: Node<T>) {\n    let current = node;\n\n    // keep looking left\n    while (current !== null && current.left !== null) {\n      current = current.left;\n    }\n    return current;\n  }\n\n  /**\n   * @description: return largest element in tree\n   */\n  public max() {\n    // call iterator method\n    return this.maxNode(this.root);\n  }\n\n  /**\n   * @description: returns the largest element under the specified subtree\n   */\n  protected maxNode(node: Node<T>) {\n    let current = node;\n\n    // keep looking right\n    while (current !== null && current.right !== null) {\n      current = current.right;\n    }\n    return current;\n  }\n\n  /**\n   * @description: remove the specified element\n   */\n  public remove(value: T) {\n    // Call the recursive method, the recursion here is special, and the deleted tree will be returned\n    this.root = this.removeNode(this.root, value);\n  }\n\n  /**\n   * @description: A recursive method that removes the specified element in the specified subtree. After each processing, the processed node needs to be returned to this node\n   */\n  protected removeNode(node: Node<T>, value: T) {\n    // baseline condition\n    if (node === null) {\n      return null;\n    }\n\n    if (compare(value, node.value) === Compare.LessThan) {\n      // When the value is less than node.value, look left\n      node.left = this.removeNode(node.left, value);\n      return node;\n    } else if (compare(value, node.value) === Compare.BiggerThan) {\n      // When the value is greater than node.value, look to the right\n      node.right = this.removeNode(node.right, value);\n      return node;\n    } else {\n      // value is equal to node.value\n      // At this point, the node to be deleted has been found\n      // handle 3 special conditions\n\n      // case 1: When the node to be deleted is a leaf node\n      if (node.left === null && node.right === null) {\n        node = null;\n        return node;\n      }\n\n      // case 2: When the node to delete has only one right child\n      if (node.left === null) {\n        node = node.right;\n        return node;\n        // The same deleted node has only one left child node\n      } else if (node.right === null) {\n        node = node.left;\n        return node;\n      }\n\n      // case 3: When the node to be deleted has two children\n      const aux = this.minNode(node.right);\n      node.value = aux.value;\n      node.right = this.removeNode(node.right, aux.value);\n      return node;\n    }\n  }\n}\n")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"let tree = new BinarySearchTree<number>();\nconsole.log(tree.getRoot());\n\ntree.insert(11);\ntree.insert(7);\ntree.insert(15);\ntree.insert(5);\ntree.insert(3);\ntree.insert(9);\ntree.insert(8);\ntree.insert(10);\ntree.insert(13);\ntree.insert(12);\ntree.insert(14);\ntree.insert(20);\ntree.insert(18);\ntree.insert(25);\nconsole.log(tree.getRoot());\nconsole.log(tree.getRoot().left);\nconsole.log(tree.getRoot().right);\n\ntree.preOrderTraverse(console.log);\ntree.inOrderTraverse(console.log);\ntree.postOrderTraverse(console.log);\n\nconsole.log(tree.search(8));\nconsole.log(tree.search(0));\nconsole.log(tree.min());\nconsole.log(tree.max());\nconsole.log(tree.remove(8));\nconsole.log(tree.search(8));\n")))))}c.isMDXComponent=!0},97703:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/node_deletion_from_tree1-2e27fe4031a752fc6d36b98ac97e4b5f.jpg"},89453:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/node_deletion_from_tree2-2baa7507d15837ceba1f8655a1ba38a3.jpg"},86960:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/node_deletion_from_tree3-dfb824761b363bd86b370ca3f5c4e146.jpg"},53279:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/tree1-d9f63ee003703877df0648573d08e5bc.jpg"}}]);