"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[4451],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>d});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),i=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=i(e.components);return r.createElement(c.Provider,{value:n},e.children)},s={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),h=i(t),d=a,m=h["".concat(c,".").concat(d)]||h[d]||s[d]||o;return t?r.createElement(m,l(l({ref:n},p),{},{components:t})):r.createElement(m,l({ref:n},p))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,l=new Array(o);l[0]=h;var u={};for(var c in n)hasOwnProperty.call(n,c)&&(u[c]=n[c]);u.originalType=e,u.mdxType="string"==typeof e?e:a,l[1]=u;for(var i=2;i<o;i++)l[i]=t[i];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},35098:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>s,frontMatter:()=>o,metadata:()=>u,toc:()=>i});var r=t(83117),a=(t(67294),t(3905));const o={},l="Count Construct example",u={unversionedId:"interviewPrep/algorithms_and_techniques/dynamic_programming/countConstruct",id:"interviewPrep/algorithms_and_techniques/dynamic_programming/countConstruct",title:"Count Construct example",description:"- explanation",source:"@site/docs/interviewPrep/algorithms_and_techniques/dynamic_programming/countConstruct.md",sourceDirName:"interviewPrep/algorithms_and_techniques/dynamic_programming",slug:"/interviewPrep/algorithms_and_techniques/dynamic_programming/countConstruct",permalink:"/docs/interviewPrep/algorithms_and_techniques/dynamic_programming/countConstruct",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/algorithms_and_techniques/dynamic_programming/countConstruct.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Can Sum example",permalink:"/docs/interviewPrep/algorithms_and_techniques/dynamic_programming/canSum"},next:{title:"Fibonacci example",permalink:"/docs/interviewPrep/algorithms_and_techniques/dynamic_programming/fibonacci"}},c={},i=[{value:"Naive solution",id:"naive-solution",level:2},{value:"Memoization solution",id:"memoization-solution",level:2},{value:"Tabulation solution",id:"tabulation-solution",level:2}],p={toc:i};function s(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"count-construct-example"},"Count Construct example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Write a function "countConstruct(target, wordBank)" that accepts a target string and an array of strings\n\nThe function should return the number of ways that the "target" can be constructed by concatenating elements of the "wordBank" array\n\nYou may reuse elements of "wordBank" as many times as needed\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"explanation")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Question: countConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd"])\n\nAnswer: 1\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"graph display of what goes behind the hood for ",(0,a.kt)("inlineCode",{parentName:"li"},"countConstruct(target, wordBank)"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'countConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd"]) -> 1\n* do not take out characters from the middle of a string\n* only branch the children if we have a matching prefix in the word bank\n\nm = target.length\nn = wordBank.length\nheight = m\n\n       abcdef                       1\n  /(ab)  |(abc)  \\(abcd)\ncdef    def       ef                * n\n |(cd)   |(def)\n ef      ""                         * n\n\nwhen leaf node is "" returns value 1 to parent\nwhen leaf node is not empty and cannot be broken down any more, returns value 0 to parent\nparent would then sum all of the children node values together\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'countConstruct("purple", ["purp", "p", "ur", "le", "purpl"]) -> 2\n\n         purple\n  /(purp)  |(p)  \\(purpl)\n le      urple    e\n |(le)     |(ur)\n ""       ple\n           |(p)\n           le\n           |(le)\n           ""\n')),(0,a.kt)("h2",{id:"naive-solution"},"Naive solution"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"time complexity is ",(0,a.kt)("inlineCode",{parentName:"li"},"O((n^m) * m)")),(0,a.kt)("li",{parentName:"ul"},"space complexity is ",(0,a.kt)("inlineCode",{parentName:"li"},"O(m * m)"),", simplified to ",(0,a.kt)("inlineCode",{parentName:"li"},"O(m^2)"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'const countConstruct = (target, wordBank) => {\n  if (target === "") return 1;\n\n  let totalCount = 0;\n\n  for (const word of wordBank) {\n    // time n\n    if (target.indexOf(word) === 0) {\n      const numWaysForRest = countConstruct(\n        target.slice(word.length),\n        wordBank\n      ); // time ^m, * m, space m^2\n      totalCount += numWaysForRest;\n    }\n  }\n  return totalCount;\n};\n\nconsole.log(countConstruct("purple", ["purp", "p", "ur", "le", "purpl"])); // 2\nconsole.log(countConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd"])); // 1\nconsole.log(\n  countConstruct("skateboard", ["bo", "rd", "ate", "t", "ska", "sk", "boar"])\n); // 0\nconsole.log(\n  countConstruct("enterapotentpot", ["a", "p", "ent", "enter", "ot", "o", "t"])\n); // 4\nconsole.log(\n  countConstruct("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef", [\n    "e",\n    "ee",\n    "eee",\n    "eeee",\n    "eeeee",\n    "eeeeee",\n  ])\n); // 0\n')),(0,a.kt)("h2",{id:"memoization-solution"},"Memoization solution"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"time complexity is O(n ",(0,a.kt)("em",{parentName:"li"}," m ")," m), simplified to O(n ","*"," m^2)"),(0,a.kt)("li",{parentName:"ul"},"space complexity is O(m ","*"," m), simplified to O(m^2)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'const countConstruct = (target, wordBank, memo = {}) => {\n  if (target in memo) return memo[target]; // space m\n  if (target === "") return 1;\n\n  let totalCount = 0;\n\n  for (const word of wordBank) {\n    // time n\n    if (target.indexOf(word) === 0) {\n      const numWaysForRest = countConstruct(\n        target.slice(word.length),\n        wordBank,\n        memo\n      ); // time m * m, space m\n      totalCount += numWaysForRest;\n    }\n  }\n  memo[target] = totalCount;\n  return totalCount;\n};\n\nconsole.log(countConstruct("purple", ["purp", "p", "ur", "le", "purpl"])); // 2\nconsole.log(countConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd"])); // 1\nconsole.log(\n  countConstruct("skateboard", ["bo", "rd", "ate", "t", "ska", "sk", "boar"])\n); // 0\nconsole.log(\n  countConstruct("enterapotentpot", ["a", "p", "ent", "enter", "ot", "o", "t"])\n); // 4\nconsole.log(\n  countConstruct("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef", [\n    "e",\n    "ee",\n    "eee",\n    "eeee",\n    "eeeee",\n    "eeeeee",\n  ])\n); // 0\n')),(0,a.kt)("h2",{id:"tabulation-solution"},"Tabulation solution"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'countConstruct("purple", ["purp", "p", "ur", "le", "purpl"]) -> 2\n\nm = target\nn = wordBank.length\n\nfirst create an array the size of the target.length + 1\nset default value to be 0\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   0     0     0     0     0     0     0\nActual char:   p     u     r     p     l     e\n\nwhen target value is an empty string, no string concatenation is required to get "", therefore return value should be 1\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     0     0     0     0     0     0\nActual char:   p     u     r     p     l     e\n\nlook at the 1st element of the array ["purp", "p", "ur", "le", "purpl"] is "purp"\ncurrent index is 0, value is 1, and actual char is "p"\nsince first char of "purp" === actual char "p"\nwe can look at "purp" char length 4 steps ahead of the current index,\nvalue can be changed to the same as current value 1\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     0     0     0     1     0     0\nActual char:   p     u     r     p     l     e\n\nlook at the 2nd element of the array ["purp", "p", "ur", "le", "purpl"] is "p"\ncurrent index is 0, value is 1, and actual char is "p"\nsince first char of "p" === actual char "p"\nwe can look at "p" char length 1 steps ahead of the current index,\nvalue can be changed to the same as current value 1\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     0     1     0     0\nActual char:   p     u     r     p     l     e\n\nlook at the 3rd element of the array ["purp", "p", "ur", "le", "purpl"] is "ur"\ncurrent index is 0, value is 1, and actual char is "p"\nsince first char of "ur" !== actual char "p"\nwe can ignore and skip this\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     0     1     0     0\nActual char:   p     u     r     p     l     e\n\nlook at the 4th element of the array ["purp", "p", "ur", "le", "purpl"] is "le"\ncurrent index is 0, value is 1, and actual char is "p"\nsince first char of "le" !== actual char "p"\nwe can ignore and skip this\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     0     1     0     0\nActual char:   p     u     r     p     l     e\n\nlook at the 5th element of the array ["purp", "p", "ur", "le", "purpl"] is "purpl"\ncurrent index is 0, value is 1, and actual char is "p"\nsince first char of "purpl" === actual char "p"\nwe can look at "purpl" char length 5 steps ahead of the current index,\nvalue can be changed to the same as current value 1\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     0     1     1     0\nActual char:   p     u     r     p     l     e\n\nmove current value to the next index\nlook at the 1st element of the array ["purp", "p", "ur", "le", "purpl"] is "purp"\ncurrent index is 1, value is 1, and actual char is "u"\nsince first char of "purp" !== actual char "u"\nwe can ignore and skip this\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     0     1     1     0\nActual char:   p     u     r     p     l     e\n\nlook at the 2nd element of the array ["purp", "p", "ur", "le", "purpl"] is "p"\ncurrent index is 1, value is 1, and actual char is "u"\nsince first char of "p" !== actual char "u"\nwe can ignore and skip this\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     0     1     1     0\nActual char:   p     u     r     p     l     e\n\nlook at the 3rd element of the array ["purp", "p", "ur", "le", "purpl"] is "ur"\ncurrent index is 1, value is 1, and actual char is "u"\nsince first char of "ur" === actual char "u"\nwe can look at "ur" char length 2 steps ahead of the current index,\nvalue can be changed to the same as current value 1\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     1     1     1     0\nActual char:   p     u     r     p     l     e\n\nlook at the 4th element of the array ["purp", "p", "ur", "le", "purpl"] is "le"\ncurrent index is 1, value is 1, and actual char is "u"\nsince first char of "le" !== actual char "u"\nwe can ignore and skip this\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     1     1     1     0\nActual char:   p     u     r     p     l     e\n\n\nlook at the 5th element of the array ["purp", "p", "ur", "le", "purpl"] is "purpl"\ncurrent index is 1, value is 1, and actual char is "u"\nsince first char of "purpl" !== actual char "u"\nwe can ignore and skip this\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     1     1     1     0\nActual char:   p     u     r     p     l     e\n\nmove current value to the next index\nlook at the 1st element of the array ["purp", "p", "ur", "le", "purpl"] is "purp"\ncurrent index is 2, value is 0, and actual char is "r"\nsince value is 0\nwe can ignore and skip the entire process and move to the next index\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     1     1     1     0\nActual char:   p     u     r     p     l     e\n\nmove current value to the next index\nlook at the 1st element of the array ["purp", "p", "ur", "le", "purpl"] is "purp"\ncurrent index is 3, value is 1, and actual char is "p"\nsince first char of "purp" === actual char "p"\nwe can look at "purp" char length 4 steps ahead of the current index,\nit is out of range, nothing needs to be changed\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     1     1     1     0\nActual char:   p     u     r     p     l     e\n\nlook at the 2nd element of the array ["purp", "p", "ur", "le", "purpl"] is "p"\ncurrent index is 3, value is 1, and actual char is "p"\nsince first char of "p" === actual char "p"\nwe can look at "p" char length 1 steps ahead of the current index,\nexisting value of 1 can be added to the current value 1 changing the value to 2\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     1     2     1     0\nActual char:   p     u     r     p     l     e\n\nlook at the 3rd element of the array ["purp", "p", "ur", "le", "purpl"] is "ur"\ncurrent index is 3, value is 1, and actual char is "p"\nsince first char of "ur" !== actual char "p"\nwe can ignore and skip this\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     1     2     1     0\nActual char:   p     u     r     p     l     e\n\nlook at the 4th element of the array ["purp", "p", "ur", "le", "purpl"] is "le"\ncurrent index is 3, value is 1, and actual char is "p"\nsince first char of "le" !== actual char "p"\nwe can ignore and skip this\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     1     2     1     0\nActual char:   p     u     r     p     l     e\n\nlook at the 5th element of the array ["purp", "p", "ur", "le", "purpl"] is "purpl"\ncurrent index is 3, value is 1, and actual char is "p"\nsince first char of "purpl" === actual char "p"\nwe can look at "purpl" char length 5 steps ahead of the current index,\nit is out of range, nothing needs to be changed\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     1     2     1     0\nActual char:   p     u     r     p     l     e\n\nmove current value to the next index\nlook at the 1st element of the array ["purp", "p", "ur", "le", "purpl"] is "purp"\ncurrent index is 4, value is 2, and actual char is "l"\nsince first char of "purp" !== actual char "l"\nwe can ignore and skip this\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     1     2     1     0\nActual char:   p     u     r     p     l     e\n\nlook at the 2nd element of the array ["purp", "p", "ur", "le", "purpl"] is "p"\ncurrent index is 4, value is 2, and actual char is "l"\nsince first char of "p" !== actual char "l"\nwe can ignore and skip this\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     1     2     1     0\nActual char:   p     u     r     p     l     e\n\nlook at the 3rd element of the array ["purp", "p", "ur", "le", "purpl"] is "ur"\ncurrent index is 4, value is 2, and actual char is "l"\nsince first char of "ur" !== actual char "l"\nwe can ignore and skip this\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     1     2     1     0\nActual char:   p     u     r     p     l     e\n\nlook at the 4th element of the array ["purp", "p", "ur", "le", "purpl"] is "le"\ncurrent index is 4, value is 2, and actual char is "l"\nsince first char of "le" === actual char "l"\nwe can look at "le" char length 2 steps ahead of the current index,\nexisting value of 0 can be added to the current value 2 changing the value to 2\n\nindex      :   0     1     2     3     4     5     6\nvalue      :   1     1     0     1     2     1     2\nActual char:   p     u     r     p     l     e\n\nwe can stop here, since nothing else will change\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"time complexity is O(n ",(0,a.kt)("em",{parentName:"li"}," m ")," m), simplified to O(n ","*"," m^2)"),(0,a.kt)("li",{parentName:"ul"},"space complexity is O(m), simplified to O(m)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'const countConstruct = (target, wordBank) => {\n  const table = Array(target.length + 1).fill(0); // space m\n  table[0] = 1;\n\n  for (let i = 0; i <= target.length; i++) {\n    // time m\n    for (const word of wordBank) {\n      // time n\n      if (target.slice(i, i + word.length) === word) {\n        // time m\n        table[i + word.length] += table[i];\n      }\n    }\n  }\n  return table[target.length];\n};\n\nconsole.log(countConstruct("purple", ["purp", "p", "ur", "le", "purpl"])); // 2\nconsole.log(countConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd"])); // 1\nconsole.log(\n  countConstruct("skateboard", ["bo", "rd", "ate", "t", "ska", "sk", "boar"])\n); // 0\nconsole.log(\n  countConstruct("enterapotentpot", ["a", "p", "ent", "enter", "ot", "o", "t"])\n); // 4\nconsole.log(\n  countConstruct("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef", [\n    "e",\n    "ee",\n    "eee",\n    "eeee",\n    "eeeee",\n    "eeeeee",\n  ])\n); // 0\n')))}s.isMDXComponent=!0}}]);