"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[4234],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>h});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var u=a.createContext({}),s=function(e){var n=a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},m=function(e){var n=s(e.components);return a.createElement(u.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,u=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=s(t),h=r,p=c["".concat(u,".").concat(h)]||c[h]||d[h]||i;return t?a.createElement(p,l(l({ref:n},m),{},{components:t})):a.createElement(p,l({ref:n},m))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=c;var o={};for(var u in n)hasOwnProperty.call(n,u)&&(o[u]=n[u]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var s=2;s<i;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},2300:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>s});var a=t(7462),r=(t(7294),t(3905));const i={},l="Best Sum example",o={unversionedId:"interviewPrep/algorithms_and_techniques/dynamic_programming/bestSum",id:"interviewPrep/algorithms_and_techniques/dynamic_programming/bestSum",title:"Best Sum example",description:"- explanation",source:"@site/docs/interviewPrep/algorithms_and_techniques/dynamic_programming/bestSum.md",sourceDirName:"interviewPrep/algorithms_and_techniques/dynamic_programming",slug:"/interviewPrep/algorithms_and_techniques/dynamic_programming/bestSum",permalink:"/docs/interviewPrep/algorithms_and_techniques/dynamic_programming/bestSum",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/algorithms_and_techniques/dynamic_programming/bestSum.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"All Construct example",permalink:"/docs/interviewPrep/algorithms_and_techniques/dynamic_programming/allConstruct"},next:{title:"Can Construct example",permalink:"/docs/interviewPrep/algorithms_and_techniques/dynamic_programming/canConstruct"}},u={},s=[{value:"Naive solution",id:"naive-solution",level:2},{value:"Memoization solution",id:"memoization-solution",level:2},{value:"Tabulation solution",id:"tabulation-solution",level:2}],m={toc:s};function d(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"best-sum-example"},"Best Sum example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Write a function "bestSum(targetSum, numbers)" that takes in a targetSum and an array of numbers as arguments\n\nThe function should return an array containing the shortest combination of numbers that add up to exactly the targetSum\n\nIf there is a tie for the shortest combination, you may return any one of the shortest\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"explanation")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Question 1: calculate the bestSum(7, [5, 3, 4, 7])\n\nPossible answer 1:\n1. [3, 4]\n2. [7]\n\nAnswer 1: [7] since the goal is to find the smallest array\n\nQuestion 2: calculate the bestSum(8, [2, 3, 5])\n\nPossible answer 2:\n1. [2, 2, 2, 2]\n2. [2, 3, 3]\n3. [3, 5]\n\nAnswer 2: [3, 5]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"graph display of what goes behind the hood for bestSum(8, ","[2, 3, 5]",") -> ","[3, 5]")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"                            8\n           /                |           \\\n         6                  5             3\n    /    |    \\         /   |   \\        / \\\n  4      3      1      3    2    0      1   0\n / \\    / \\           / \\   |\n2   1  1   0         1   0  0\n|\n0\n\nwhen leaf node value is 0, it will be our base case\nand we can return an array including the value of the parent node - child node\nin this example, at value 6, it would receive 2 possible answers:\n[2, 2, 2] or [3, 3]\nfor this problem, we are looking for the smallest array, thus we will ignore [2, 2, 2]\ntherefore, when a parent node is faced with multiple arrays that could be returned,\nwe will choose to return the array with the smallest length\n")),(0,r.kt)("h2",{id:"naive-solution"},"Naive solution"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"time complexity is ",(0,r.kt)("inlineCode",{parentName:"li"},"O((n^m) * m)"),", where targetSum is m, and numbers array.length is n"),(0,r.kt)("li",{parentName:"ul"},"space complexity is ",(0,r.kt)("inlineCode",{parentName:"li"},"O(m * m)"),", simplified to ",(0,r.kt)("inlineCode",{parentName:"li"},"O(m^2)"),", where memory is being stored for the recursion stack and the additional values stored")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const bestSum = (targetSum, numbers) => {\n  if (targetSum === 0) return [];\n  if (targetSum < 0) return null;\n  \n  let shortestCombination = null;  // space m\n  \n  for (const num of numbers) {  // time n\n    const remainder = targetSum - num;\n    const remainderCombination = bestSum(remainder, numbers);  // space m, time will follow targetSum with repeats giving n^m\n    if (remainderCombination !== null) {\n      const combination = [...remainderCombination, num];  // time m\n      if (shortestCombination === null || combination.length < shortestCombination.length) {\n        shortestCombination = combination;\n      }\n    }\n  }\n  \n  return shortestCombination;\n}\n\nconsole.log(bestSum(7, [5, 3, 4, 7]));  // [7]\nconsole.log(bestSum(8, [2, 3, 5]));  // [3, 5]\nconsole.log(bestSum(8, [1, 4, 5]));  // [4, 4]\nconsole.log(bestSum(100, [1, 2, 5, 25]));  // [25, 25, 25, 25]\n")),(0,r.kt)("h2",{id:"memoization-solution"},"Memoization solution"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"time complexity is ",(0,r.kt)("inlineCode",{parentName:"li"},"O(n * m * m)"),", simplified to ",(0,r.kt)("inlineCode",{parentName:"li"},"O(n * m^2)")),(0,r.kt)("li",{parentName:"ul"},"space complexity is ",(0,r.kt)("inlineCode",{parentName:"li"},"O(m * m)"),", simplified to ",(0,r.kt)("inlineCode",{parentName:"li"},"O(m^2)"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const bestSum = (targetSum, numbers, memo={}) => {\n  if (targetSum in memo) return memo[targetSum];\n  if (targetSum === 0) return [];\n  if (targetSum < 0) return null;\n  \n  let shortestCombination = null;  // space m\n  \n  for (const num of numbers) {  // time n\n    const remainder = targetSum - num;\n    const remainderCombination = bestSum(remainder, numbers, memo);  // space m, time will follow targetSum without repeats giving m\n    if (remainderCombination !== null) {\n      const combination = [...remainderCombination, num];  // time m\n      if (shortestCombination === null || combination.length < shortestCombination.length) {\n        shortestCombination = combination;\n      }\n    }\n  }\n  \n  memo[targetSum] = shortestCombination;\n  return shortestCombination;\n}\n\nconsole.log(bestSum(7, [5, 3, 4, 7]));  // [7]\nconsole.log(bestSum(8, [2, 3, 5]));  // [3, 5]\nconsole.log(bestSum(8, [1, 4, 5]));  // [4, 4]\nconsole.log(bestSum(100, [1, 2, 5, 25]));  // [25, 25, 25, 25]\n")),(0,r.kt)("h2",{id:"tabulation-solution"},"Tabulation solution"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bestSum(8, [2, 3, 5])\n\nm = targetSum\nn = numbers.length\n\nfirst create an array the size of the target sum + 1\n\nindex:   0     1     2     3     4     5     6     7     8\nvalue:  null  null  null  null  null  null  null  null  null\n\nwhen targetSum is at 0, no sum is required to get 0, therefore return value should be []\n\nindex:   0     1     2     3     4     5     6     7    8\nvalue:   []  null  null  null  null  null  null  null  null\n\nlook at the 1st element of the array [2, 3, 5] is 2\ncurrent index is 0 and value is []\ncurrent index 0, can return 0 by not adding\nat 2 steps ahead of the current index,\nvalue can be changed to the same as current value [] and appends the current element 2 into it\nresulting to [2]\n\nindex:   0     1     2     3     4     5     6     7    8\nvalue:   []  null   [2]  null  null  null  null  null  null\n\nlook at the 2nd element of the array [2, 3, 5] is 3\ncurrent index is 0 and value is []\ncurrent index 0, can return 0 by not adding\nat 3 steps ahead of the current index,\nvalue can be changed to the same as current value [] and appends the current element 3 into it\nresulting to [3]\n\nindex:   0     1     2     3     4     5     6     7    8\nvalue:   []  null   [2]   [3]   null  null  null  null  null\n\n\nlook at the 3rd element of the array [2, 3, 5] is 5\ncurrent index is 0 and value is []\ncurrent index 0, can return 0 by not adding\nat 5 steps ahead of the current index,\nvalue can be changed to the same as current value [] and appends the current element 5 into it\nresulting to [5]\n\nindex:   0     1     2     3     4     5     6     7    8\nvalue:   []  null   [2]   [3]   null  [5]   null  null  null\n\nmove current value to the next index\nlook at the 1st element of the array [2, 3, 5] is 2\ncurrent index is 1 and value is null\nif current value is null, nothing needs to be changed\n\nindex:   0     1     2     3     4     5     6     7    8\nvalue:   []  null   [2]   [3]   null  [5]   null  null  null\n\nlook at the 2nd element of the array [2, 3, 5] is 3\ncurrent index is 1 and value is null\nif current value is null, nothing needs to be changed\n\nindex:   0     1     2     3     4     5     6     7    8\nvalue:   []  null   [2]   [3]   null  [5]   null  null  null\n\nlook at the 3rd element of the array [2, 3, 5] is 5\ncurrent index is 1 and value is null\nif current value is null, nothing needs to be changed\n\nindex:   0     1     2     3     4     5     6     7    8\nvalue:   []  null   [2]   [3]   null  [5]   null  null  null\n\nmove current value to the next index\nlook at the 1st element of the array [2, 3, 5] is 2\ncurrent index is 2 and value is [2]\nat 2 steps ahead of the current index,\nvalue can be copied from the current value [2] and append the current element 2 into it\nresulting to [2, 2]\nnote that value at index 4 gets overwritten\n\nindex:   0     1     2     3      4      5     6     7    8\nvalue:   []  null   [2]   [3]   [2, 2]  [5]   null  null  null\n\nlook at the 2nd element of the array [2, 3, 5] is 3\ncurrent index is 2 and value is [2]\nat 3 steps ahead of the current index,\nvalue can be copied from the current value [2] and append the current element 3 into it\nresulting to [2, 3]\nhowever, since current index 2 + current element 3 giving index 5 already has a value,\nwe would need to compare index 5 value of [5] with the new data [2, 3] to see which has the smallest array\nsince the initial value at index 5 has a smaller array size, it does not get overwritten\n\nindex:   0     1     2     3      4      5     6     7    8\nvalue:   []  null   [2]   [3]   [2, 2]  [5]   null  null  null\n\nlook at the 3rd element of the array [2, 3, 5] is 5\ncurrent index is 2 and value is [2]\nat 5 steps ahead of the current index,\nvalue can be copied from the current value [2] and append the current element 5 into it\nresulting to [2, 2]\nnote that value at index 7 gets overwritten\n\nindex:   0     1     2     3      4      5     6      7      8\nvalue:   []  null   [2]   [3]   [2, 2]  [5]   null  [2, 5]  null\n\nmove current value to the next index\nlook at the 1st element of the array [2, 3, 5] is 2\ncurrent index is 3 and value is [3]\nat 2 steps ahead of the current index,\nvalue can be copied from the current value [3] and append the current element 2 into it\nresulting to [3, 2]\nhowever, since current index 3 + current element 2 giving index 5 already has a value,\nwe would need to compare index 5 value of [5] with the new data [3, 2] to see which has the smallest array\nsince the initial value at index 5 has a smaller array size, it does not get overwritten\n\nindex:   0     1     2     3      4      5     6      7      8\nvalue:   []  null   [2]   [3]   [2, 2]  [5]   null  [2, 5]  null\n\nlook at the 2nd element of the array [2, 3, 5] is 3\ncurrent index is 3 and value is [3]\nat 3 steps ahead of the current index,\nvalue can be copied from the current value [3] and append the current element 3 into it\nresulting to [3, 3]\nnote that value at index 6 gets overwritten\n\nindex:   0     1     2     3      4      5      6       7      8\nvalue:   []  null   [2]   [3]   [2, 2]  [5]   [3, 3]  [2, 5]  null\n\nlook at the 3rd element of the array [2, 3, 5] is 5\ncurrent index is 3 and value is [3]\nat 5 steps ahead of the current index,\nvalue can be copied from the current value [3] and append the current element 5 into it\nresulting to [3, 5]\nnote that value at index 8 gets overwritten\n\nindex:   0     1     2     3      4      5      6       7       8\nvalue:   []  null   [2]   [3]   [2, 2]  [5]   [3, 3]  [2, 5]  [3, 5]\n\nwe can stop here, but just for example purposes, we will continue\nwe can continue the loop till the end and it would still provide the same valid answer\n\nmove current value to the next index\nlook at the 1st element of the array [2, 3, 5] is 2\ncurrent index is 4 and value is [2, 2]\nat 2 steps ahead of the current index,\nvalue can be copied from the current value [2, 2] and append the current element 2 into it\nresulting to [2, 2, 2]\nhowever, since current index 4 + current element 2 giving index 6 already has a value,\nwe would need to compare index 6 value of [3, 3] with the new data [2, 2, 2] to see which has the smallest array\nsince the initial value at index 6 has a smaller array size, it does not get overwritten\n\nindex:   0     1     2     3      4      5      6       7       8\nvalue:   []  null   [2]   [3]   [2, 2]  [5]   [3, 3]  [2, 5]  [3, 5]\n\nlook at the 2st element of the array [2, 3, 5] is 3\ncurrent index is 4 and value is [2, 2]\nat 3 steps ahead of the current index,\nvalue can be copied from the current value [2, 2] and append the current element 3 into it\nresulting to [2, 2, 3]\nhowever, since current index 4 + current element 3 giving index 7 already has a value,\nwe would need to compare index 7 value of [2, 5] with the new data [2, 2, 3] to see which has the smallest array\nsince the initial value at index 7 has a smaller array size, it does not get overwritten\n\nindex:   0     1     2     3      4      5      6       7       8\nvalue:   []  null   [2]   [3]   [2, 2]  [5]   [3, 3]  [2, 5]  [3, 5]\n\nlook at the 3rd element of the array [5, 3, 4] is 5\ncurrent index is 4 and value is [2, 2]\nat 5 steps ahead of the current index,\nit is out of range, nothing needs to be changed\n\nindex:   0     1     2     3      4      5      6       7       8\nvalue:   []  null   [2]   [3]   [2, 2]  [5]   [3, 3]  [2, 5]  [3, 5]\n\nmove current value to the next index\nlook at the 1st element of the array [2, 3, 5] is 2\ncurrent index is 5 and value is [5]\nat 2 steps ahead of the current index,\nvalue can be copied from the current value [5, 2] and append the current element 2 into it\nresulting to [5, 2]\nhowever, since current index 5 + current element 2 giving index 7 already has a value,\nwe would need to compare index 7 value of [2, 5] with the new data [5, 2] to see which has the smallest array\nsince both has the same array size, it does not get overwritten\n\nindex:   0     1     2     3      4      5      6       7       8\nvalue:   []  null   [2]   [3]   [2, 2]  [5]   [3, 3]  [2, 5]  [3, 5]\n\nlook at the 2st element of the array [2, 3, 5] is 3\ncurrent index is 5 and value is [2, 2]\nat 3 steps ahead of the current index,\nvalue can be copied from the current value [5] and append the current element 3 into it\nresulting to [5, 3]\nhowever, since current index 5 + current element 3 giving index 8 already has a value,\nwe would need to compare index 8 value of [3, 5] with the new data [5, 3] to see which has the smallest array\nsince both has the same array size, it does not get overwritten\n\nindex:   0     1     2     3      4      5      6       7       8\nvalue:   []  null   [2]   [3]   [2, 2]  [5]   [3, 3]  [2, 5]  [3, 5]\n\nlook at the 3rd element of the array [5, 3, 4] is 5\ncurrent index is 5 and value is [5]\nat 5 steps ahead of the current index,\nit is out of range, nothing needs to be changed\n\nindex:   0     1     2     3      4      5      6       7       8\nvalue:   []  null   [2]   [3]   [2, 2]  [5]   [3, 3]  [2, 5]  [3, 5]\n\nmove current value to the next index\nlook at the 1st element of the array [2, 3, 5] is 2\ncurrent index is 6 and value is [3, 3]\nat 2 steps ahead of the current index,\nvalue can be copied from the current value [3, 3] and append the current element 2 into it\nresulting to [3, 3, 2]\nhowever, since current index 6 + current element 2 giving index 8 already has a value,\nwe would need to compare index 8 value of [3, 5] with the new data [3, 3, 2] to see which has the smallest array\nsince the initial value at index 8 has a smaller array size, it does not get overwritten\n\nindex:   0     1     2     3      4      5      6       7       8\nvalue:   []  null   [2]   [3]   [2, 2]  [5]   [3, 3]  [2, 5]  [3, 5]\n\nthe rest are out of range, thus nothing needs to be changed\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"time complexity is ",(0,r.kt)("inlineCode",{parentName:"li"},"O(n * m^2)")),(0,r.kt)("li",{parentName:"ul"},"space complexity is ",(0,r.kt)("inlineCode",{parentName:"li"},"O(m^2)"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const bestSum = (targetSum, numbers) => {\n  const table = Array(targetSum + 1).fill(null);\n  table[0] = [];\n  \n  for (let i=0; i<=targetSum; i++) {\n    if (table[i] !== null) {\n      for (const num of numbers) {\n        const combination = [...table[i], num];\n        if (!table[i + num] || table[i + num].length > combination.length) {\n          table[i + num] = combination;\n        }\n      }\n    }\n  }\n  return table[targetSum];\n}\n\nconsole.log(bestSum(7, [5, 3, 4, 7]));  // [7]\nconsole.log(bestSum(8, [2, 3, 5]));  // [3, 5]\nconsole.log(bestSum(8, [1, 4, 5]));  // [4, 4]\nconsole.log(bestSum(100, [1, 2, 5, 25]));  // [25, 25, 25, 25]\n")))}d.isMDXComponent=!0}}]);