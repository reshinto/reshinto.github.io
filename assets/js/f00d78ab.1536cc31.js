"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[4587],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var r=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n,r,s={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,s=e.mdxType,a=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=c(n),g=s,y=u["".concat(l,".").concat(g)]||u[g]||h[g]||a;return n?r.createElement(y,i(i({ref:t},d),{},{components:n})):r.createElement(y,i({ref:t},d))}));function g(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var a=n.length,i=new Array(a);i[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},19650:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var r=n(83117),s=(n(67294),n(3905));const a={},i="C++ Example",o={unversionedId:"interviewPrep/designPatterns/Structural_patterns/Flyweight/cPlusPlus/readme",id:"interviewPrep/designPatterns/Structural_patterns/Flyweight/cPlusPlus/readme",title:"C++ Example",description:"",source:"@site/docs/interviewPrep/designPatterns/Structural_patterns/Flyweight/cPlusPlus/readme.md",sourceDirName:"interviewPrep/designPatterns/Structural_patterns/Flyweight/cPlusPlus",slug:"/interviewPrep/designPatterns/Structural_patterns/Flyweight/cPlusPlus/",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Flyweight/cPlusPlus/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Structural_patterns/Flyweight/cPlusPlus/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Flyweight",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Flyweight/"},next:{title:"C# Example",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Flyweight/cSharp/"}},l={},c=[],d={toc:c};function h(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"c-example"},"C++ Example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n\n/**\n * Flyweight Design Pattern\n *\n * Intent: Lets you fit more objects into the available amount of RAM by sharing\n * common parts of state between multiple objects, instead of keeping all of the\n * data in each object.\n */\n\nstruct SharedState\n{\n    std::string brand_;\n    std::string model_;\n    std::string color_;\n\n    SharedState(const std::string &brand, const std::string &model, const std::string &color)\n        : brand_(brand), model_(model), color_(color)\n    {\n    }\n\n    friend std::ostream &operator<<(std::ostream &os, const SharedState &ss)\n    {\n        return os << "[ " << ss.brand_ << " , " << ss.model_ << " , " << ss.color_ << " ]";\n    }\n};\n\nstruct UniqueState\n{\n    std::string owner_;\n    std::string plates_;\n\n    UniqueState(const std::string &owner, const std::string &plates)\n        : owner_(owner), plates_(plates)\n    {\n    }\n\n    friend std::ostream &operator<<(std::ostream &os, const UniqueState &us)\n    {\n        return os << "[ " << us.owner_ << " , " << us.plates_ << " ]";\n    }\n};\n\n/**\n * The Flyweight stores a common portion of the state (also called intrinsic\n * state) that belongs to multiple real business entities. The Flyweight accepts\n * the rest of the state (extrinsic state, unique for each entity) via its\n * method parameters.\n */\nclass Flyweight\n{\nprivate:\n    SharedState *shared_state_;\n\npublic:\n    Flyweight(const SharedState *shared_state) : shared_state_(new SharedState(*shared_state))\n    {\n    }\n    Flyweight(const Flyweight &other) : shared_state_(new SharedState(*other.shared_state_))\n    {\n    }\n    ~Flyweight()\n    {\n        delete shared_state_;\n    }\n    SharedState *shared_state() const\n    {\n        return shared_state_;\n    }\n    void Operation(const UniqueState &unique_state) const\n    {\n        std::cout << "Flyweight: Displaying shared (" << *shared_state_ << ") and unique (" << unique_state << ") state.\\n";\n    }\n};\n/**\n * The Flyweight Factory creates and manages the Flyweight objects. It ensures\n * that flyweights are shared correctly. When the client requests a flyweight,\n * the factory either returns an existing instance or creates a new one, if it\n * doesn\'t exist yet.\n */\nclass FlyweightFactory\n{\n    /**\n     * @var Flyweight[]\n     */\nprivate:\n    std::unordered_map<std::string, Flyweight> flyweights_;\n    /**\n     * Returns a Flyweight\'s string hash for a given state.\n     */\n    std::string GetKey(const SharedState &ss) const\n    {\n        return ss.brand_ + "_" + ss.model_ + "_" + ss.color_;\n    }\n\npublic:\n    FlyweightFactory(std::initializer_list<SharedState> share_states)\n    {\n        for (const SharedState &ss : share_states)\n        {\n            this->flyweights_.insert(std::make_pair<std::string, Flyweight>(this->GetKey(ss), Flyweight(&ss)));\n        }\n    }\n\n    /**\n     * Returns an existing Flyweight with a given state or creates a new one.\n     */\n    Flyweight GetFlyweight(const SharedState &shared_state)\n    {\n        std::string key = this->GetKey(shared_state);\n        if (this->flyweights_.find(key) == this->flyweights_.end())\n        {\n            std::cout << "FlyweightFactory: Can\'t find a flyweight, creating new one.\\n";\n            this->flyweights_.insert(std::make_pair(key, Flyweight(&shared_state)));\n        }\n        else\n        {\n            std::cout << "FlyweightFactory: Reusing existing flyweight.\\n";\n        }\n        return this->flyweights_.at(key);\n    }\n    void ListFlyweights() const\n    {\n        size_t count = this->flyweights_.size();\n        std::cout << "\\nFlyweightFactory: I have " << count << " flyweights:\\n";\n        for (std::pair<std::string, Flyweight> pair : this->flyweights_)\n        {\n            std::cout << pair.first << "\\n";\n        }\n    }\n};\n\n// ...\nvoid AddCarToPoliceDatabase(\n    FlyweightFactory &ff, const std::string &plates, const std::string &owner,\n    const std::string &brand, const std::string &model, const std::string &color)\n{\n    std::cout << "\\nClient: Adding a car to database.\\n";\n    const Flyweight &flyweight = ff.GetFlyweight({brand, model, color});\n    // The client code either stores or calculates extrinsic state and passes it\n    // to the flyweight\'s methods.\n    flyweight.Operation({owner, plates});\n}\n\n/**\n * The client code usually creates a bunch of pre-populated flyweights in the\n * initialization stage of the application.\n */\n\nint main()\n{\n    FlyweightFactory *factory = new FlyweightFactory({{"Chevrolet", "Camaro2018", "pink"}, {"Mercedes Benz", "C300", "black"}, {"Mercedes Benz", "C500", "red"}, {"BMW", "M5", "red"}, {"BMW", "X6", "white"}});\n    factory->ListFlyweights();\n\n    AddCarToPoliceDatabase(*factory,\n                            "CL234IR",\n                            "James Doe",\n                            "BMW",\n                            "M5",\n                            "red");\n\n    AddCarToPoliceDatabase(*factory,\n                            "CL234IR",\n                            "James Doe",\n                            "BMW",\n                            "X1",\n                            "red");\n    factory->ListFlyweights();\n    delete factory;\n\n    return 0;\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"FlyweightFactory: I have 5 flyweights:\nBMW_X6_white\nMercedes Benz_C500_red\nMercedes Benz_C300_black\nBMW_M5_red\nChevrolet_Camaro2018_pink\n\nClient: Adding a car to database.\nFlyweightFactory: Reusing existing flyweight.\nFlyweight: Displaying shared ([ BMW , M5 , red ]) and unique ([ CL234IR , James Doe ]) state.\n\nClient: Adding a car to database.\nFlyweightFactory: Can't find a flyweight, creating new one.\nFlyweight: Displaying shared ([ BMW , X1 , red ]) and unique ([ CL234IR , James Doe ]) state.\n\nFlyweightFactory: I have 6 flyweights:\nBMW_X1_red\nMercedes Benz_C300_black\nBMW_X6_white\nMercedes Benz_C500_red\nBMW_M5_red\nChevrolet_Camaro2018_pink\n")))}h.isMDXComponent=!0}}]);