"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[40651],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||r;return n?i.createElement(h,o(o({ref:t},p),{},{components:n})):i.createElement(h,o({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},12786:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var i=n(83117),a=(n(67294),n(3905));const r={},o="Composition",s={unversionedId:"interviewPrep/basics/programmingParadigm/OOP/composition",id:"interviewPrep/basics/programmingParadigm/OOP/composition",title:"Composition",description:"- it is one of the fundamental concepts in object-oriented programming",source:"@site/docs/interviewPrep/basics/programmingParadigm/OOP/composition.md",sourceDirName:"interviewPrep/basics/programmingParadigm/OOP",slug:"/interviewPrep/basics/programmingParadigm/OOP/composition",permalink:"/docs/interviewPrep/basics/programmingParadigm/OOP/composition",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/basics/programmingParadigm/OOP/composition.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Object-oriented Design",permalink:"/docs/interviewPrep/basics/programmingParadigm/OOP/OOD"},next:{title:"Design by Contract (DbC)",permalink:"/docs/interviewPrep/basics/programmingParadigm/OOP/designByContract"}},l={},c=[{value:"Composition vs Inheritance",id:"composition-vs-inheritance",level:2},{value:"Moving from Inheritance to Composition",id:"moving-from-inheritance-to-composition",level:2},{value:"Accepting the Consequences of Inheritance",id:"accepting-the-consequences-of-inheritance",level:2},{value:"Benefits of Inheritance",id:"benefits-of-inheritance",level:3},{value:"Cons of Inheritance",id:"cons-of-inheritance",level:3},{value:"Accepting the Consequences of Composition",id:"accepting-the-consequences-of-composition",level:2},{value:"Benefits of Composition",id:"benefits-of-composition",level:3},{value:"Cons of Composition",id:"cons-of-composition",level:3}],p={toc:c};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"composition"},"Composition"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"it is one of the fundamental concepts in object-oriented programming"),(0,a.kt)("li",{parentName:"ul"},"It describes a class that references one or more objects of other classes in instance variables"),(0,a.kt)("li",{parentName:"ul"},"This allows the modeling of a ",(0,a.kt)("inlineCode",{parentName:"li"},"HAS-A association")," between objects")),(0,a.kt)("h2",{id:"composition-vs-inheritance"},"Composition vs Inheritance"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Composition uses different relation type"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"inheritance models strong ",(0,a.kt)("inlineCode",{parentName:"li"},"IS-A relation")," between classes, it means that mountain bike is-a bicycle"),(0,a.kt)("li",{parentName:"ul"},"composition models weaker ",(0,a.kt)("inlineCode",{parentName:"li"},"HAS-A relation"),", mountain bike has-a wheel"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"inheritance example"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"problem:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"if need continuously extend existing functionality, will notice that spare parts functionality may not change all the time"),(0,a.kt)("li",{parentName:"ul"},"or will require adjustments because of specific implementations of different subclasses"),(0,a.kt)("li",{parentName:"ul"},"it becomes too difficult to extend spare parts functionality",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"composition will help solve this problem")))))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'abstract class Bicycle {\n  protected readonly defaultChain = "11-speed";\n\n  constructor(opts) {\n    this.style = opts.style;\n    this.chain = opts.chain || this.defaultChain;\n    this.tireSize = opts.tireSize || this.defaultTireSize;\n  }\n\n  spares() {\n    return {\n      chain: this.chain,\n      tireSize: this.tireSize,\n    };\n  }\n}\n\nclass RoadBike extends Bicycle {\n  protected readonly defaultTireSize = "28";\n\n  constructor(opts) {\n    super(opts);\n\n    this.tapeColor = opts.tapeColor;\n  }\n\n  spares() {\n    return {\n      ...super.spares(),\n      tapeColor: this.tapeColor,\n    };\n  }\n\n  protected get defaultChain() {\n    return "2-speed";\n  }\n}\n\nclass MountainBike extends Bicycle {\n  protected readonly defaultTireSize = "29";\n\n  constructor(opts) {\n    super(opts);\n\n    this.frontShock = opts.frontShock;\n  }\n\n  spares() {\n    return {\n      ...super.spares(),\n      frontShock: this.frontShock,\n    };\n  }\n}\n')))),(0,a.kt)("h2",{id:"moving-from-inheritance-to-composition"},"Moving from Inheritance to Composition"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"by moving spare parts to ",(0,a.kt)("inlineCode",{parentName:"li"},"Parts")," class, inheritance will be replaced with composition",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"now we have ",(0,a.kt)("inlineCode",{parentName:"li"},"Parts")," class with all the spare functionality encapsulated inside it"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Bicycle")," type depends on provided parts"),(0,a.kt)("li",{parentName:"ul"},"when spares method is called inside Bicycle, it is delegated to Parts instance, and it decides which exact parts to return")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'class Bicycle {\n  constructor(private size: string, private parts: Parts) {}\n\n  spares() {\n    return this.parts.spares();\n  }\n}\n\nclass Parts {\n  constructor(private parts: Part[]) {}\n\n  spares() {\n    return this.parts\n      .filter(({needsSpare}) => needsSpare)\n      .reduce((spares, {name, value}) => ({\n        ...spares,\n        [name]: value,\n      }));\n  }\n}\n\nclass Part {\n  constructor(\n    public name: string,\n    public value: string,\n    public needsSpare = true\n  ) {}\n}\n\nconst roadBike = new Bicycle(\n  "M",\n  new Parts([\n    new Part("chain", "11-speed"),\n    new Part("tireSize", "28"),\n    new Part("tapeColor", "red"),\n  ])\n);\nconst mountainBike = new Bicycle(\n  "L",\n  new Parts([\n    new Part("chain", "11-speed"),\n    new Part("tireSize", "29"),\n    new Part("readShock", "fox", false),\n    new Part("frontShock", "manitou"),\n  ])\n);\n')),(0,a.kt)("h2",{id:"accepting-the-consequences-of-inheritance"},"Accepting the Consequences of Inheritance"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Inheritance is best suited to adding functionally to existing classes when you will use most of the old code and add relatively small amounts of new code")),(0,a.kt)("h3",{id:"benefits-of-inheritance"},"Benefits of Inheritance"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use of inheritance results in code that can be described as ",(0,a.kt)("inlineCode",{parentName:"li"},"open-closed principle"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"hierarchies are open for extension while remaining closed for modification"),(0,a.kt)("li",{parentName:"ul"},"allows you to easily extend the class behaviour without modifying existing code, this is pretty safe way to get the needed result"),(0,a.kt)("li",{parentName:"ul"},"when the encapsulation is not violated and classes are inherited in a correct way OCP will not be violated"))),(0,a.kt)("li",{parentName:"ul"},"Correctly written hierarchies are easy to extend",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The hierarchy embodies the abstraction and every new subclass plugs in a few concrete differences"),(0,a.kt)("li",{parentName:"ul"},"The existing pattern is easy to follow and replicate"),(0,a.kt)("li",{parentName:"ul"},"Hierarchies by their nature provide guidance for writing the code to extend them"))),(0,a.kt)("li",{parentName:"ul"},"Use Inheritance for ",(0,a.kt)("inlineCode",{parentName:"li"},"IS-A Relationships"))),(0,a.kt)("h3",{id:"cons-of-inheritance"},"Cons of Inheritance"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Choosing inheritance to solve the wrong kind of problem"),(0,a.kt)("li",{parentName:"ul"},"High cost of making changes near the top of an incorrectly modeled hierarchy",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"In this case, the leveraging effect works to your disadvantage; small changes break everything"))),(0,a.kt)("li",{parentName:"ul"},"Impossibility of adding behavior when new subclasses represent a mixture of types")),(0,a.kt)("h2",{id:"accepting-the-consequences-of-composition"},"Accepting the Consequences of Composition"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use composition when the behavior is more than the sum of its parts")),(0,a.kt)("h3",{id:"benefits-of-composition"},"Benefits of Composition"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"When using composition, the natural tendency is to create many small objects that contain straightforward responsibilities that are accessible through clearly defined interfaces",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Interfaces need to be used when some part depends on (composes) other part, so it also helps to develop the new functionality"))),(0,a.kt)("li",{parentName:"ul"},"These small objects have a ",(0,a.kt)("inlineCode",{parentName:"li"},"single responsibility principle")," and specify their own behavior",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"They are transparent"),(0,a.kt)("li",{parentName:"ul"},"it is easy to understand the code, and it is clear what will happen if it changes"))),(0,a.kt)("li",{parentName:"ul"},"Because composed objects deal with their parts via an interface, adding a new kind of part is a simple matter of plugging in a new object that honors the interface"),(0,a.kt)("li",{parentName:"ul"},"Use Composition for has-a Relationships")),(0,a.kt)("h3",{id:"cons-of-composition"},"Cons of Composition"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A composed object relies on its many parts",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Even if each part is small and easily understood, the combined operation of the whole may be less than obvious"))),(0,a.kt)("li",{parentName:"ul"},"The benefits of structural independence are gained at the cost of automatic message delegation",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The composed object must explicitly know which messages to delegate and to whom"))),(0,a.kt)("li",{parentName:"ul"},"As these costs and benefits illustrate, composition is excellent at prescribing rules for assembling an object made of parts but does not provide as much help for the problem of arranging code for a collection of parts that are very nearly identical")))}m.isMDXComponent=!0}}]);