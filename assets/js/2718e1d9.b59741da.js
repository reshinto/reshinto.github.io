"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[9322],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(t),m=a,y=d["".concat(s,".").concat(m)]||d[m]||p[m]||i;return t?r.createElement(y,o(o({ref:n},u),{},{components:t})):r.createElement(y,o({ref:n},u))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=t[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},63388:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=t(87462),a=(t(67294),t(3905));const i={},o="TypeScript",l={unversionedId:"languageSpecific/javascript/typescript",id:"languageSpecific/javascript/typescript",title:"TypeScript",description:"- it is an object-oriented, strongly typed language which is a superset of JavaScript",source:"@site/docs/languageSpecific/javascript/typescript.md",sourceDirName:"languageSpecific/javascript",slug:"/languageSpecific/javascript/typescript",permalink:"/docs/languageSpecific/javascript/typescript",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/languageSpecific/javascript/typescript.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Reduce method",permalink:"/docs/languageSpecific/javascript/reduce"},next:{title:"Python",permalink:"/docs/languageSpecific/python/"}},s={},c=[{value:"Installation",id:"installation",level:2},{value:"Run",id:"run",level:3},{value:"Syntax",id:"syntax",level:2},{value:"Basic Types",id:"basic-types",level:3},{value:"union",id:"union",level:3},{value:"enum",id:"enum",level:3},{value:"Objects",id:"objects",level:3},{value:"Type Assertion",id:"type-assertion",level:3},{value:"Functions",id:"functions",level:3},{value:"Interface",id:"interface",level:3},{value:"Classes",id:"classes",level:3},{value:"Generics",id:"generics",level:3},{value:"Overriding Type or Interface",id:"overriding-type-or-interface",level:3}],u={toc:c};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"typescript"},"TypeScript"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"it is an object-oriented, strongly typed language which is a superset of JavaScript"),(0,a.kt)("li",{parentName:"ul"},"it converts code to JavaScript",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"which can be executed anywhere that is JavaScript supported",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"browser, Nodejs, etc."))))),(0,a.kt)("li",{parentName:"ul"},"developed by Microsoft"),(0,a.kt)("li",{parentName:"ul"},"it adds new capabilities to the language",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Most notable addition are static type definitions",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Thanks to types, it's possible, for example, to declare what kind of arguments we are expecting and what is returned exactly in our functions or what's the exact shape of the object that we are creating"))),(0,a.kt)("li",{parentName:"ul"},"It makes our code more secure and robust by preventing a lot of bugs before code is even shipped"),(0,a.kt)("li",{parentName:"ul"},"it catches problems during writing the code"))),(0,a.kt)("li",{parentName:"ul"},"TypeScript offers a whole lot of other great mechanisms like interfaces, classes, utility types and so on",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"on bigger projects you can declare your TypeScript compiler configuration in a separate file and granularly adjust how it works, how strict it is and where it stores compiled files")))),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"npm i -D typescript")),(0,a.kt)("h3",{id:"run"},"Run"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"npx tsc example.ts")),(0,a.kt)("h2",{id:"syntax"},"Syntax"),(0,a.kt)("h3",{id:"basic-types"},"Basic Types"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'let id: number = 5; // not required to define type\nlet id = 5; // this already defines the type\n\nlet company: string = "test";\nlet isPublished: boolean = true;\nlet x: any = "hello"; // try not to use the any keyword\n\nlet ids: number[] = [1, 2, 3, 4];\nlet arr: any[] = [1, true, "hello"]; // type format can be anything\nlet person: [number, string, boolean] = [1, "Brad", true]; // must follow type format and order\n\ntype Point = string | number; // works for type but not interface\nconst p1: Point = 1;\n\n// works for both type and interface\ntype Point2 = {\n  id: number;\n  x: number;\n};\nconst p2: Point2 = {\n  id: 1,\n  x: 2,\n};\n\n// dynamic property types, use when you don\'t know all the property names\ntype UnknownObject = {\n  [k: string]: string;\n};\n')),(0,a.kt)("h3",{id:"union"},"union"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"let employee: (string | number)[]; // allow strings and/or numbers in array\n")),(0,a.kt)("h3",{id:"enum"},"enum"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'// value starts from 0 by default\nenum Direction1 {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n\nconsole.log(Direction1.Up); // 0 by default\n\n// set value to start from 1\nenum Direction2 {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n}\n\nconsole.log(Direction2.Left); // 3\n\nenum Direction3 {\n  Up = "Up",\n  Down = "Down",\n  Left = "Left",\n  Right = "Right",\n}\n')),(0,a.kt)("h3",{id:"objects"},"Objects"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'// method 1\nconst user1: {\n  id: number;\n  name: string;\n} = {\n  id: 1,\n  number: "John",\n};\n\n// method 2\ntype User = {\n  id: number;\n  name: string;\n};\n\nconst user2: User = {\n  id: 1,\n  number: "John",\n};\n\n// method 3\ninterface User2 {\n  id: number;\n  name: string;\n}\n\nconst user3: User2 = {\n  id: 1,\n  number: "John",\n};\n')),(0,a.kt)("h3",{id:"type-assertion"},"Type Assertion"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// method 1\nlet id: any = 1;\nlet customerId = <number>id;\n\n// method 2\nlet id2: any = 1;\nlet customerId2 = id as number;\n")),(0,a.kt)("h3",{id:"functions"},"Functions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function addNum(x: number, y: number): number {\n  return x + y;\n}\n\nfunction log(msg: string | number): void {\n  console.log(msg);\n}\n")),(0,a.kt)("h3",{id:"interface"},"Interface"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"can't be used with primitives or unions")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface Point {\n  readonly id: number; // disable value modification, also works for type keyword\n  y: number;\n  x?: number; // ? enables it to be optional, also works for type keyword\n  (x: number, y: number): number;\n}\n\nlet p2: Point = {\n  id: 1,\n  y: 2,\n};\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"functions")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface Add {\n  (x: number, y: number): number;\n}\n\nconst add: Add = (x: number, y: number): number => x + y;\n")),(0,a.kt)("h3",{id:"classes"},"Classes"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// method 1\nclass Node1 {\n  // adding of access modifiers is needed; does not work for javascript\n  constructor(public element: number, private next?: Node1) {}\n\n  getNext() {\n    return this.next;\n  }\n}\n\nconst n1 = new Node1(1);\nconsole.log(n1.element); // 1\n\n// method 2\nclass Node2 {\n  // not required in javascript\n  public element: number;\n  private next?: Node2;\n\n  constructor(element: number, next?: Node2) {\n    this.element = element;\n    this.next = next;\n  }\n\n  getNext() {\n    return this.next;\n  }\n}\nconst n2 = new Node2(2);\nconsole.log(n2.element); // 2\n\n// method 3\ninterface NodeInterface {\n  element: number;\n  // private next is not required\n  getNext(): NodeInterface | undefined;\n}\n\nclass Node3 implements NodeInterface {\n  constructor(public element: number, private next?: NodeInterface) {}\n\n  getNext() {\n    return this.next;\n  }\n}\n\nconst n3 = new Node4(3);\nconsole.log(n3.element); // 3\n\n// method 4\nclass Node4<T> {\n  public element: T;\n  private next?: Node2<T>;\n\n  constructor(element: T, next?: Node2<T>) {\n    this.element = element;\n    this.next = next;\n  }\n\n  getElement() {\n    return this.element;\n  }\n}\n\nconst n4 = new Node4(4);\nconsole.log(n4.element); // 4\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Inheritance")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class Node3 {\n  constructor(public element: number, private next?: Node3) {}\n\n  getNext() {\n    return this.next;\n  }\n}\n\nclass List extends Node3 {\n  dsType: string;\n\n  constructor(dsType: string, element: number, next?: Node3) {\n    super(element, next);\n    this.dsType = dsType;\n  }\n}\n")),(0,a.kt)("h3",{id:"generics"},"Generics"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// method 1\nfunction getArray(items: any[]): any[] {\n  return new Array().concat(items);\n}\n\nlet numArr = getArray([1, 2, 3]);\n\n// method 2: better method\nfunction getArray2<T>(items: T[]): T[] {\n  return new Array().concat(items);\n}\n\n// both works\nlet numArr2 = getArray2([1, 2, 3]);\nlet numArr3 = getArray2<number>([1, 2, 3]);\n")),(0,a.kt)("h3",{id:"overriding-type-or-interface"},"Overriding Type or Interface"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'// can be either interface or type\ninterface A {\n  x: string;\n  y: number;\n  z: string;\n}\n\nconst obj: A = {\n  x: "1",\n  y: 2,\n  z: "3",\n};\n\n// method 1: using interface method, A can be either type or interface\ninterface B extends Omit<A, "x" | "z"> {\n  x: number;\n  z: number;\n}\n\nconst obj2: B = {\n  x: 1,\n  y: 2,\n  z: 3,\n};\n\n// method 2: using type method, A can be either type or interface\ntype C = Omit<A, "x" | "z"> & {\n  x: number;\n  z: number;\n};\n\nconst obj3: C = {\n  x: 1,\n  y: 2,\n  z: 3,\n};\n')))}p.isMDXComponent=!0}}]);