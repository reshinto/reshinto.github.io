"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[66342],{3905:(e,n,t)=>{t.d(n,{Zo:()=>a,kt:()=>d});var o=t(67294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,s=function(e,n){if(null==e)return{};var t,o,s={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var p=o.createContext({}),_=function(e){var n=o.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},a=function(e){var n=_(e.components);return o.createElement(p.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,s=e.mdxType,r=e.originalType,p=e.parentName,a=i(e,["components","mdxType","originalType","parentName"]),m=_(t),d=s,f=m["".concat(p,".").concat(d)]||m[d]||l[d]||r;return t?o.createElement(f,c(c({ref:n},a),{},{components:t})):o.createElement(f,c({ref:n},a))}));function d(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=t.length,c=new Array(r);c[0]=m;var i={};for(var p in n)hasOwnProperty.call(n,p)&&(i[p]=n[p]);i.originalType=e,i.mdxType="string"==typeof e?e:s,c[1]=i;for(var _=2;_<r;_++)c[_]=t[_];return o.createElement.apply(null,c)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},56159:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>c,default:()=>l,frontMatter:()=>r,metadata:()=>i,toc:()=>_});var o=t(83117),s=(t(67294),t(3905));const r={},c="Python Example",i={unversionedId:"interviewPrep/designPatterns/Creational_patterns/Prototype/python/readme",id:"interviewPrep/designPatterns/Creational_patterns/Prototype/python/readme",title:"Python Example",description:"",source:"@site/docs/interviewPrep/designPatterns/Creational_patterns/Prototype/python/readme.md",sourceDirName:"interviewPrep/designPatterns/Creational_patterns/Prototype/python",slug:"/interviewPrep/designPatterns/Creational_patterns/Prototype/python/",permalink:"/docs/interviewPrep/designPatterns/Creational_patterns/Prototype/python/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Creational_patterns/Prototype/python/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"JavaScript",permalink:"/docs/interviewPrep/designPatterns/Creational_patterns/Prototype/javascript/"},next:{title:"Example 2",permalink:"/docs/interviewPrep/designPatterns/Creational_patterns/Prototype/python/example2"}},p={},_=[],a={toc:_};function l(e){let{components:n,...t}=e;return(0,s.kt)("wrapper",(0,o.Z)({},a,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"python-example"},"Python Example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},'import copy\n\n\nclass SelfReferencingEntity:\n    def __init__(self):\n        self.parent = None\n\n    def set_parent(self, parent):\n        self.parent = parent\n\n\nclass SomeComponent:\n    """\n    Python provides its own interface of Prototype via `copy.copy` and\n    `copy.deepcopy` functions. And any class that wants to implement custom\n    implementations have to override `__copy__` and `__deepcopy__` member\n    functions.\n    """\n\n    def __init__(self, some_int, some_list_of_objects, some_circular_ref):\n        self.some_int = some_int\n        self.some_list_of_objects = some_list_of_objects\n        self.some_circular_ref = some_circular_ref\n\n    def __copy__(self):\n        """\n        Create a shallow copy. This method will be called whenever someone calls\n        `copy.copy` with this object and the returned value is returned as the\n        new shallow copy.\n        """\n\n        # First, let\'s create copies of the nested objects.\n        some_list_of_objects = copy.copy(self.some_list_of_objects)\n        some_circular_ref = copy.copy(self.some_circular_ref)\n\n        # Then, let\'s clone the object itself, using the prepared clones of the\n        # nested objects.\n        new = self.__class__(\n            self.some_int, some_list_of_objects, some_circular_ref\n        )\n        new.__dict__.update(self.__dict__)\n\n        return new\n\n    def __deepcopy__(self, memo={}):\n        """\n        Create a deep copy. This method will be called whenever someone calls\n        `copy.deepcopy` with this object and the returned value is returned as\n        the new deep copy.\n\n        What is the use of the argument `memo`? Memo is the dictionary that is\n        used by the `deepcopy` library to prevent infinite recursive copies in\n        instances of circular references. Pass it to all the `deepcopy` calls\n        you make in the `__deepcopy__` implementation to prevent infinite\n        recursions.\n        """\n\n        # First, let\'s create copies of the nested objects.\n        some_list_of_objects = copy.deepcopy(self.some_list_of_objects, memo)\n        some_circular_ref = copy.deepcopy(self.some_circular_ref, memo)\n\n        # Then, let\'s clone the object itself, using the prepared clones of the\n        # nested objects.\n        new = self.__class__(\n            self.some_int, some_list_of_objects, some_circular_ref\n        )\n        new.__dict__ = copy.deepcopy(self.__dict__, memo)\n\n        return new\n\n\nif __name__ == "__main__":\n\n    list_of_objects = [1, {1, 2, 3}, [1, 2, 3]]\n    circular_ref = SelfReferencingEntity()\n    component = SomeComponent(23, list_of_objects, circular_ref)\n    circular_ref.set_parent(component)\n\n    shallow_copied_component = copy.copy(component)\n\n    # Let\'s change the list in shallow_copied_component and see if it changes in\n    # component.\n    shallow_copied_component.some_list_of_objects.append("another object")\n    if component.some_list_of_objects[-1] == "another object":\n        print(\n            "Adding elements to `shallow_copied_component`\'s "\n            "some_list_of_objects adds it to `component`\'s "\n            "some_list_of_objects."\n        )\n    else:\n        print(\n            "Adding elements to `shallow_copied_component`\'s "\n            "some_list_of_objects doesn\'t add it to `component`\'s "\n            "some_list_of_objects."\n        )\n\n    # Let\'s change the set in the list of objects.\n    component.some_list_of_objects[1].add(4)\n    if 4 in shallow_copied_component.some_list_of_objects[1]:\n        print(\n            "Changing objects in the `component`\'s some_list_of_objects "\n            "changes that object in `shallow_copied_component`\'s "\n            "some_list_of_objects."\n        )\n    else:\n        print(\n            "Changing objects in the `component`\'s some_list_of_objects "\n            "doesn\'t change that object in `shallow_copied_component`\'s "\n            "some_list_of_objects."\n        )\n\n    deep_copied_component = copy.deepcopy(component)\n\n    # Let\'s change the list in deep_copied_component and see if it changes in\n    # component.\n    deep_copied_component.some_list_of_objects.append("one more object")\n    if component.some_list_of_objects[-1] == "one more object":\n        print(\n            "Adding elements to `deep_copied_component`\'s "\n            "some_list_of_objects adds it to `component`\'s "\n            "some_list_of_objects."\n        )\n    else:\n        print(\n            "Adding elements to `deep_copied_component`\'s "\n            "some_list_of_objects doesn\'t add it to `component`\'s "\n            "some_list_of_objects."\n        )\n\n    # Let\'s change the set in the list of objects.\n    component.some_list_of_objects[1].add(10)\n    if 10 in deep_copied_component.some_list_of_objects[1]:\n        print(\n            "Changing objects in the `component`\'s some_list_of_objects "\n            "changes that object in `deep_copied_component`\'s "\n            "some_list_of_objects."\n        )\n    else:\n        print(\n            "Changing objects in the `component`\'s some_list_of_objects "\n            "doesn\'t change that object in `deep_copied_component`\'s "\n            "some_list_of_objects."\n        )\n\n    print(\n        f"id(deep_copied_component.some_circular_ref.parent): "\n        f"{id(deep_copied_component.some_circular_ref.parent)}"\n    )\n    print(\n        f"id(deep_copied_component.some_circular_ref.parent.some_circular_ref.parent): "\n        f"{id(deep_copied_component.some_circular_ref.parent.some_circular_ref.parent)}"\n    )\n    print(\n        "^^ This shows that deepcopied objects contain same reference, they "\n        "are not cloned repeatedly."\n    )\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Adding elements to `shallow_copied_component`'s some_list_of_objects adds it to `component`'s some_list_of_objects.\nChanging objects in the `component`'s some_list_of_objects changes that object in `shallow_copied_component`'s some_list_of_objects.\nAdding elements to `deep_copied_component`'s some_list_of_objects doesn't add it to `component`'s some_list_of_objects.\nChanging objects in the `component`'s some_list_of_objects doesn't change that object in `deep_copied_component`'s some_list_of_objects.\nid(deep_copied_component.some_circular_ref.parent): 4429472784\nid(deep_copied_component.some_circular_ref.parent.some_circular_ref.parent): 4429472784\n^^ This shows that deepcopied objects contain same reference, they are not cloned repeatedly.\n")))}l.isMDXComponent=!0}}]);