"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[1246],{3905:(e,n,r)=>{r.d(n,{Zo:()=>c,kt:()=>v});var t=r(67294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function l(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?l(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):l(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},l=Object.keys(e);for(t=0;t<l.length;t++)r=l[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)r=l[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var a=t.createContext({}),u=function(e){var n=t.useContext(a),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},c=function(e){var n=u(e.components);return t.createElement(a.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,l=e.originalType,a=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=u(r),v=i,g=h["".concat(a,".").concat(v)]||h[v]||p[v]||l;return r?t.createElement(g,o(o({ref:n},c),{},{components:r})):t.createElement(g,o({ref:n},c))}));function v(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=r.length,o=new Array(l);o[0]=h;var s={};for(var a in n)hasOwnProperty.call(n,a)&&(s[a]=n[a]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var u=2;u<l;u++)o[u]=r[u];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}h.displayName="MDXCreateElement"},26521:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>u});var t=r(83117),i=(r(67294),r(3905));const l={},o="Recursion with strings",s={unversionedId:"interviewPrep/algorithms_and_techniques/recursion/reverseString",id:"interviewPrep/algorithms_and_techniques/recursion/reverseString",title:"Recursion with strings",description:"- before working on the recursion, need to think about the following",source:"@site/docs/interviewPrep/algorithms_and_techniques/recursion/reverseString.md",sourceDirName:"interviewPrep/algorithms_and_techniques/recursion",slug:"/interviewPrep/algorithms_and_techniques/recursion/reverseString",permalink:"/docs/interviewPrep/algorithms_and_techniques/recursion/reverseString",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/algorithms_and_techniques/recursion/reverseString.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Reverse Linked List",permalink:"/docs/interviewPrep/algorithms_and_techniques/recursion/reverseLinkedList"},next:{title:"Sum of natural numbers",permalink:"/docs/interviewPrep/algorithms_and_techniques/recursion/sumOfNaturalNumbers"}},a={},u=[{value:"Iterative solution",id:"iterative-solution",level:3}],c={toc:u};function p(e){let{components:n,...r}=e;return(0,i.kt)("wrapper",(0,t.Z)({},c,r,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"recursion-with-strings"},"Recursion with strings"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"The recursive function needs to reverse a string\n\ninput: the simple engineer\noutput: reenigne elpmis eht\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"before working on the recursion, need to think about the following",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"What is the base case?",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"in another words, when can i no longer continue?",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"in this case, the empty string is the base case"))))),(0,i.kt)("li",{parentName:"ul"},"What is the smallest amount of work I can do in each iteration?",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"in another words, between each invocation, what's the small unit i can reverse?")))))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'function reverseString(input) {\n  if (input === "") return ""; // base case\n  return reverseString(input.slice(1)) + input[0];\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'input: "hello"\n\ncurrent input is "hello"\nwhen function is called, the return value is added to the call stack\n|-----------------------------|\n| reverseString("ello") + "h" |\n|-----------------------------|\n\nmove to the next recursion call\ncurrent input is "ello"\nwhen function is called, the return value is added to the call stack\n|-----------------------------|\n| reverseString("llo") + "e"  |\n| reverseString("ello") + "h" |\n|-----------------------------|\n\nmove to the next recursion call\ncurrent input is "llo"\nwhen function is called, the return value is added to the call stack\n|-----------------------------|\n| reverseString("lo") + "l"   |\n| reverseString("llo") + "e"  |\n| reverseString("ello") + "h" |\n|-----------------------------|\n\nmove to the next recursion call\ncurrent input is "lo"\nwhen function is called, the return value is added to the call stack\n|-----------------------------|\n| reverseString("o") + "l"    |\n| reverseString("lo") + "l"   |\n| reverseString("llo") + "e"  |\n| reverseString("ello") + "h" |\n|-----------------------------|\n\nmove to the next recursion call\ncurrent input is "o"\nwhen function is called, the return value is added to the call stack\n|-----------------------------|\n| reverseString("") + "o"     |\n| reverseString("o") + "l"    |\n| reverseString("lo") + "l"   |\n| reverseString("llo") + "e"  |\n| reverseString("ello") + "h" |\n|-----------------------------|\n\nmove to the next recursion call\ncurrent input is ""\nsince return value for this has hit the base case,\nit will start executing by poping the top stack frame from the call stack\n\nreturn result: ""\n|-----------------------------|\n| "" + "o"                    |\n| reverseString("o") + "l"    |\n| reverseString("lo") + "l"   |\n| reverseString("llo") + "e"  |\n| reverseString("ello") + "h" |\n|-----------------------------|\n\nreturn result: "o"\n|-----------------------------|\n|                             |\n| "o" + "l"                   |\n| reverseString("lo") + "l"   |\n| reverseString("llo") + "e"  |\n| reverseString("ello") + "h" |\n|-----------------------------|\n\nreturn result: "ol"\n|-----------------------------|\n|                             |\n|                             |\n| "ol" + "l"                  |\n| reverseString("llo") + "e"  |\n| reverseString("ello") + "h" |\n|-----------------------------|\n\nreturn result: "oll"\n|-----------------------------|\n|                             |\n|                             |\n|                             |\n| "oll" + "e"                 |\n| reverseString("ello") + "h" |\n|-----------------------------|\n\nreturn result: "olle"\n|-----------------------------|\n|                             |\n|                             |\n|                             |\n|                             |\n| "olle" + "h"                |\n|-----------------------------|\n\nreturn result: "olleh"\n|-----------------------------|\n|                             |\n|                             |\n|                             |\n|                             |\n|                             |\n|-----------------------------|\n')),(0,i.kt)("h3",{id:"iterative-solution"},"Iterative solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'function reverseString(input) {\n  const midIndex = Math.ceil(input.length / 2);\n  const strArr = input.split("");\n  for (let i = 0; i < midIndex; i++) {\n    [strArr[0 + i], strArr[strArr.length - 1 - i]] = [\n      strArr[strArr.length - 1 - i],\n      strArr[0 + i],\n    ];\n  }\n  return strArr.join("");\n}\n')))}p.isMDXComponent=!0}}]);