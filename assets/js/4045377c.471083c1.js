"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[7622],{3905:(n,e,t)=>{t.d(e,{Zo:()=>p,kt:()=>g});var r=t(7294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function a(n,e){if(null==n)return{};var t,r,i=function(n,e){if(null==n)return{};var t,r,i={},o=Object.keys(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var c=r.createContext({}),u=function(n){var e=r.useContext(c),t=e;return n&&(t="function"==typeof n?n(e):s(s({},e),n)),t},p=function(n){var e=u(n.components);return r.createElement(c.Provider,{value:e},n.children)},l={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(n,e){var t=n.components,i=n.mdxType,o=n.originalType,c=n.parentName,p=a(n,["components","mdxType","originalType","parentName"]),d=u(t),g=i,f=d["".concat(c,".").concat(g)]||d[g]||l[g]||o;return t?r.createElement(f,s(s({ref:e},p),{},{components:t})):r.createElement(f,s({ref:e},p))}));function g(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var o=t.length,s=new Array(o);s[0]=d;var a={};for(var c in e)hasOwnProperty.call(e,c)&&(a[c]=e[c]);a.originalType=n,a.mdxType="string"==typeof n?n:i,s[1]=a;for(var u=2;u<o;u++)s[u]=t[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},6003:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>o,metadata:()=>a,toc:()=>u});var r=t(7462),i=(t(7294),t(3905));const o={},s="Run-Length Encoding",a={unversionedId:"interviewPrep/codingTests/easy/strings/run-lengthEncoding",id:"interviewPrep/codingTests/easy/strings/run-lengthEncoding",title:"Run-Length Encoding",description:"Write a function that takes in a non-empty string and returns its run-length",source:"@site/docs/interviewPrep/codingTests/easy/strings/run-lengthEncoding.md",sourceDirName:"interviewPrep/codingTests/easy/strings",slug:"/interviewPrep/codingTests/easy/strings/run-lengthEncoding",permalink:"/docs/interviewPrep/codingTests/easy/strings/run-lengthEncoding",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/codingTests/easy/strings/run-lengthEncoding.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Palindrome Check",permalink:"/docs/interviewPrep/codingTests/easy/strings/palindromeCheck"},next:{title:"Array Of Products",permalink:"/docs/interviewPrep/codingTests/medium/arrays/arrayOfProducts"}},c={},u=[],p={toc:u};function l(n){let{components:e,...t}=n;return(0,i.kt)("wrapper",(0,r.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"run-length-encoding"},"Run-Length Encoding"),(0,i.kt)("p",null,"Write a function that takes in a non-empty string and returns its run-length\nencoding."),(0,i.kt)("p",null,'From Wikipedia, "run-length encoding is a form of lossless data compression in\nwhich runs of data are stored as a single data value and count, rather than as\nthe original run." For this problem, a run of data is any sequence of\nconsecutive, identical characters. So the run "AAA" would be\nrun-length-encoded as "3A"'),(0,i.kt)("p",null,'To make things more complicated, however, the input string can contain all\nsorts of special characters, including numbers. And since encoded data must be\ndecodable, this means that we can\'t naively run-length-encode long runs. For\nexample, the run "AAAAAAAAAAAA" (12 As), can\'t\nnaively be encoded as "12A", since this string can be decoded as\neither "AAAAAAAAAAAA" or "1AA". Thus, long runs (runs\nof 10 or more characters) should be encoded in a split fashion; the\naforementioned run should be encoded as "9A3A"'),(0,i.kt)("p",null,"Sample Input\n",(0,i.kt)("inlineCode",{parentName:"p"},'string = "AAAAAAAAAAAAABBCCCCDD"'),'\nSample Output\n"9A4A2B4C2D"'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# solution 1\ndef runLengthEncoding(string):\n  # Write your code here.\n  newStr = []\n  count = 0\n  previous = None\n  for i in range(len(string)):\n    if not previous:\n      count += 1\n    elif string[i] == previous and count < 9:\n      count += 1\n    elif string[i] == previous:\n      newStr.append(str(count))\n      newStr.append(string[i])\n      count = 1\n    elif string[i] != previous:\n      newStr.append(str(count))\n      newStr.append(previous)\n      count = 1\n    if i == len(string) - 1:\n      newStr.append(str(count))\n      newStr.append(string[i])\n    previous = string[i]\n  return "".join(newStr)\n\n\n# solution 2\ndef runLengthEncoding(string):\n  # Write your code here.\n  newStr = []\n  count = 1\n  for i in range(1, len(string)):\n    current = string[i]\n    previous = string[i-1]\n    if current != previous or count >= 9:\n      newStr.append(str(count))\n      newStr.append(previous)\n      count = 0\n    count += 1\n  newStr.append(str(count))\n  newStr.append(string[len(string) - 1])\n  return "".join(newStr)\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'function runLengthEncoding(string) {\n  // Write your code here.\n  const newStr = [];\n  let count = 1;\n  for (let i = 1; i < string.length; i++) {\n    const current = string[i];\n    const previous = string[i - 1];\n    if (current !== previous || count >= 9) {\n      newStr.push(String(count));\n      newStr.push(previous);\n      count = 0;\n    }\n    count++;\n  }\n  newStr.push(String(count));\n  newStr.push(string[string.length - 1]);\n  return newStr.join("");\n}\n')))}l.isMDXComponent=!0}}]);