"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[82718],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),f=a,u=d["".concat(l,".").concat(f)]||d[f]||m[f]||o;return n?r.createElement(u,i(i({ref:t},p),{},{components:n})):r.createElement(u,i({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4647:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=n(83117),a=(n(67294),n(3905));const o={},i="Python Example",s={unversionedId:"interviewPrep/designPatterns/Structural_patterns/Bridge/python/readme",id:"interviewPrep/designPatterns/Structural_patterns/Bridge/python/readme",title:"Python Example",description:"",source:"@site/docs/interviewPrep/designPatterns/Structural_patterns/Bridge/python/readme.md",sourceDirName:"interviewPrep/designPatterns/Structural_patterns/Bridge/python",slug:"/interviewPrep/designPatterns/Structural_patterns/Bridge/python/",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Bridge/python/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Structural_patterns/Bridge/python/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java Example",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Bridge/java/"},next:{title:"Example 2",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Bridge/python/example2"}},l={},c=[],p={toc:c};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"python-example"},"Python Example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'"""\nBridge Design Pattern\n\nIntent: Lets you split a large class or a set of closely related classes into\ntwo separate hierarchies\u2014abstraction and implementation\u2014which can be developed\nindependently of each other.\n\n              A\n           /     \\                        A         N\n         Aa      Ab        ===>        /     \\     / \\\n        / \\     /  \\                 Aa(N) Ab(N)  1   2\n      Aa1 Aa2  Ab1 Ab2\n"""\n\n\nfrom __future__ import annotations\nfrom abc import ABC, abstractmethod\n\n\nclass Abstraction:\n    """\n    The Abstraction defines the interface for the "control" part of the two\n    class hierarchies. It maintains a reference to an object of the\n    Implementation hierarchy and delegates all of the real work to this object.\n    """\n\n    def __init__(self, implementation: Implementation) -> None:\n        self.implementation = implementation\n\n    def operation(self) -> str:\n        return (f"Abstraction: Base operation with:\\n"\n                f"{self.implementation.operation_implementation()}")\n\n\nclass ExtendedAbstraction(Abstraction):\n    """\n    You can extend the Abstraction without changing the Implementation classes.\n    """\n\n    def operation(self) -> str:\n        return (f"ExtendedAbstraction: Extended operation with:\\n"\n                f"{self.implementation.operation_implementation()}")\n\n\nclass Implementation(ABC):\n    """\n    The Implementation defines the interface for all implementation classes. It\n    doesn\'t have to match the Abstraction\'s interface. In fact, the two\n    interfaces can be entirely different. Typically the Implementation interface\n    provides only primitive operations, while the Abstraction defines higher-\n    level operations based on those primitives.\n    """\n\n    @abstractmethod\n    def operation_implementation(self) -> str:\n        pass\n\n\n"""\nEach Concrete Implementation corresponds to a specific platform and implements\nthe Implementation interface using that platform\'s API.\n"""\n\n\nclass ConcreteImplementationA(Implementation):\n    def operation_implementation(self) -> str:\n        return "ConcreteImplementationA: Here\'s the result on the platform A."\n\n\nclass ConcreteImplementationB(Implementation):\n    def operation_implementation(self) -> str:\n        return "ConcreteImplementationB: Here\'s the result on the platform B."\n\n\ndef client_code(abstraction: Abstraction) -> None:\n    """\n    Except for the initialization phase, where an Abstraction object gets linked\n    with a specific Implementation object, the client code should only depend on\n    the Abstraction class. This way the client code can support any abstraction-\n    implementation combination.\n    """\n\n    # ...\n\n    print(abstraction.operation(), end="")\n\n    # ...\n\n\nif __name__ == "__main__":\n    """\n    The client code should be able to work with any pre-configured abstraction-\n    implementation combination.\n    """\n\n    implementation = ConcreteImplementationA()\n    abstraction = Abstraction(implementation)\n    client_code(abstraction)\n\n    print("\\n")\n\n    implementation = ConcreteImplementationB()\n    abstraction = ExtendedAbstraction(implementation)\n    client_code(abstraction)\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"Abstraction: Base operation with:\nConcreteImplementationA: Here's the result on the platform A.\n\nExtendedAbstraction: Extended operation with:\nConcreteImplementationB: Here's the result on the platform B.\n")))}m.isMDXComponent=!0}}]);