"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[7493],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>d});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),c=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(o.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=c(a),d=i,m=h["".concat(o,".").concat(d)]||h[d]||p[d]||r;return a?n.createElement(m,l(l({ref:t},u),{},{components:a})):n.createElement(m,l({ref:t},u))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=h;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var c=2;c<r;c++)l[c]=a[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},23196:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=a(83117),i=(a(67294),a(3905));const r={},l="Mixins",s={unversionedId:"interviewPrep/programmingParadigm/OOP/mixins",id:"interviewPrep/programmingParadigm/OOP/mixins",title:"Mixins",description:"- Mixins is another OOD tool to share some behavior between non-related objects",source:"@site/docs/interviewPrep/programmingParadigm/OOP/mixins.md",sourceDirName:"interviewPrep/programmingParadigm/OOP",slug:"/interviewPrep/programmingParadigm/OOP/mixins",permalink:"/docs/interviewPrep/programmingParadigm/OOP/mixins",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/programmingParadigm/OOP/mixins.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Interface",permalink:"/docs/interviewPrep/programmingParadigm/OOP/interface"},next:{title:"Introduction",permalink:"/docs/interviewPrep/system_design/01Introduction/"}},o={},c=[{value:"Understanding Roles",id:"understanding-roles",level:2},{value:"Writing the Concrete Code",id:"writing-the-concrete-code",level:2},{value:"Writing Inheritable Code",id:"writing-inheritable-code",level:2}],u={toc:c};function p(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"mixins"},"Mixins"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Mixins is another OOD tool to share some behavior between non-related objects",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"while inheritance and composition working with some classes' hierarchy mixins can share needed behavior between different classes which are not directly related but need to play some specific role"))),(0,i.kt)("li",{parentName:"ul"},"mixins model relation type: ",(0,i.kt)("inlineCode",{parentName:"li"},"BEHAVES-AS"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"mixins tells us that some object under some circumstances 'behaves-as' needed under these circumstances"))),(0,i.kt)("li",{parentName:"ul"},"inheritance is not the only way to share a behavior",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"every problem which we solve using inheritance can also be solved using other tools, such as mixins")))),(0,i.kt)("h2",{id:"understanding-roles"},"Understanding Roles"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Sometimes you need to share some behavior between non-related objects"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"such case is a direct opposite to inheritance hierarchy (IS-A relation)"),(0,i.kt)("li",{parentName:"ul"},"It is rather a role, which object can play on some state of its lifecycle"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"example"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"When you need to use mixin functionality on some object, you can just add it to the object's prototype",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this will give us the possibility to use mixins methods on this object"))),(0,i.kt)("li",{parentName:"ul"},"such approach has some consequences, prototypes functionality is not the most convenient in usage, apart from that, ",(0,i.kt)("inlineCode",{parentName:"li"},"Object.assign()")," only makes a shallow copy",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"can use existing JavaScript libraries to make mixins usage easier")))))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const sayMixin = {\n  say(phrase) {\n    alert(phrase);\n  },\n};\n\nconst sayHiMixin = {\n  __proto__: sayMixin,\n  sayHi() {\n    super.say(`Hello ${this.name}`);\n  },\n  sayBye() {\n    super.say(`Bye ${this.name}`);\n  },\n};\n\nclass User {\n  constructor(public name) {}\n}\n\nObject.assign(User.prototype, sayHiMixin);\n\nnew User("Dave").sayHi();\n')),(0,i.kt)("h2",{id:"writing-the-concrete-code"},"Writing the Concrete Code"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"example 1"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"major part of logic is stored in Schedule class",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the class is used in isSchedulable method of Bicycle",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"it needs two dates, one for the start and one for the end of booking"),(0,i.kt)("li",{parentName:"ul"},"Schedule instance receives start date with subtracted leadDays",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"so as to provide enough time to prepare the bicycle for a trip"))))))),(0,i.kt)("li",{parentName:"ul"},"we can schedule a bicycle, but we also have other classes like Mechanic and Driver and each of them has its own leadDays value",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"by extracting common logic, we can create Schedulable duck type"))),(0,i.kt)("li",{parentName:"ul"},"with the new Schedulable instance, the relation between Bicycle and Schedulable is not ",(0,i.kt)("inlineCode",{parentName:"li"},"IS-A"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"because Bicycle should not be schedulable under normal conditions"),(0,i.kt)("li",{parentName:"ul"},"This duck type describes Bicycle specific behavior when it is required to be scheduled for the trip"),(0,i.kt)("li",{parentName:"ul"},"Other parts of the system should not even know that Bicycle is schedulable"))),(0,i.kt)("li",{parentName:"ul"},"these classes relations will be better to describe as ",(0,i.kt)("inlineCode",{parentName:"li"},"BEHAVES-AS"))),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Schedule {\n  isScheduled(schedulable, starting, ending) {\n    console.log(\n      `Checking if ${schedulable.constructor.name}` +\n        `is available on ${starting} - ${ending}`\n    );\n\n    //do the checks\n\n    return true;\n  }\n}\n\nclass Bicycle {\n  leadDays = 1;\n\n  constructor(parts, schedule = new Schedule()) {\n    this.schedule = schedule;\n    // ...\n  }\n\n  isSchedulable(starting, ending) {\n    const withLeadTime = starting - this.leadDays;\n\n    return this.schedule.isScheduled(this, withLeadTime, ending);\n  }\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"example 2"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"by extracting common logic to SchedulableMixin with isSchedulable method",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"now we can easily mix it to any class in the hierarchy, either Bicycle, Mechanic or Driver, so we will have schedulable behavior when we only need it"),(0,i.kt)("li",{parentName:"ul"},"In this case decorators could be used as an alternative solution"),(0,i.kt)("li",{parentName:"ul"},"The only consequence in Schedulable mixin is that we need to store leadDays property in a target class, so it can be used in mixin")))),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const SchedulableMixin = (superclass) =>\n  class extends superclass {\n    private _schedule: Schedule;\n    protected leadDays = 0;\n\n    set schedule(schedule) {\n      this._schedule = schedule;\n    }\n\n    get schedule() {\n      return this._schedule || new Schedule();\n    }\n\n    isSchedulable(starting, ending) {\n      const withLeadDays = starting - this.leadDays;\n\n      return this.schedule.isScheduled(this, withLeadDays, ending);\n    }\n  };\n\nclass Bicycle extends SchedulableMixin(Object) {\n  protected leadDays = 1;\n}\n\nclass Vehicle extends SchedulableMixin(Object) {\n  protected leadDays = 3;\n}\n\nclass Mechanic extends SchedulableMixin(Object) {\n  protected leadDays = 4;\n}\n")))),(0,i.kt)("h2",{id:"writing-inheritable-code"},"Writing Inheritable Code"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Mixins call stack",src:a(28054).Z,width:"1446",height:"1720"})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"mixins adds additional levels to the call stack"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this makes understanding and debugging of the application less obvious"),(0,i.kt)("li",{parentName:"ul"},"thus need to keep this in mind and use mixins only when they are really needed"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"rules to follow"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Recognize the Antipatterns"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"There are two antipatterns which may indicate that you can gain a benefit from inheritance"),(0,i.kt)("li",{parentName:"ul"},"First of them is using variables with a type/category to determine a type of object and send it a message"),(0,i.kt)("li",{parentName:"ul"},"The second is usage of direct object type checking or switch-case operator",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"rather missed a duck type"),(0,i.kt)("li",{parentName:"ul"},"Duck types may have not only common interface but also common behavior, which is recommended to extract to mixins"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Insist on the Abstraction"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"All the code in an abstract superclass which should be used in every subclass, superclasses should not contain a code which is only applied for some subclasses"),(0,i.kt)("li",{parentName:"ul"},"This limitation is also applicable to mixins, all the mixin functionality should be used in every place where it is mixed in"),(0,i.kt)("li",{parentName:"ul"},"If you cannot identify an abstraction, then probably it is not existing, and inheritance cannot be applied to solve this problem"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Honor the Contract"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Subclasses must honor the contract, so they can be easily replaced with superclasses without any change in a system behavior"),(0,i.kt)("li",{parentName:"ul"},"This means that they need to answer on the same messages receiving the same input data and returning the same result data"),(0,i.kt)("li",{parentName:"ul"},"Thereby they cannot do something which will force a client code to check them for a type to understand what to wait from them"),(0,i.kt)("li",{parentName:"ul"},"Subclasses which do not honor the contract cannot work synchronously thus making all the inheritance hierarchy unpredictable"),(0,i.kt)("li",{parentName:"ul"},"This also violates Liskov Substitution Principle"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Preemptively Decouple Classes"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Try to avoid super method call, use template method pattern and so-called hooks instead, they give subclass a possibility to specify the common algorithm which is controlled by superclass"),(0,i.kt)("li",{parentName:"ul"},'Remember that it is not a "silver bullet" and do not follow this approach blindly'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Create Shallow Hierarchies"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Try to create as compact hierarchies as it is possible"),(0,i.kt)("li",{parentName:"ul"},"Shallow hierarchies are easy to understand, shallow and wide are slightly more difficult, but they still are easy to understand"),(0,i.kt)("li",{parentName:"ul"},"Deep and narrow hierarchies tend to become wider and much difficult to understand and maintain"),(0,i.kt)("li",{parentName:"ul"},"You should avoid deep and wide hierarchies, they create a long path to target method or property which is missing in a target class"),(0,i.kt)("li",{parentName:"ul"},"Such hierarchies are difficult to maintain, and they create a high risk of application failure")))),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("img",{alt:"Different Hierarchies",src:a(46465).Z,width:"1048",height:"738"})))))}p.isMDXComponent=!0},46465:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/differentHierarchies-bfebeb21ad5867c76b9ca50b7f8813cb.png"},28054:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/mixinsCallStack-8ada2597916b12ea2292e29df54e9c04.png"}}]);