"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[93226],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=p(a),u=i,d=h["".concat(s,".").concat(u)]||h[u]||m[u]||r;return a?n.createElement(d,o(o({ref:t},c),{},{components:a})):n.createElement(d,o({ref:t},c))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},29527:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var n=a(83117),i=(a(67294),a(3905));const r={},o="Visitor",l={unversionedId:"interviewPrep/designPatterns/Behavioral_patterns/Visitor/readme",id:"interviewPrep/designPatterns/Behavioral_patterns/Visitor/readme",title:"Visitor",description:"- it is a behavioral design pattern that lets you separate algorithms from the objects on which they operate",source:"@site/docs/interviewPrep/designPatterns/Behavioral_patterns/Visitor/readme.md",sourceDirName:"interviewPrep/designPatterns/Behavioral_patterns/Visitor",slug:"/interviewPrep/designPatterns/Behavioral_patterns/Visitor/",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Visitor/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Behavioral_patterns/Visitor/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"TypeScript Example",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Template/typescript/"},next:{title:"C++ Example",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Visitor/cPlusPlus/"}},s={},p=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2},{value:"Analogy",id:"analogy",level:2},{value:"Structure",id:"structure",level:2},{value:"When to use",id:"when-to-use",level:2},{value:"How to implement",id:"how-to-implement",level:2},{value:"Pros &amp; Cons",id:"pros--cons",level:2},{value:"Pros",id:"pros",level:3},{value:"Cons",id:"cons",level:3},{value:"Example",id:"example",level:2}],c={toc:p};function m(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"visitor"},"Visitor"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"it is a behavioral design pattern that lets you separate algorithms from the objects on which they operate")),(0,i.kt)("h2",{id:"problem"},"Problem"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"when a team develops an app which works with geographic information structured as 1 colossal graph",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"each node of the graph may represent a complex entity",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"such as a city, and granular things like industries, sightseeing areas, etc"))),(0,i.kt)("li",{parentName:"ul"},"the nodes are connected with others if there's a road between real objects that they represent"),(0,i.kt)("li",{parentName:"ul"},"under the hood, each node type is represented by its own class"),(0,i.kt)("li",{parentName:"ul"},"while each specific node is an object"))),(0,i.kt)("li",{parentName:"ul"},"at some point, a new task is given to implement exporting the graph into XML format",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"seems straightforward"),(0,i.kt)("li",{parentName:"ul"},"plan to add an export method to each node class",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"and then leverage recursion to go over each node of the graph, executing the export method"))),(0,i.kt)("li",{parentName:"ul"},"solution was simple and elegant",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"thanks to polymorphism, code weren't coupled that called the export method to concrete classes of node"))))),(0,i.kt)("li",{parentName:"ul"},"however, the system architect refused to allow altering of existing node classes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"since code was already in production, its not good to take risk breaking the app due to a potential bug in the changes"),(0,i.kt)("li",{parentName:"ul"},"it also does not make sense to have XML export code within node classes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"primary job of these classes was to work with geodata",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"XML export behavior would look alien there"))))),(0,i.kt)("li",{parentName:"ul"},"another reason for refusal is after this feature is implemented",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"someone from the marketing department would ask to provide the ability to export into a different format",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"or request some other weird stuff"))),(0,i.kt)("li",{parentName:"ul"},"this would force you to change those classes again")))))),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"the visitor pattern suggests that the new behavior should be placed into a separate class call visitor"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the original object that had to perform the behavior is now passed to 1 of the visitor's methods as an argument",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"providing the method access to all necessary data contained within the object"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"the behavior can also be executed over objects of different classes"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the visitor class may define set of methods, each of which could take arguments of different types",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"class ExportVisitor implements Visitor is\n  method doForCity(City c) { ... }\n  method doForIndustry(Industry f) { ... }\n  method doForSightSeeing(SightSeeing ss) { ... }\n  // ...\n"))),(0,i.kt)("li",{parentName:"ul"},"however, calling of these methods will be an issue since they have different signatures, thus polymorphism can't be used",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"foreach (Node node in graph) {\n  if (node instanceof City)\n    exportVisitor.doForCity((City) node)\n  if (node instanceof Industry)\n    exportVisitor.doForIndustry((Industry) node)\n  // ...\n}\n"))),(0,i.kt)("li",{parentName:"ul"},"why not use method overloading?",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"give all methods the same name even if they support different sets of parameters"),(0,i.kt)("li",{parentName:"ul"},"however, even if java & C# supports it, it won't be of help"),(0,i.kt)("li",{parentName:"ul"},"since the exact class of a node object is unknown in advance",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the overloading mechanism won't be able to determine the correct method to execute"))),(0,i.kt)("li",{parentName:"ul"},"it would default to the method that takes an object of the base Node class"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"the Visitor pattern addresses this problem by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Double Dispatch")," method"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"this helps to execute the proper method on an object without cumbersome conditionals")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"instead of letting the client select a proper version of the method to call"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"we delegate the choice to objects we're passing to the visitor as an argument")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"since the objects know their own classes"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"they would be able to pick a proper method on the visitor less awkwardly")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"the accept a visitor and tell it what visiting method should be executed"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"// Client code\nforeach (Node node in graph)\n  node.accept(exportVisitor)\n\n// City\nclass City is\n  method accept(Visitor v) is\n    v.doForCity(this)\n  // ...\n\n// Industry\nclass Industry is\n  method accept(Visitor v) is\n    v.doForIndustry(this)\n  // ...\n"))))))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"although the node classes still has to be changed"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"at least the change is trivial"),(0,i.kt)("li",{parentName:"ul"},"and lets us add further behaviors without altering the code again"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"by extracting a common interface for all visitors"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"all existing nodes can work with any visitor introduced into the app"),(0,i.kt)("li",{parentName:"ul"},"when required to introduce a new behavior related to nodes, just need to implement a new visitor class")))),(0,i.kt)("h2",{id:"analogy"},"Analogy"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"imagine a seasoned insurance agent who's eager to get new customers",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"he can visit every building in a neighborhood",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"and try to sell insurance to everyone he meets"))),(0,i.kt)("li",{parentName:"ul"},"depending on the type of organization that occupies the building",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"he can offer specialized insurance policies",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"residential building, sells medical insurance"),(0,i.kt)("li",{parentName:"ul"},"bank, sells theft insurance"),(0,i.kt)("li",{parentName:"ul"},"coffee shop, sells fire and flood insurance")))))))),(0,i.kt)("h2",{id:"structure"},"Structure"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Visitor",src:a(87231).Z,width:"1072",height:"1130"})),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The Visitor interface declares a set of visiting methods that can take concrete elements of an object structure as arguments."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"These methods may have the same names if the program is written in a language that supports overloading, but the type of their parameters must be different."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Each Concrete Visitor implements several versions of the same behaviors, tailored for different concrete element classes.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The Element interface declares a method for \u201caccepting\u201d visitors."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This method should have one parameter declared with the type of the visitor interface."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Each Concrete Element must implement the acceptance method."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The purpose of this method is to redirect the call to the proper visitor\u2019s method corresponding to the current element class."),(0,i.kt)("li",{parentName:"ul"},"Be aware that even if a base element class implements this method, all subclasses must still override this method in their own classes and call the appropriate method on the visitor object."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The Client usually represents a collection or some other complex object (for example, a Composite tree)."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Usually, clients aren\u2019t aware of all the concrete element classes because they work with objects from that collection via some abstract interface.")))),(0,i.kt)("h2",{id:"when-to-use"},"When to use"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Use the Visitor when you need to perform an operation on all elements of a complex object structure (for example, an object tree)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The Visitor pattern lets you execute an operation over a set of objects with different classes by having a visitor object implement several variants of the same operation, which correspond to all target classes"))),(0,i.kt)("li",{parentName:"ul"},"Use the Visitor to clean up the business logic of auxiliary behaviors",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The pattern lets you make the primary classes of your app more focused on their main jobs by extracting all other behaviors into a set of visitor classes"))),(0,i.kt)("li",{parentName:"ul"},"Use the pattern when a behavior makes sense only in some classes of a class hierarchy, but not in others",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"You can extract this behavior into a separate visitor class and implement only those visiting methods that accept objects of relevant classes, leaving the rest empty")))),(0,i.kt)("h2",{id:"how-to-implement"},"How to implement"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Declare the visitor interface with a set of \u201cvisiting\u201d methods, one per each concrete element class that exists in the program"),(0,i.kt)("li",{parentName:"ol"},"Declare the element interface",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"If you\u2019re working with an existing element class hierarchy, add the abstract \u201cacceptance\u201d method to the base class of the hierarchy"),(0,i.kt)("li",{parentName:"ul"},"This method should accept a visitor object as an argument"))),(0,i.kt)("li",{parentName:"ol"},"Implement the acceptance methods in all concrete element classes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"These methods must simply redirect the call to a visiting method on the incoming visitor object which matches the class of the current element"))),(0,i.kt)("li",{parentName:"ol"},"The element classes should only work with visitors via the visitor interface",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Visitors, however, must be aware of all concrete element classes, referenced as parameter types of the visiting methods"))),(0,i.kt)("li",{parentName:"ol"},"For each behavior that can\u2019t be implemented inside the element hierarchy, create a new concrete visitor class and implement all of the visiting methods",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"You might encounter a situation where the visitor will need access to some private members of the element class"),(0,i.kt)("li",{parentName:"ul"},"In this case, you can either make these fields or methods public, violating the element\u2019s encapsulation, or nest the visitor class in the element class"),(0,i.kt)("li",{parentName:"ul"},"The latter is only possible if you\u2019re lucky to work with a programming language that supports nested classes"))),(0,i.kt)("li",{parentName:"ol"},"The client must create visitor objects and pass them into elements via \u201cacceptance\u201d methods")),(0,i.kt)("h2",{id:"pros--cons"},"Pros & Cons"),(0,i.kt)("h3",{id:"pros"},"Pros"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Open/Closed Principle",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"You can introduce a new behavior that can work with objects of different classes without changing these classes"))),(0,i.kt)("li",{parentName:"ul"},"Single Responsibility Principle",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"You can move multiple versions of the same behavior into the same class"))),(0,i.kt)("li",{parentName:"ul"},"A visitor object can accumulate some useful information while working with various objects",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This might be handy when you want to traverse some complex object structure, such as an object tree, and apply the visitor to each object of this structure")))),(0,i.kt)("h3",{id:"cons"},"Cons"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You need to update all visitors each time a class gets added to or removed from the element hierarchy"),(0,i.kt)("li",{parentName:"ul"},"Visitors might lack the necessary access to the private fields and methods of the elements that they\u2019re supposed to work with")),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// The component interface declares an 'accept' method that\n// takes the base visitor interface as an argument.\ninterface Shape {\n  move(x, y);\n  draw();\n  accept(v: Visitor);\n}\n\n// Each concrete component class must implement the 'accept' method\nclass Dot implements Shape {\n  accept(v: Visitor) {\n    v.visitDot(this);\n  }\n  move(x, y) {}\n  draw() {}\n}\n\nclass Circle implements Shape {\n  accept(v: Visitor) {\n    v.visitCircle(this);\n  }\n  move(x, y) {}\n  draw() {}\n}\n\nclass Rectangle implements Shape {\n  accept(v: Visitor) {\n    v.visitRectangle(this);\n  }\n  move(x, y) {}\n  draw() {}\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// The Visitor interface declares a set of visiting methods that\n// correspond to component classes.\ninterface Visitor {\n  visitDot(d: Dot);\n  visitCircle(c: Circle);\n  visitRectangle(r: Rectangle);\n}\n\nclass JSONExportVisitor implements Visitor {\n  visitDot(d: Dot) {\n    // Export the dot's ID and coordinates.\n  }\n\n  visitCircle(d: Circle) {\n    // Export the circle's ID, center coordinates and radius.\n  }\n\n  visitRectangle(d: Rectangle) {\n    // Export the rectangle's ID, left-top coordinates, width and height.\n  }\n}\n\n// The client code can run visitor operations over any set of\n// elements without figuring out their concrete classes. The\n// 'accept' operation directs a call to the appropriate operation\n// in the visitor object.\nconst allShapes = [new Dot(), new Circle(), new Rectangle()];\nconst exportVisitor = new JSONExportVisitor();\n\nallShapes.forEach((shape) => shape.accept(exportVisitor));\n")))}m.isMDXComponent=!0},87231:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/visitor-fc194a448b0d3fbce09c5eb658b738a7.png"}}]);