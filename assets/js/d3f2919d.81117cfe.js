"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[4316],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>d});var n=a(67294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),c=p(a),d=l,k=c["".concat(s,".").concat(d)]||c[d]||m[d]||i;return a?n.createElement(k,o(o({ref:t},u),{},{components:a})):n.createElement(k,o({ref:t},u))}));function d(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=a.length,o=new Array(i);o[0]=c;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:l,o[1]=r;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},90860:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var n=a(87462),l=(a(67294),a(3905));const i={},o="Kubernetes (K8s, Hubernetes)",r={unversionedId:"Technologies/devops/kubernetes/readme",id:"Technologies/devops/kubernetes/readme",title:"Kubernetes (K8s, Hubernetes)",description:"- it is an open-source platform started by google, designed to automate the deployment, scaling, and operation of containers",source:"@site/docs/Technologies/devops/kubernetes/readme.md",sourceDirName:"Technologies/devops/kubernetes",slug:"/Technologies/devops/kubernetes/",permalink:"/docs/Technologies/devops/kubernetes/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/Technologies/devops/kubernetes/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Docker Compose",permalink:"/docs/Technologies/devops/docker/dockercompose"},next:{title:"Minikube",permalink:"/docs/Technologies/devops/kubernetes/minikube"}},s={},p=[{value:"Features",id:"features",level:2},{value:"Multi-host container scheduling",id:"multi-host-container-scheduling",level:3},{value:"Scalability and Availability",id:"scalability-and-availability",level:3},{value:"Flexibility and Modularization",id:"flexibility-and-modularization",level:4},{value:"Registration and Discovery",id:"registration-and-discovery",level:4},{value:"Registration",id:"registration",level:5},{value:"Service Discovery",id:"service-discovery",level:5},{value:"Persistent Storage",id:"persistent-storage",level:4},{value:"Application Upgrades and Downgrades",id:"application-upgrades-and-downgrades",level:4},{value:"Maintenance",id:"maintenance",level:3},{value:"Logging and Monitoring",id:"logging-and-monitoring",level:3},{value:"Secrets Management",id:"secrets-management",level:3},{value:"Kubernetes: basics",id:"kubernetes-basics",level:2},{value:"Kubernetes cluster architecture",id:"kubernetes-cluster-architecture",level:3},{value:"master node",id:"master-node",level:4},{value:"etcd",id:"etcd",level:4},{value:"kubectl",id:"kubectl",level:4},{value:"worker nodes",id:"worker-nodes",level:4},{value:"Nodes and Pods",id:"nodes-and-pods",level:3},{value:"Node",id:"node",level:4},{value:"Tool: Minikube",id:"tool-minikube",level:4},{value:"Pods",id:"pods",level:4},{value:"Controllers",id:"controllers",level:3},{value:"Labels, Selectors, and Namespaces",id:"labels-selectors-and-namespaces",level:3},{value:"Labels",id:"labels",level:4},{value:"Selectors",id:"selectors",level:4},{value:"Namespaces",id:"namespaces",level:4},{value:"Kubelet and Kube-proxy",id:"kubelet-and-kube-proxy",level:3},{value:"Kubelet",id:"kubelet",level:4},{value:"Kube-proxy: the network proxy",id:"kube-proxy-the-network-proxy",level:4},{value:"Authentication and Authorization",id:"authentication-and-authorization",level:2},{value:"2 kinds of users",id:"2-kinds-of-users",level:3},{value:"Information that defines a User",id:"information-that-defines-a-user",level:3},{value:"Definitions",id:"definitions",level:3},{value:"Popular Authentication Modules",id:"popular-authentication-modules",level:3},{value:"Client Certificate Authentication",id:"client-certificate-authentication",level:4},{value:"Static token files (static password file)",id:"static-token-files-static-password-file",level:4},{value:"OpenID Connect",id:"openid-connect",level:4},{value:"Webhook tokens",id:"webhook-tokens",level:4},{value:"Popular Authorization Modules",id:"popular-authorization-modules",level:3},{value:"ABAC: Attribute-based access control",id:"abac-attribute-based-access-control",level:4},{value:"RBAC: Role-based access control",id:"rbac-role-based-access-control",level:4},{value:"Webhook Authorization Mode",id:"webhook-authorization-mode",level:4},{value:"Installation",id:"installation",level:2},{value:"Yaml file",id:"yaml-file",level:2},{value:"application health checks",id:"application-health-checks",level:3},{value:"readinessProbe",id:"readinessprobe",level:4},{value:"livenessProbe",id:"livenessprobe",level:4},{value:"Commands",id:"commands",level:2},{value:"verify if cluster is up and running",id:"verify-if-cluster-is-up-and-running",level:3},{value:"see what is in the cluster",id:"see-what-is-in-the-cluster",level:3},{value:"create deployment, service, pod",id:"create-deployment-service-pod",level:3},{value:"update deployment",id:"update-deployment",level:3},{value:"deletion",id:"deletion",level:3},{value:"expose deployment as a service",id:"expose-deployment-as-a-service",level:3},{value:"view deployments",id:"view-deployments",level:3},{value:"introspect a deployment",id:"introspect-a-deployment",level:3},{value:"view services",id:"view-services",level:3},{value:"introspect a service",id:"introspect-a-service",level:3},{value:"view pods",id:"view-pods",level:3},{value:"view replicaSets",id:"view-replicasets",level:3},{value:"Modifying labels after deployment",id:"modifying-labels-after-deployment",level:3},{value:"view rollout history",id:"view-rollout-history",level:3},{value:"revert changes",id:"revert-changes",level:3},{value:"configmap",id:"configmap",level:3},{value:"create configmap",id:"create-configmap",level:4},{value:"view configmap",id:"view-configmap",level:4},{value:"introspect a configmap",id:"introspect-a-configmap",level:4},{value:"handling application secrets",id:"handling-application-secrets",level:3},{value:"create a secret",id:"create-a-secret",level:4},{value:"view secret list",id:"view-secret-list",level:4},{value:"running jobs",id:"running-jobs",level:3},{value:"simple jobs",id:"simple-jobs",level:4},{value:"cron jobs",id:"cron-jobs",level:4},{value:"daemonset",id:"daemonset",level:3},{value:"view daemonsets",id:"view-daemonsets",level:4},{value:"stateful set",id:"stateful-set",level:3},{value:"view stateful sets",id:"view-stateful-sets",level:4},{value:"namespaces",id:"namespaces-1",level:3},{value:"view namespaces",id:"view-namespaces",level:4},{value:"create namespace",id:"create-namespace",level:4},{value:"delete namespace",id:"delete-namespace",level:4}],u={toc:p};function m(e){let{components:t,...i}=e;return(0,l.kt)("wrapper",(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"kubernetes-k8s-hubernetes"},"Kubernetes (K8s, Hubernetes)"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"it is an open-source platform started by google, designed to automate the deployment, scaling, and operation of containers"),(0,l.kt)("li",{parentName:"ul"},"the goal of the platform is to foster an ecosystem of components and tools that relieve the burden of running applications in public and private clouds"),(0,l.kt)("li",{parentName:"ul"},"in google",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"all infrastructure relies on containers and generates more than 2 billion container deployments a week"),(0,l.kt)("li",{parentName:"ul"},"all powered by an internal platform called ",(0,l.kt)("inlineCode",{parentName:"li"},"Borg"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Borg was the predecessor to Kubernetes"))))),(0,l.kt)("li",{parentName:"ul"},"by using Kubernetes in your infrastructure",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it gives you a platform to schedule and run containers on clusters of your machines"),(0,l.kt)("li",{parentName:"ul"},"it runs on bare metal, virtual machines, private datacenter and public cloud"),(0,l.kt)("li",{parentName:"ul"},"this means no more ",(0,l.kt)("inlineCode",{parentName:"li"},"golden handcuffs")," and opens up opportunities to have hybrid cloud scenarios for those migrating towards the cloud"))),(0,l.kt)("li",{parentName:"ul"},"since kubernetes is a container platform, you can use ",(0,l.kt)("inlineCode",{parentName:"li"},"Docker")," containers or other container platforms (e.g.: rkt) to develop and build applications",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"then use Kubernetes to run these applications on your infrastructure"))),(0,l.kt)("li",{parentName:"ul"},"other major player in container orchestration other than Kubernetes",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g.: Docker Swarm, Rancher, Mesos"),(0,l.kt)("li",{parentName:"ul"},"Cloud Specific technologies",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g.: Amazon EC2 Container service, Google Anthos")))))),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Orchestrator Guidelines",src:a(80583).Z,width:"1670",height:"862"})),(0,l.kt)("h2",{id:"features"},"Features"),(0,l.kt)("h3",{id:"multi-host-container-scheduling"},"Multi-host container scheduling"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"handled by Kube-scheduler"),(0,l.kt)("li",{parentName:"ul"},"it assigns containers also known as ",(0,l.kt)("inlineCode",{parentName:"li"},"pods")," to nodes at runtime"),(0,l.kt)("li",{parentName:"ul"},"it checks resources, quality of service, polices, and user specifications before scheduling")),(0,l.kt)("h3",{id:"scalability-and-availability"},"Scalability and Availability"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the kubernetes master can be deployed in a highly available configuration"),(0,l.kt)("li",{parentName:"ul"},"multi-region deployments are also available"),(0,l.kt)("li",{parentName:"ul"},"e.g.: Kubernetes v1.17",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"architecture supports 5000 node clusters"),(0,l.kt)("li",{parentName:"ul"},"run up to max 150000 total pods",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"max 100 pods per node"))),(0,l.kt)("li",{parentName:"ul"},"pods can be horizontally scaled via an API")))),(0,l.kt)("h4",{id:"flexibility-and-modularization"},"Flexibility and Modularization"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"has a plug and play architecture",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it allows you to extend it when needed"))),(0,l.kt)("li",{parentName:"ul"},"has add-ons: network drivers, service discovery, container runtime, visualization, and command",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"if there are tasks that you need to perform for a specific environment",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"can create an add-on to suit the need")))))),(0,l.kt)("h4",{id:"registration-and-discovery"},"Registration and Discovery"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"they are the 2 features that allow Kubernetes clusters to scale")),(0,l.kt)("h5",{id:"registration"},"Registration"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"new worker nodes can seamlessly register themselves with the Kubernetes master node")),(0,l.kt)("h5",{id:"service-discovery"},"Service Discovery"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"allows for automatic detection of new services and endpoints via DNS or environment variables")),(0,l.kt)("h4",{id:"persistent-storage"},"Persistent Storage"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a requested and important feature when working with containers"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pods")," can use persistent volumes to store data",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"data is retained across pod restarts and crashes")))),(0,l.kt)("h4",{id:"application-upgrades-and-downgrades"},"Application Upgrades and Downgrades"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"upgrades and downgrades are supported out of the box")),(0,l.kt)("h3",{id:"maintenance"},"Maintenance"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"features are backward compatible for a few versions"),(0,l.kt)("li",{parentName:"ul"},"all APIs are versioned"),(0,l.kt)("li",{parentName:"ul"},"able to turn on/off host during maintenance",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"can unschedule the host so that no deployments can take place on it during upgrading or maintenance"),(0,l.kt)("li",{parentName:"ul"},"then turn host back on and schedule deployments or jobs")))),(0,l.kt)("h3",{id:"logging-and-monitoring"},"Logging and Monitoring"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"application monitoring or health checks are built-in",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g.: TCP, HTTP, container execution health checks are available out of the box"))),(0,l.kt)("li",{parentName:"ul"},"have health checks to give status of the nodes",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"failures are monitored by node controller"))),(0,l.kt)("li",{parentName:"ul"},"Kubernetes status can also be monitored via add-ons",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g.: Metrics Server, cAdvisors and Prometheus, Heapster"))),(0,l.kt)("li",{parentName:"ul"},"can use built-in logging frameworks or use your own")),(0,l.kt)("h3",{id:"secrets-management"},"Secrets Management"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"sensitive data is first class citizen"),(0,l.kt)("li",{parentName:"ul"},"secrets are mounted as data volumes or environment variables"),(0,l.kt)("li",{parentName:"ul"},"it is specific to a single namespace",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"thus they aren't shared across all applications")))),(0,l.kt)("h2",{id:"kubernetes-basics"},"Kubernetes: basics"),(0,l.kt)("h3",{id:"kubernetes-cluster-architecture"},"Kubernetes cluster architecture"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Kubernetes Cluster Architecture",src:a(67730).Z,width:"1714",height:"898"})),(0,l.kt)("h4",{id:"master-node"},"master node"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"responsible for overall management of the Kubernetes cluster"),(0,l.kt)("li",{parentName:"ul"},"has 3 components that takes care of communication, scheduling, and controllers",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"API Server",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"allows you to interact with the Kubernetes PAI"),(0,l.kt)("li",{parentName:"ul"},"its the front end of the Kubernetes control plane"))),(0,l.kt)("li",{parentName:"ol"},"Scheduler",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it watches created ",(0,l.kt)("inlineCode",{parentName:"li"},"Pods")," who do not have a Node design yet"),(0,l.kt)("li",{parentName:"ul"},"designs the ",(0,l.kt)("inlineCode",{parentName:"li"},"Pod")," to run on a specific Node"))),(0,l.kt)("li",{parentName:"ol"},"Controller Manager",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it runs controllers",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"they are background threads that run tasks in a cluster"))),(0,l.kt)("li",{parentName:"ul"},"has a bunch of different roles compiled into a single binary",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"roles include",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Node Controller: responsible for the worker states"),(0,l.kt)("li",{parentName:"ul"},"Replication Controller: responsible for maintaining the correct number of Pods for the replicater controllers"),(0,l.kt)("li",{parentName:"ul"},"End-Point Controller: joins services and Pods together"),(0,l.kt)("li",{parentName:"ul"},"Service account and Token Controller: handle access management")))))))))),(0,l.kt)("h4",{id:"etcd"},"etcd"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a simple distributed key value store"),(0,l.kt)("li",{parentName:"ul"},"Kubernetes uses it as a database, and stores all cluster data here",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"store informatione examples",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"job scheduling info, pod details, stage information, etc.")))))),(0,l.kt)("h4",{id:"kubectl"},"kubectl"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"interact with ",(0,l.kt)("inlineCode",{parentName:"li"},"master node")," with ",(0,l.kt)("inlineCode",{parentName:"li"},"kubectl")),(0,l.kt)("li",{parentName:"ul"},"it is the command line interface for kubernetes"),(0,l.kt)("li",{parentName:"ul"},"has a ",(0,l.kt)("inlineCode",{parentName:"li"},"kubeconfig")," config file",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"has server information"),(0,l.kt)("li",{parentName:"ul"},"has authentication information to access the API server")))),(0,l.kt)("h4",{id:"worker-nodes"},"worker nodes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"are nodes where the applications operate"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"kubelet")," process",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it communicates with the master node"),(0,l.kt)("li",{parentName:"ul"},"it is an agent that communicates with the API server to see if ",(0,l.kt)("inlineCode",{parentName:"li"},"Pods")," have been designed to the Nodes"),(0,l.kt)("li",{parentName:"ul"},"it executes ",(0,l.kt)("inlineCode",{parentName:"li"},"Pod")," containers via the ",(0,l.kt)("inlineCode",{parentName:"li"},"container engine")),(0,l.kt)("li",{parentName:"ul"},"it mounts and runt ",(0,l.kt)("inlineCode",{parentName:"li"},"Pod")," volume and secrets"),(0,l.kt)("li",{parentName:"ul"},"it is aware of ",(0,l.kt)("inlineCode",{parentName:"li"},"Pod")," of Node states and responds back to the ",(0,l.kt)("inlineCode",{parentName:"li"},"Master")))),(0,l.kt)("li",{parentName:"ul"},"kubernetes is a container orchestrator",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"expectation is that you have a container native platform running on the ",(0,l.kt)("inlineCode",{parentName:"li"},"worker nodes"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"this is where ",(0,l.kt)("inlineCode",{parentName:"li"},"Docker")," is used to work together with ",(0,l.kt)("inlineCode",{parentName:"li"},"Kubelet")," to run containers on the Node"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"kube-proxy"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it is the network proxy and load balancer for the service on a single worker node"),(0,l.kt)("li",{parentName:"ul"},"it handles the network routing for TCP and UDP Packlets, and performs connection forwarding"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Docker")," daemon",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"allows running of ",(0,l.kt)("inlineCode",{parentName:"li"},"containers"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"containers of an application are tightly coupled together in a ",(0,l.kt)("inlineCode",{parentName:"li"},"Pod"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Pod")," is a the smallest unit that can be scheduled as a deployment in Kubernetes"),(0,l.kt)("li",{parentName:"ul"},"this group of containers share storage, Linux name space, IP addresses"),(0,l.kt)("li",{parentName:"ul"},"it is also co-located and share resources that are always scheduled together"),(0,l.kt)("li",{parentName:"ul"},"once ",(0,l.kt)("inlineCode",{parentName:"li"},"Pods")," have been deployed and running, the ",(0,l.kt)("inlineCode",{parentName:"li"},"kubelet")," process communicates with the ",(0,l.kt)("inlineCode",{parentName:"li"},"pods")," to check on state and health",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"kube-proxy")," will route any packets to the Pods from other resources that might want communication"))))))))),(0,l.kt)("li",{parentName:"ul"},"worker nodes can be exposed to the internvet via ",(0,l.kt)("inlineCode",{parentName:"li"},"load balancer")),(0,l.kt)("li",{parentName:"ul"},"traffic coming into the Nodes are handled by ",(0,l.kt)("inlineCode",{parentName:"li"},"Kube-proxy"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"this is how end-users talk to kubernetes application")))),(0,l.kt)("h3",{id:"nodes-and-pods"},"Nodes and Pods"),(0,l.kt)("h4",{id:"node"},"Node"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"it serves as a worker machine is a kubernetes cluster"),(0,l.kt)("li",{parentName:"ul"},"it can be a physical computer or a virtual machine"),(0,l.kt)("li",{parentName:"ul"},"requirements",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"each node must have a ",(0,l.kt)("inlineCode",{parentName:"li"},"kubelet")," running"),(0,l.kt)("li",{parentName:"ul"},"container tooling like Docker"),(0,l.kt)("li",{parentName:"ul"},"a kube-proxy process running"),(0,l.kt)("li",{parentName:"ul"},"a process like ",(0,l.kt)("inlineCode",{parentName:"li"},"Supervisord")," so that it can restart components"))),(0,l.kt)("li",{parentName:"ul"},"recommendation",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"if using Kubernetes in a production like setting, recommended to have at least a 3 Node cluster")))),(0,l.kt)("h4",{id:"tool-minikube"},"Tool: Minikube"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a lightweight kubernetes implementation that creates a VM on local machine and deploys a simple cluser containing only 1 node")),(0,l.kt)("h4",{id:"pods"},"Pods"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"it is a simplest unit that you can interact with"),(0,l.kt)("li",{parentName:"ul"},"can create, deploy, and delete pods"),(0,l.kt)("li",{parentName:"ul"},"it represents 1 running process in the cluster"),(0,l.kt)("li",{parentName:"ul"},"inside a Pod",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"docker application container"),(0,l.kt)("li",{parentName:"ul"},"storage resources"),(0,l.kt)("li",{parentName:"ul"},"a unique network IP"),(0,l.kt)("li",{parentName:"ul"},"options that govern how the container should run"),(0,l.kt)("li",{parentName:"ul"},"in some scenarios",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"can have multiple docker containers running in a Pod",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"but a Pod represents 1 single unit of deployment, which is a single instance of an application in Kubernetes that is tightly coupled and shared resources"))))))),(0,l.kt)("li",{parentName:"ul"},"designed to be ephemeral, disposable entities"),(0,l.kt)("li",{parentName:"ul"},"don't need to create Pods just by themselves in a production application",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"only do that when need to test whether the underlying containers actually work"))),(0,l.kt)("li",{parentName:"ul"},"Pods don't self-heal",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it a Pod dies, it will not be reschedules"),(0,l.kt)("li",{parentName:"ul"},"if a Pod is exited from a Node because of lack of resources, it will not be restarted on different healthier Nodes"))),(0,l.kt)("li",{parentName:"ul"},"always use higher-level constructs",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it manages and adds stability to Pods, called controllers"),(0,l.kt)("li",{parentName:"ul"},"thus user a controller like a deployment and don't use a Pod directly"))),(0,l.kt)("li",{parentName:"ul"},"Pod States",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Pending"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Pod has been accepted by the Kubernete system, but a container has not been created yet"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Running"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"where a Pod has been scheduled on a Node, and all of its containers are created, and at least 1 container is in a running state"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Succeeded"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"all containers in the Pod have exited with an exit status of 0, indicating successful execution and will not be restarted"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Failed"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"all containers in the Pod have exited and at least 1 container has failed and returned a non 0 exit status"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"CrashLoopBackOff"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"where a container fails to start, and Kubernetes tries repeatedly to restart the Pod")))))),(0,l.kt)("h3",{id:"controllers"},"Controllers"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"pods are the basic building blocks in kubernets",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"but we should not use them by themselves and should use ",(0,l.kt)("inlineCode",{parentName:"li"},"controllers")," instead"))),(0,l.kt)("li",{parentName:"ul"},"benefits of controllers",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"application reliability"),": where multiple instances of an application running prevent problems if 1 or more instance fails"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"scaling"),": when the pods experience a high volume requests, kubernetes allows scaling up of the pods, allowing for a better user experience"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"load balancing"),": where having multiple versions of a pod running allow traffic to flow to different pods and doesn't overload 1 single pod or a node"))),(0,l.kt)("li",{parentName:"ul"},"types of controllers",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"ReplicaSets",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"ensures that the specified number of replicas for a pod are running at all times"),(0,l.kt)("li",{parentName:"ul"},"if the number of pods is less than what the Replicaset expects, for example when a pod crashed, it will start up a new pod"),(0,l.kt)("li",{parentName:"ul"},"however, it can't be declared by itself as it requires deployment to do so"))),(0,l.kt)("li",{parentName:"ul"},"Deployments",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"provides a declarative updates for pods and ReplicaSets",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it means that you can describe the desired state of a deployment in a ",(0,l.kt)("inlineCode",{parentName:"li"},"yaml")," file",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the deployment controller will align the actual state to match"))))),(0,l.kt)("li",{parentName:"ul"},"it can be defined to create new or replace existing ReplicaSets"),(0,l.kt)("li",{parentName:"ul"},"most applications are packages deployments, thus creating deployments are frequent"),(0,l.kt)("li",{parentName:"ul"},"it manages ReplicaSet, which manages a pod"),(0,l.kt)("li",{parentName:"ul"},"benefit is that it can automatically support a role-back mechanism"),(0,l.kt)("li",{parentName:"ul"},"a new ReplicaSet is created each time a new deployment config is deployed, but it also keeps the old ReplicaSet",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"thus allows easy roll back to old state if something didn't work correctly"))),(0,l.kt)("li",{parentName:"ul"},"ReplicaSets and Deployments controller were under the deprecated Replication Controller"),(0,l.kt)("li",{parentName:"ul"},"use cases",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pod management")," running a ReplicaSet allows us to deploy a number of pods and check their satus as a single unit"),(0,l.kt)("li",{parentName:"ul"},"scaling a ReplicaSet scales out the pods, and allows for the deployment to handle more traffic"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pause and resume"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"used with larger changesets"),(0,l.kt)("li",{parentName:"ul"},"pause deployment, make changes, resume deployment"),(0,l.kt)("li",{parentName:"ul"},"while a deployment is paused, it means that only updates are paused, but traffic will still get passed to the existing ReplicaSet"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"status")," to check the health of pods and identify issues"))))),(0,l.kt)("li",{parentName:"ul"},"DaemonSets",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"ensure all nodes run a copy of a specific pod"),(0,l.kt)("li",{parentName:"ul"},"as nodes are added or removed from the cluster, it will add or remove the required pods"),(0,l.kt)("li",{parentName:"ul"},"deleting a DaemonSet will also clean up all the pods that it created"))),(0,l.kt)("li",{parentName:"ul"},"Jobs",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it is a supervisor process for pods carrying out batch processes to completion"),(0,l.kt)("li",{parentName:"ul"},"as the pod completes successfully, the job tracks information about the completion state of the pod"),(0,l.kt)("li",{parentName:"ul"},"use to run individual processes that need to run once and complete successfully"),(0,l.kt)("li",{parentName:"ul"},"typically, jobs are run as a cron job to run a specific process at a specific time and repeat at another time"))),(0,l.kt)("li",{parentName:"ul"},"Services",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it provides network connectivity to 1 or more pods in the cluster"),(0,l.kt)("li",{parentName:"ul"},"when a service is created, it designed a unique IP address that never changes through the lifetime of the service"),(0,l.kt)("li",{parentName:"ul"},"Pods are then configured to talk to the service and can rely on the service IP on any requests that might be sent to the pod"),(0,l.kt)("li",{parentName:"ul"},"it is an important concept because they allow 1 set of pods to communicate with another set of pods in an easy way"),(0,l.kt)("li",{parentName:"ul"},"it is best practice to use a service when trying to get 2 deployments to talk to each other"),(0,l.kt)("li",{parentName:"ul"},"types of services",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"internal services, where an IP (cluster IP) is only reachable from within the cluster"),(0,l.kt)("li",{parentName:"ul"},"external services, where services running web servers, or publicly accessible pods, are exposed through an external endpoint",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"these endpoints are available on each node through a specific port (NodePort)"))),(0,l.kt)("li",{parentName:"ul"},"load balancer, for use cases when you want to expose your application to the public internet",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"only used when using kubernetes in a cloud environment backed by a cloud provider")))))))))),(0,l.kt)("h3",{id:"labels-selectors-and-namespaces"},"Labels, Selectors, and Namespaces"),(0,l.kt)("h4",{id:"labels"},"Labels"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"they are key value pairs that are attached to object like pods, services, and deployments"),(0,l.kt)("li",{parentName:"ul"},"for users of kubernetes to identify attributes for objects"),(0,l.kt)("li",{parentName:"ul"},"typically used to organize clusters in some meaningful way"),(0,l.kt)("li",{parentName:"ul"},"can be added at deployment time or later on and changed at any time"),(0,l.kt)("li",{parentName:"ul"},"examples",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"release: stable"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"release: canary")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"environemnt: dev"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"environemnt: qa"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"environemnt: production")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"tier: frontend"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"tier: backend"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"tier: cache")))),(0,l.kt)("li",{parentName:"ul"},"labels used with selectors gives a powerl feature",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"label selectors allow identification of a set of objects")))),(0,l.kt)("h4",{id:"selectors"},"Selectors"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Equality-based Selectors",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"=")," 2 labels or values of labels should be equal"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"!=")," the values of the labels should not be equal"))),(0,l.kt)("li",{parentName:"ol"},"Set-based Selectors",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"IN")," a value should be inside a set of defined values"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"NOTIN")," a value should not be in a set of defined values"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"EXISTS")," determines whether a label exists or not")))),(0,l.kt)("h4",{id:"namespaces"},"Namespaces"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"great for large enterprises"),(0,l.kt)("li",{parentName:"ul"},"allows teams to access resources with accountability"),(0,l.kt)("li",{parentName:"ul"},"great way to divide cluster resources between users"),(0,l.kt)("li",{parentName:"ul"},"provides scope for names-must be unique in the namespace"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Default")," namespace created when kubernete is launched"),(0,l.kt)("li",{parentName:"ul"},"objects placed in ",(0,l.kt)("inlineCode",{parentName:"li"},"default")," namespace at start"),(0,l.kt)("li",{parentName:"ul"},"newer applications install their resources in a different namespace")),(0,l.kt)("h3",{id:"kubelet-and-kube-proxy"},"Kubelet and Kube-proxy"),(0,l.kt)("h4",{id:"kubelet"},"Kubelet"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"it is the kubernetes node agent that runs on each node"),(0,l.kt)("li",{parentName:"ul"},"roles",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"communicates with API server to see if pods have been assigned to nodes"),(0,l.kt)("li",{parentName:"ul"},"executes pod containers via a container engine"),(0,l.kt)("li",{parentName:"ul"},"mounts and runs pod volumes and secrets"),(0,l.kt)("li",{parentName:"ul"},"executes health checks to identify pod/node status"))),(0,l.kt)("li",{parentName:"ul"},"it works via ",(0,l.kt)("inlineCode",{parentName:"li"},"Podspec")," which is a YAML file that describes a pod",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it takes a set of Podspec that are provided by the kube-api server and ensures that the containers described in those Podspecs are running and healthy"))),(0,l.kt)("li",{parentName:"ul"},"it only manages containers that were created by the API server",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"does not manages any container running on the node"))),(0,l.kt)("li",{parentName:"ul"},"we can manage kubelet without an API server by using a HTTP endpoint or a file")),(0,l.kt)("h4",{id:"kube-proxy-the-network-proxy"},"Kube-proxy: the network proxy"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a process that runs on all worker nodes"),(0,l.kt)("li",{parentName:"ul"},"it reflects services as defined on node, and can do simple network stream or round-robin forwarding across a set of backends"),(0,l.kt)("li",{parentName:"ul"},"service cluster IPs and ports are currently found through Docker --link compatible environment variables specifying ports opened by the service proxy"),(0,l.kt)("li",{parentName:"ul"},"has 3 modes",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"User space mode (most common)"),(0,l.kt)("li",{parentName:"ol"},"Iptables mode"),(0,l.kt)("li",{parentName:"ol"},"Ipvs mode (alpha feature)")),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"why modes are important",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"services defined against the API server: kube-proxy watches the API server for the addition and removal of services"),(0,l.kt)("li",{parentName:"ul"},"for each new service, kube-proxy opens a randomly chosen port on the local node"),(0,l.kt)("li",{parentName:"ul"},"connections made to the chosen port are proxied to 1 of the corresponding backend pods")))))),(0,l.kt)("h2",{id:"authentication-and-authorization"},"Authentication and Authorization"),(0,l.kt)("h3",{id:"2-kinds-of-users"},"2 kinds of users"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Normal users",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"humans interacting with the system"))),(0,l.kt)("li",{parentName:"ol"},"Service accounts",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"accounts managed by the K8s API")))),(0,l.kt)("h3",{id:"information-that-defines-a-user"},"Information that defines a User"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"username: a string to indentify the end user"),(0,l.kt)("li",{parentName:"ul"},"UID: an indentifier that is more consistent or unique than username"),(0,l.kt)("li",{parentName:"ul"},"group: a string that associates users with a set of commonly grouped users",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"used later by the authorization module"))),(0,l.kt)("li",{parentName:"ul"},"extra fields: a map of strings that hold additional information that might be used by the authorization system")),(0,l.kt)("h3",{id:"definitions"},"Definitions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Authentication: does a user have access to the system"),(0,l.kt)("li",{parentName:"ul"},"Authorization: can the user perform an action in the system")),(0,l.kt)("h3",{id:"popular-authentication-modules"},"Popular Authentication Modules"),(0,l.kt)("h4",{id:"client-certificate-authentication"},"Client Certificate Authentication"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"client certificate authentication enabled by passing the ",(0,l.kt)("inlineCode",{parentName:"li"},"--client-ca-file=FILENAME")," option to the API server"),(0,l.kt)("li",{parentName:"ul"},"referenced file must contain 1 or more certificate authorities to validate client certificates"),(0,l.kt)("li",{parentName:"ul"},"the common name of a client certificate is used as the username for the request")),(0,l.kt)("h4",{id:"static-token-files-static-password-file"},"Static token files (static password file)"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Token File Example"),(0,l.kt)("li",{parentName:"ul"},"use ",(0,l.kt)("inlineCode",{parentName:"li"},"--token-auth-file=FILE_WITH_TOKENS")," option on the command line"),(0,l.kt)("li",{parentName:"ul"},"token file is a CSV file with 4 columns: token, username, user UID, followed by optional group names",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},'e.g.: token,user,uid,"group1, group2,group3"')))),(0,l.kt)("h4",{id:"openid-connect"},"OpenID Connect"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"if you already have Open ID or Active Directory in your org, take a look at OpenID Connect tokens")),(0,l.kt)("h4",{id:"webhook-tokens"},"Webhook tokens"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the kube-apiserver calls out to a service defined by you to tell it whether a token is valid or not"),(0,l.kt)("li",{parentName:"ul"},"used commonly in scenarios where you want to integrate Kubernetes with a remote authentication service")),(0,l.kt)("h3",{id:"popular-authorization-modules"},"Popular Authorization Modules"),(0,l.kt)("h4",{id:"abac-attribute-based-access-control"},"ABAC: Attribute-based access control"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"e.g. 1:",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "apiVersion": "abac.authorization.kubernetes.io/v1beta1",\n  "kind": "Policy",\n  "spec": {\n    "user": "karthik",\n    "namespace": "*",\n    "resource": "*",\n    "apiGroup": "*"\n  }\n}\n'))),(0,l.kt)("li",{parentName:"ul"},"e.g. 2:",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "apiVersion": "abac.authorization.kubernetes.io/v1beta1",\n  "kind": "Policy",\n  "spec": {\n    "user": "carisa",\n    "namespace": "*",\n    "resource": "*",\n    "apiGroup": "*",\n    "readonly": true\n  }\n}\n')))),(0,l.kt)("h4",{id:"rbac-role-based-access-control"},"RBAC: Role-based access control"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"does a user have a role that can perform a specific action?"),(0,l.kt)("li",{parentName:"ul"},"lots of application want to use RBAC",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"keep it turned on even if you don't use it directly"))),(0,l.kt)("li",{parentName:"ul"},"e.g.:",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},'kind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  namespace: default\n  name: pod-reader\nrules:\n  - apiGroups: [""] # "" indicates the core API group\n    resources: ["pods"]\n    verbs: ["get", "watch", "list"]\n'))),(0,l.kt)("li",{parentName:"ul"},"RoleBinding or ClusterRoleBinding",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},"get   <-                                                ->  User\n          Pod-reader Role  <-  Pod-reader Role Binding  ->  Group\nlist  <-                                                ->  Service Account\n")),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g.:",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},"kind: RoleBinding\napiVersion: brace.authorization.k8s.io/v1\nMetadata:\n  name: read-pods\n  Namespace: default\nsubjects:\n  kind: User\n  name: karthik\n  apiGroup: rbac.authroization.k8s.io\nroleRef:\n  kind: Role\n  name: pod-reader\n  apiGroup: rbac.authorization.k8s.io\n")))))),(0,l.kt)("h4",{id:"webhook-authorization-mode"},"Webhook Authorization Mode"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the kube-apiserver calls out to a service defined by you to tell it whether a specific action can be performed",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"it sends the token and the action the token is trying to perform"))),(0,l.kt)("li",{parentName:"ul"},"this method works great when trying to integrate with a 3rd party authorization system, or if you want a complex set of rules")),(0,l.kt)("h2",{id:"installation"},"Installation"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Install ",(0,l.kt)("inlineCode",{parentName:"li"},"kubectl"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"brew install kubectl"),(0,l.kt)("ul",{parentName:"blockquote"},(0,l.kt)("li",{parentName:"ul"},"verify installation\nkubectl version --client")))),(0,l.kt)("li",{parentName:"ul"},"Install ",(0,l.kt)("inlineCode",{parentName:"li"},"minikube"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"brew install minikube"),(0,l.kt)("ul",{parentName:"blockquote"},(0,l.kt)("li",{parentName:"ul"},"verify installation\nminikube version"))))),(0,l.kt)("h2",{id:"yaml-file"},"Yaml file"),(0,l.kt)("h3",{id:"application-health-checks"},"application health checks"),(0,l.kt)("h4",{id:"readinessprobe"},"readinessProbe"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"detects when a container can accept traffic"),(0,l.kt)("li",{parentName:"ul"},"good readinessProd example",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: helloworld-deployment-with-probe\nspec:\n  selector:\n    matchLabels:\n      app: helloworld\n  replicas: 1 # tells deployment to run 1 pods matching the template\n  template: # create pods using pod definition in this template\n    metadata:\n      labels:\n        app: helloworld\n    spec:\n      containers:\n        - name: helloworld\n          image: karthequian/helloworld:latest\n          ports:\n            - containerPort: 80\n          readinessProbe:\n            # length of time to wait for a pod to initialize\n            # after pod startup, before applying health checking\n            initialDelaySeconds: 5\n            # Amount of time to wait before timing out\n            timeoutSeconds: 1\n            # Probe for http\n            httpGet:\n              # Path to probe\n              path: /\n              # Port to probe\n              port: 80\n"))),(0,l.kt)("li",{parentName:"ul"},"bad readinessProd example",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: helloworld-deployment-with-bad-readiness-probe\nspec:\n  selector:\n    matchLabels:\n      app: helloworld\n  replicas: 1 # tells deployment to run 1 pods matching the template\n  template: # create pods using pod definition in this template\n    metadata:\n      labels:\n        app: helloworld\n    spec:\n      containers:\n        - name: helloworld\n          image: karthequian/helloworld:latest\n          ports:\n            - containerPort: 80\n          readinessProbe:\n            # length of time to wait for a pod to initialize\n            # after pod startup, before applying health checking\n            initialDelaySeconds: 5\n            # Amount of time to wait before timing out\n            timeoutSeconds: 1\n            # Probe for http\n            httpGet:\n              # Path to probe\n              path: /\n              # Port to probe\n              port: 90\n")))),(0,l.kt)("h4",{id:"livenessprobe"},"livenessProbe"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"checks whether the container is alive and running"),(0,l.kt)("li",{parentName:"ul"},"good livenessProbe example",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: helloworld-deployment-with-probe\nspec:\n  selector:\n    matchLabels:\n      app: helloworld\n  replicas: 1 # tells deployment to run 1 pods matching the template\n  template: # create pods using pod definition in this template\n    metadata:\n      labels:\n        app: helloworld\n    spec:\n      containers:\n        - name: helloworld\n          image: karthequian/helloworld:latest\n          ports:\n            - containerPort: 80\n          livenessProbe:\n            # length of time to wait for a pod to initialize\n            # after pod startup, before applying health checking\n            initialDelaySeconds: 5\n            # Amount of time to wait before timing out\n            timeoutSeconds: 1\n            # Probe for http\n            httpGet:\n              # Path to probe\n              path: /\n              # Port to probe\n              port: 80\n"))),(0,l.kt)("li",{parentName:"ul"},"bad livenessProbe example",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: helloworld-deployment-with-bad-liveness-probe\nspec:\n  selector:\n    matchLabels:\n      app: helloworld\n  replicas: 1 # tells deployment to run 1 pods matching the template\n  template: # create pods using pod definition in this template\n    metadata:\n      labels:\n        app: helloworld\n    spec:\n      containers:\n        - name: helloworld\n          image: karthequian/helloworld:latest\n          ports:\n            - containerPort: 80\n          livenessProbe:\n            # length of time to wait for a pod to initialize\n            # after pod startup, before applying health checking\n            initialDelaySeconds: 5\n            # How often (in seconds) to perform the probe.\n            periodSeconds: 5\n            # Amount of time to wait before timing out\n            timeoutSeconds: 1\n            # Kubernetes will try failureThreshold times before giving up and restarting the Pod\n            failureThreshold: 2\n            # Probe for http\n            httpGet:\n              # Path to probe\n              path: /\n              # Port to probe\n              port: 90\n")))),(0,l.kt)("h2",{id:"commands"},"Commands"),(0,l.kt)("h3",{id:"verify-if-cluster-is-up-and-running"},"verify if cluster is up and running"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get nodes")),(0,l.kt)("h3",{id:"see-what-is-in-the-cluster"},"see what is in the cluster"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get all")),(0,l.kt)("h3",{id:"create-deployment-service-pod"},"create deployment, service, pod"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"use ",(0,l.kt)("inlineCode",{parentName:"li"},"--record")," flag to record the rollout history",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"currently deprecated and will be removed in the future",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl create -f filename.yaml"))))),(0,l.kt)("li",{parentName:"ul"},"pod yaml file example",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: v1\nkind: Pod\nmetadata:\n  name: helloworld\n  labels:\n    env: production\n    author: karthequian\n    application_type: ui\n    release-version: "1.0"\nspec:\n  containers:\n    - name: helloworld\n      image: karthequian/helloworld:latest\n'))),(0,l.kt)("li",{parentName:"ul"},"deployment yaml file example",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"# Helloworld application- just the deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: helloworld-deployment\nspec:\n  selector:\n    matchLabels:\n      app: helloworld\n  replicas: 1 # tells deployment to run 1 pods matching the template\n  template: # create pods using pod definition in this template\n    metadata:\n      labels:\n        app: helloworld\n    spec:\n      containers:\n        - name: helloworld\n          image: karthequian/helloworld:latest\n          ports:\n            - containerPort: 80\n"))),(0,l.kt)("li",{parentName:"ul"},"service yaml file example",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"# Helloworld service for nodeports\napiVersion: v1\nkind: Service\nmetadata:\n  name: helloworld-service\nspec:\n  type: NodePort\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 80\n  selector:\n    app: helloworld\n"))),(0,l.kt)("li",{parentName:"ul"},"multiple files together (e.g.: deployment and service)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"use ",(0,l.kt)("inlineCode",{parentName:"li"},"---")," to separate different files")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: helloworld-all-deployment\nspec:\n  selector:\n    matchLabels:\n      app: helloworld\n  replicas: 1 # tells deployment to run 1 pods matching the template\n  template: # create pods using pod definition in this template\n    metadata:\n      labels:\n        app: helloworld\n    spec:\n      containers:\n        - name: helloworld\n          image: karthequian/helloworld:latest\n          ports:\n            - containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: helloworld-all-service\nspec:\n  type: NodePort\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 80\n  selector:\n    app: helloworld\n")))),(0,l.kt)("h3",{id:"update-deployment"},"update deployment"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"update an image",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl set image deployment/deploymentname containername=newimagename")))),(0,l.kt)("h3",{id:"deletion"},"deletion"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"delete a deployment",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl delete deploy deploymentname"))),(0,l.kt)("li",{parentName:"ul"},"delete a service",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl delete svc servicename"))),(0,l.kt)("li",{parentName:"ul"},"delete a pod",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl delete pod podname"),(0,l.kt)("ul",{parentName:"blockquote"},(0,l.kt)("li",{parentName:"ul"},"delete pods via label\nkubectl delete pods -l labelkey=labelvalue"))))),(0,l.kt)("h3",{id:"expose-deployment-as-a-service"},"expose deployment as a service"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl expose deployment appname --type=NodePort")),(0,l.kt)("h3",{id:"view-deployments"},"view deployments"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get deployments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"get deployment details with ",(0,l.kt)("inlineCode",{parentName:"li"},"describe"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl describe deployment deploymentname")))),(0,l.kt)("h3",{id:"introspect-a-deployment"},"introspect a deployment"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get deployment/helloworld -o yaml")),(0,l.kt)("h3",{id:"view-services"},"view services"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get services")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"get service details with ",(0,l.kt)("inlineCode",{parentName:"li"},"describe"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl describe service servicename")))),(0,l.kt)("h3",{id:"introspect-a-service"},"introspect a service"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get service/helloworld -o yaml")),(0,l.kt)("h3",{id:"view-pods"},"view pods"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get pods")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"show labels using ",(0,l.kt)("inlineCode",{parentName:"li"},"--show-labels")," flag",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl get pods --show-labels"))),(0,l.kt)("li",{parentName:"ul"},"get filtered list of pods via labels with ",(0,l.kt)("inlineCode",{parentName:"li"},"--selector")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"-l")," flag",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl get pods --selector labelkey=labelvalue"),(0,l.kt)("ul",{parentName:"blockquote"},(0,l.kt)("li",{parentName:"ul"},"using multi labels\nkubectl get pods --selector labelkey1=labelvalue1,labelkey2=labelvalue2"),(0,l.kt)("li",{parentName:"ul"},"using ",(0,l.kt)("inlineCode",{parentName:"li"},"in")," operator",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},'e.g.: search for release version between 1.0 to 2.0\nkubectl get pods -l "release-version in (1.0,2.0)"'))),(0,l.kt)("li",{parentName:"ul"},"using ",(0,l.kt)("inlineCode",{parentName:"li"},"notin")," operator",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},'e.g.: search for release version not in 1.0 to 2.0\nkubectl get pods -l "release-version notin (1.0,2.0)"')))))),(0,l.kt)("li",{parentName:"ul"},"get pod details with ",(0,l.kt)("inlineCode",{parentName:"li"},"describe"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"method 1",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl describe po/podname"))),(0,l.kt)("li",{parentName:"ul"},"method 2",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl describe pod podname"))))),(0,l.kt)("li",{parentName:"ul"},"get pod logs",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl logs podname"))),(0,l.kt)("li",{parentName:"ul"},"enter the pod",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl exec podname -it /bin/bash"),(0,l.kt)("ul",{parentName:"blockquote"},(0,l.kt)("li",{parentName:"ul"},"enter the pod for a specific container\nkubectl exec podname -it -c containername /bin/bash"))))),(0,l.kt)("h3",{id:"view-replicasets"},"view replicaSets"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get rs")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"get replicatSets details with ",(0,l.kt)("inlineCode",{parentName:"li"},"describe"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl describe rs replicasetname"))),(0,l.kt)("li",{parentName:"ul"},"scale replicas",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl scale -n namespacename deployment deploymentname --replicas=numberofreplicas")))),(0,l.kt)("h3",{id:"modifying-labels-after-deployment"},"Modifying labels after deployment"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"pods",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"add or modify label",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl label po/podname app=newlabelname --overwrite"))),(0,l.kt)("li",{parentName:"ul"},"delete label using ",(0,l.kt)("inlineCode",{parentName:"li"},"-"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl label pod/podname labelname-")))))),(0,l.kt)("h3",{id:"view-rollout-history"},"view rollout history"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl rollout history deployment/deploymentname")),(0,l.kt)("h3",{id:"revert-changes"},"revert changes"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl rollout undo deployment/deploymentname")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"revert to a specific revision number with ",(0,l.kt)("inlineCode",{parentName:"li"},"--to-revision")," flag",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl rollout undo deployment/deploymentname --to-revision=revisionnumber")))),(0,l.kt)("h3",{id:"configmap"},"configmap"),(0,l.kt)("h4",{id:"create-configmap"},"create configmap"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"this will pass the ",(0,l.kt)("inlineCode",{parentName:"li"},"configmapkeyname=debug")," to the actual container as an environment variable",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl create configmap configmapname --from-literal=configmapkeyname=debug"))),(0,l.kt)("li",{parentName:"ul"},"must have a yaml file similar to the following",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: logreader-dynamic\n  labels:\n    app: logreader-dynamic\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: logreader-dynamic\n  template:\n    metadata:\n      labels:\n        app: logreader-dynamic\n    spec:\n      containers:\n        - name: logreader\n          image: karthequian/reader:latest\n          env:\n            - name: configmapkeyname\n              valueFrom:\n                configMapKeyRef:\n                  name: configmapname #Read from a configmap called log-level\n                  key: configmapkeyname #Read the key called log_level\n")))),(0,l.kt)("h4",{id:"view-configmap"},"view configmap"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get configmaps")),(0,l.kt)("h4",{id:"introspect-a-configmap"},"introspect a configmap"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get configmap/configmapname -o yaml")),(0,l.kt)("h3",{id:"handling-application-secrets"},"handling application secrets"),(0,l.kt)("h4",{id:"create-a-secret"},"create a secret"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl create secret generic secretname --from-literal=secretkeyname=secretkeyvalue")),(0,l.kt)("h4",{id:"view-secret-list"},"view secret list"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get secrets")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"view a specific secret",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl get secret secretname"))),(0,l.kt)("li",{parentName:"ul"},"introspect secret",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the secret key value is encoded in the base 64 format",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl get secret secretname -o yaml"))))),(0,l.kt)("li",{parentName:"ul"},"get secret key value in applications example",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"after deployment, secret key value can be retrieved via logs")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: secretreader\n  labels:\n    name: secretreader\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      name: secretreader\n  template:\n    metadata:\n      labels:\n        name: secretreader\n    spec:\n      containers:\n        - name: secretreader\n          image: karthequian/secretreader:latest\n          env:\n            - name: secretkeyname\n              valueFrom:\n                secretKeyRef:\n                  name: secretname\n                  key: secretkeyname\n")))),(0,l.kt)("h3",{id:"running-jobs"},"running jobs"),(0,l.kt)("h4",{id:"simple-jobs"},"simple jobs"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"view jobs",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl get jobs"))),(0,l.kt)("li",{parentName:"ul"},"need to have the following example",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"create job")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: finalcountdown\nspec:\n  template:\n    metadata:\n      name: finalcountdown\n    spec:\n      containers:\n        - name: counter\n          image: busybox\n          command:\n            - bin/sh\n            - -c\n            - "for i in 9 8 7 6 5 4 3 2 1 ; do echo $i ; done"\n      restartPolicy: Never #could also be Always or OnFailure\n')))),(0,l.kt)("h4",{id:"cron-jobs"},"cron jobs"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"view cron jobs",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl get cronjob"))),(0,l.kt)("li",{parentName:"ul"},"need to have the following example",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"create job")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: batch/v1beta1\nkind: CronJob\nmetadata:\n  name: hellocron\nspec:\n  schedule: "*/1 * * * *" #Runs every minute (cron syntax) or @hourly.\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n            - name: hellocron\n              image: busybox\n              args:\n                - /bin/sh\n                - -c\n                - date; echo Hello from your Kubernetes cluster\n          restartPolicy: OnFailure #could also be Always or Never\n  suspend: false #Set to true if you want to suspend in the future\n')),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"this is create a new job each time it runs",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"view the new job with",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl get jobs"))))))),(0,l.kt)("li",{parentName:"ul"},"edit cronjob",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"kubectl edit cronjobs/cronjobname"))),(0,l.kt)("li",{parentName:"ul"},"pause/stop a cronjob",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"edit cronjob"),(0,l.kt)("li",{parentName:"ul"},"modify ",(0,l.kt)("inlineCode",{parentName:"li"},"suspend: false")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"suspend: true"))))),(0,l.kt)("h3",{id:"daemonset"},"daemonset"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"need create the following example",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: example-daemonset\n  namespace: default\n  labels:\n    k8s-app: example-daemonset\nspec:\n  selector:\n    matchLabels:\n      name: example-daemonset\n  template:\n    metadata:\n      labels:\n        name: example-daemonset\n    spec:\n      #nodeSelector: minikube # Specify if you want to run on specific nodes\n      containers:\n        - name: example-daemonset\n          image: busybox\n          args:\n            - /bin/sh\n            - -c\n            - date; sleep 1000\n          resources:\n            limits:\n              memory: 200Mi\n            requests:\n              cpu: 100m\n              memory: 200Mi\n      terminationGracePeriodSeconds: 30\n"))),(0,l.kt)("li",{parentName:"ul"},"set infra as development",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"if DaemonSet is not running, it means that there isn't any development nodes running",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the Node Selector watches for the ",(0,l.kt)("inlineCode",{parentName:"li"},"infra=development")," label and only runs on nodes with that label")))),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: example-daemonset2\n  namespace: default\n  labels:\n    k8s-app: example-daemonset2\nspec:\n  selector:\n    matchLabels:\n      name: example-daemonset2\n  template:\n    metadata:\n      labels:\n        name: example-daemonset2\n    spec:\n      containers:\n        - name: example-daemonset2\n          image: busybox\n          args:\n            - /bin/sh\n            - -c\n            - date; sleep 1000\n          resources:\n            limits:\n              memory: 200Mi\n            requests:\n              cpu: 100m\n              memory: 200Mi\n      terminationGracePeriodSeconds: 30\n      nodeSelector:\n        infra: "development"\n'))),(0,l.kt)("li",{parentName:"ul"},"set infra as production",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"if DaemonSet is not running, it means that there isn't any production nodes running",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the Node Selector watches for the ",(0,l.kt)("inlineCode",{parentName:"li"},"infra=production")," label and only runs on nodes with that label")))),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: prod-daemonset\n  namespace: default\n  labels:\n    k8s-app: prod-daemonset\nspec:\n  selector:\n    matchLabels:\n      name: prod-daemonset\n  template:\n    metadata:\n      labels:\n        name: prod-daemonset\n    spec:\n      containers:\n        - name: prod-daemonset\n          image: busybox\n          args:\n            - /bin/sh\n            - -c\n            - date; sleep 1000\n          resources:\n            limits:\n              memory: 200Mi\n            requests:\n              cpu: 100m\n              memory: 200Mi\n      terminationGracePeriodSeconds: 30\n      nodeSelector:\n        infra: "production"\n')))),(0,l.kt)("h4",{id:"view-daemonsets"},"view daemonsets"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get daemonsets")),(0,l.kt)("h3",{id:"stateful-set"},"stateful set"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"example",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: v1\nkind: Service\nmetadata:\n  name: zk-hs\n  labels:\n    app: zk\nspec:\n  ports:\n    - port: 2888\n      name: server\n    - port: 3888\n      name: leader-election\n  clusterIP: None\n  selector:\n    app: zk\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: zk-cs\n  labels:\n    app: zk\nspec:\n  ports:\n    - port: 2181\n      name: client\n  selector:\n    app: zk\n---\napiVersion: policy/v1beta1\nkind: PodDisruptionBudget\nmetadata:\n  name: zk-pdb\nspec:\n  selector:\n    matchLabels:\n      app: zk\n  maxUnavailable: 1\n---\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: zk\nspec:\n  selector:\n    matchLabels:\n      app: zk\n  serviceName: zk-hs\n  replicas: 3\n  updateStrategy:\n    type: RollingUpdate\n  podManagementPolicy: OrderedReady\n  template:\n    metadata:\n      labels:\n        app: zk\n    spec:\n      affinity:\n        podAntiAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            - labelSelector:\n                matchExpressions:\n                  - key: "app"\n                    operator: In\n                    values:\n                      - zk\n              topologyKey: "kubernetes.io/hostname"\n      containers:\n        - name: kubernetes-zookeeper\n          imagePullPolicy: Always\n          image: "k8s.gcr.io/kubernetes-zookeeper:1.0-3.4.10"\n          resources:\n            requests:\n              memory: "1Gi"\n              cpu: "0.5"\n          ports:\n            - containerPort: 2181\n              name: client\n            - containerPort: 2888\n              name: server\n            - containerPort: 3888\n              name: leader-election\n          command:\n            - sh\n            - -c\n            - "start-zookeeper \\\n              --servers=3 \\\n              --data_dir=/var/lib/zookeeper/data \\\n              --data_log_dir=/var/lib/zookeeper/data/log \\\n              --conf_dir=/opt/zookeeper/conf \\\n              --client_port=2181 \\\n              --election_port=3888 \\\n              --server_port=2888 \\\n              --tick_time=2000 \\\n              --init_limit=10 \\\n              --sync_limit=5 \\\n              --heap=512M \\\n              --max_client_cnxns=60 \\\n              --snap_retain_count=3 \\\n              --purge_interval=12 \\\n              --max_session_timeout=40000 \\\n              --min_session_timeout=4000 \\\n              --log_level=INFO"\n          readinessProbe:\n            exec:\n              command:\n                - sh\n                - -c\n                - "zookeeper-ready 2181"\n            initialDelaySeconds: 10\n            timeoutSeconds: 5\n          livenessProbe:\n            exec:\n              command:\n                - sh\n                - -c\n                - "zookeeper-ready 2181"\n            initialDelaySeconds: 10\n            timeoutSeconds: 5\n          volumeMounts:\n            - name: datadir\n              mountPath: /var/lib/zookeeper\n      securityContext:\n        runAsUser: 1000\n        fsGroup: 1000\n  volumeClaimTemplates:\n    - metadata:\n        name: datadir\n      spec:\n        accessModes: ["ReadWriteOnce"]\n        resources:\n          requests:\n            storage: 10Gi\n')))),(0,l.kt)("h4",{id:"view-stateful-sets"},"view stateful sets"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get statefulsets")),(0,l.kt)("h3",{id:"namespaces-1"},"namespaces"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"add ",(0,l.kt)("inlineCode",{parentName:"li"},"-n")," flag followed by the namespacename when deploying a resource to a specific namespace",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"adding the flag will make the resource exist in the namespace")))),(0,l.kt)("h4",{id:"view-namespaces"},"view namespaces"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl get namespaces")),(0,l.kt)("h4",{id:"create-namespace"},"create namespace"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl create namespace namespacename")),(0,l.kt)("h4",{id:"delete-namespace"},"delete namespace"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"kubectl delete namespace namespacename")))}m.isMDXComponent=!0},67730:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/kubernetesClusterArchitecture-9d954e69f648090979fede4722daeb2b.png"},80583:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/orchestratorGuidelines-147f88bb370d642ea372588bdd1a0561.png"}}]);