"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[42841],{3905:(t,e,n)=>{n.d(e,{Zo:()=>d,kt:()=>p});var r=n(67294);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function o(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,r,a=function(t,e){if(null==t)return{};var n,r,a={},i=Object.keys(t);for(r=0;r<i.length;r++)n=i[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(r=0;r<i.length;r++)n=i[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var c=r.createContext({}),m=function(t){var e=r.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):o(o({},e),t)),n},d=function(t){var e=m(t.components);return r.createElement(c.Provider,{value:e},t.children)},l={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},u=r.forwardRef((function(t,e){var n=t.components,a=t.mdxType,i=t.originalType,c=t.parentName,d=s(t,["components","mdxType","originalType","parentName"]),u=m(n),p=a,g=u["".concat(c,".").concat(p)]||u[p]||l[p]||i;return n?r.createElement(g,o(o({ref:e},d),{},{components:n})):r.createElement(g,o({ref:e},d))}));function p(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=t,s.mdxType="string"==typeof t?t:a,o[1]=s;for(var m=2;m<i;m++)o[m]=n[m];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},50552:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var r=n(83117),a=(n(67294),n(3905));const i={},o="C++ Example",s={unversionedId:"interviewPrep/designPatterns/Behavioral_patterns/Memento/cPlusPlus/readme",id:"interviewPrep/designPatterns/Behavioral_patterns/Memento/cPlusPlus/readme",title:"C++ Example",description:"",source:"@site/docs/interviewPrep/designPatterns/Behavioral_patterns/Memento/cPlusPlus/readme.md",sourceDirName:"interviewPrep/designPatterns/Behavioral_patterns/Memento/cPlusPlus",slug:"/interviewPrep/designPatterns/Behavioral_patterns/Memento/cPlusPlus/",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Memento/cPlusPlus/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Behavioral_patterns/Memento/cPlusPlus/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Memento",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Memento/"},next:{title:"C# Example",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Memento/cSharp/"}},c={},m=[],d={toc:m};function l(t){let{components:e,...n}=t;return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"c-example"},"C++ Example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <string>\n#include <vector>\n\n/**\n * Memento Design Pattern\n *\n * Intent: Lets you save and restore the previous state of an object without\n * revealing the details of its implementation.\n */\n\n/**\n * The Memento interface provides a way to retrieve the memento\'s metadata, such\n * as creation date or name. However, it doesn\'t expose the Originator\'s state.\n */\nclass Memento {\n public:\n  virtual std::string GetName() const = 0;\n  virtual std::string date() const = 0;\n  virtual std::string state() const = 0;\n};\n\n/**\n * The Concrete Memento contains the infrastructure for storing the Originator\'s\n * state.\n */\nclass ConcreteMemento : public Memento {\n private:\n  std::string state_;\n  std::string date_;\n\n public:\n  ConcreteMemento(std::string state) : state_(state) {\n    this->state_ = state;\n    std::time_t now = std::time(0);\n    this->date_ = std::ctime(&now);\n  }\n  /**\n   * The Originator uses this method when restoring its state.\n   */\n  std::string state() const override {\n    return this->state_;\n  }\n  /**\n   * The rest of the methods are used by the Caretaker to display metadata.\n   */\n  std::string GetName() const override {\n    return this->date_ + " / (" + this->state_.substr(0, 9) + "...)";\n  }\n  std::string date() const override {\n    return this->date_;\n  }\n};\n\n/**\n * The Originator holds some important state that may change over time. It also\n * defines a method for saving the state inside a memento and another method for\n * restoring the state from it.\n */\nclass Originator {\n  /**\n   * @var string For the sake of simplicity, the originator\'s state is stored\n   * inside a single variable.\n   */\n private:\n  std::string state_;\n\n  std::string GenerateRandomString(int length = 10) {\n    const char alphanum[] =\n        "0123456789"\n        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"\n        "abcdefghijklmnopqrstuvwxyz";\n    int stringLength = sizeof(alphanum) - 1;\n\n    std::string random_string;\n    for (int i = 0; i < length; i++) {\n      random_string += alphanum[std::rand() % stringLength];\n    }\n    return random_string;\n  }\n\n public:\n  Originator(std::string state) : state_(state) {\n    std::cout << "Originator: My initial state is: " << this->state_ << "\\n";\n  }\n  /**\n   * The Originator\'s business logic may affect its internal state. Therefore,\n   * the client should backup the state before launching methods of the business\n   * logic via the save() method.\n   */\n  void DoSomething() {\n    std::cout << "Originator: I\'m doing something important.\\n";\n    this->state_ = this->GenerateRandomString(30);\n    std::cout << "Originator: and my state has changed to: " << this->state_ << "\\n";\n  }\n\n  /**\n   * Saves the current state inside a memento.\n   */\n  Memento *Save() {\n    return new ConcreteMemento(this->state_);\n  }\n  /**\n   * Restores the Originator\'s state from a memento object.\n   */\n  void Restore(Memento *memento) {\n    this->state_ = memento->state();\n    std::cout << "Originator: My state has changed to: " << this->state_ << "\\n";\n  }\n};\n\n/**\n * The Caretaker doesn\'t depend on the Concrete Memento class. Therefore, it\n * doesn\'t have access to the originator\'s state, stored inside the memento. It\n * works with all mementos via the base Memento interface.\n */\nclass Caretaker {\n  /**\n   * @var Memento[]\n   */\n private:\n  std::vector<Memento *> mementos_;\n\n  /**\n   * @var Originator\n   */\n  Originator *originator_;\n\n public:\n  Caretaker(Originator *originator) : originator_(originator) {\n    this->originator_ = originator;\n  }\n\n  void Backup() {\n    std::cout << "\\nCaretaker: Saving Originator\'s state...\\n";\n    this->mementos_.push_back(this->originator_->Save());\n  }\n  void Undo() {\n    if (!this->mementos_.size()) {\n      return;\n    }\n    Memento *memento = this->mementos_.back();\n    this->mementos_.pop_back();\n    std::cout << "Caretaker: Restoring state to: " << memento->GetName() << "\\n";\n    try {\n      this->originator_->Restore(memento);\n    } catch (...) {\n      this->Undo();\n    }\n  }\n  void ShowHistory() const {\n    std::cout << "Caretaker: Here\'s the list of mementos:\\n";\n    for (Memento *memento : this->mementos_) {\n      std::cout << memento->GetName() << "\\n";\n    }\n  }\n};\n/**\n * Client code.\n */\n\nvoid ClientCode() {\n  Originator *originator = new Originator("Super-duper-super-puper-super.");\n  Caretaker *caretaker = new Caretaker(originator);\n  caretaker->Backup();\n  originator->DoSomething();\n  caretaker->Backup();\n  originator->DoSomething();\n  caretaker->Backup();\n  originator->DoSomething();\n  std::cout << "\\n";\n  caretaker->ShowHistory();\n  std::cout << "\\nClient: Now, let\'s rollback!\\n\\n";\n  caretaker->Undo();\n  std::cout << "\\nClient: Once more!\\n\\n";\n  caretaker->Undo();\n\n  delete originator;\n  delete caretaker;\n}\n\nint main() {\n  std::srand(static_cast<unsigned int>(std::time(NULL)));\n  ClientCode();\n  return 0;\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Originator: My initial state is: Super-duper-super-puper-super.\n\nCaretaker: Saving Originator's state...\nOriginator: I'm doing something important.\nOriginator: and my state has changed to: uOInE8wmckHYPwZS7PtUTwuwZfCIbz\n\nCaretaker: Saving Originator's state...\nOriginator: I'm doing something important.\nOriginator: and my state has changed to: te6RGmykRpbqaWo5MEwjji1fpM1t5D\n\nCaretaker: Saving Originator's state...\nOriginator: I'm doing something important.\nOriginator: and my state has changed to: hX5xWDVljcQ9ydD7StUfbBt5Z7pcSN\n\nCaretaker: Here's the list of mementos:\nSat Oct 19 18:09:37 2019\n / (Super-dup...)\nSat Oct 19 18:09:37 2019\n / (uOInE8wmc...)\nSat Oct 19 18:09:37 2019\n / (te6RGmykR...)\n\nClient: Now, let's rollback!\n\nCaretaker: Restoring state to: Sat Oct 19 18:09:37 2019\n / (te6RGmykR...)\nOriginator: My state has changed to: te6RGmykRpbqaWo5MEwjji1fpM1t5D\n\nClient: Once more!\n\nCaretaker: Restoring state to: Sat Oct 19 18:09:37 2019\n / (uOInE8wmc...)\nOriginator: My state has changed to: uOInE8wmckHYPwZS7PtUTwuwZfCIbz\n")))}l.isMDXComponent=!0}}]);