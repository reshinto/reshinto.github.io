"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[115],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>h});var l=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,l)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,l,n=function(e,t){if(null==e)return{};var a,l,n={},i=Object.keys(e);for(l=0;l<i.length;l++)a=i[l],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(l=0;l<i.length;l++)a=i[l],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var o=l.createContext({}),p=function(e){var t=l.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},m=function(e){var t=p(e.components);return l.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return l.createElement(l.Fragment,{},t)}},c=l.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(a),h=n,d=c["".concat(o,".").concat(h)]||c[h]||u[h]||i;return a?l.createElement(d,r(r({ref:t},m),{},{components:a})):l.createElement(d,r({ref:t},m))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,r=new Array(i);r[0]=c;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:n,r[1]=s;for(var p=2;p<i;p++)r[p]=a[p];return l.createElement.apply(null,r)}return l.createElement.apply(null,a)}c.displayName="MDXCreateElement"},3557:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var l=a(7462),n=(a(7294),a(3905));const i={},r="Template design pattern",s={unversionedId:"interviewPrep/designPatterns/Behavioral_patterns/Template/readme",id:"interviewPrep/designPatterns/Behavioral_patterns/Template/readme",title:"Template design pattern",description:"- it is a design pattern that defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure",source:"@site/docs/interviewPrep/designPatterns/Behavioral_patterns/Template/readme.md",sourceDirName:"interviewPrep/designPatterns/Behavioral_patterns/Template",slug:"/interviewPrep/designPatterns/Behavioral_patterns/Template/",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Template/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Behavioral_patterns/Template/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Strategy design pattern",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Strategy/"},next:{title:"Visitor design pattern",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Visitor/"}},o={},p=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2},{value:"Analogy",id:"analogy",level:2},{value:"Structure",id:"structure",level:2},{value:"How to use",id:"how-to-use",level:2},{value:"How to implement",id:"how-to-implement",level:2},{value:"Pros and Cons",id:"pros-and-cons",level:2},{value:"Pros",id:"pros",level:3},{value:"Cons",id:"cons",level:3}],m={toc:p};function u(e){let{components:t,...i}=e;return(0,n.kt)("wrapper",(0,l.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"template-design-pattern"},"Template design pattern"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"it is a design pattern that defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure")),(0,n.kt)("h2",{id:"problem"},"Problem"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"when creating a data mining app that analyzes corporate documents",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"user feed the app documents in various formats (pdf, doc, csv)"),(0,n.kt)("li",{parentName:"ul"},"and tries to extract meaningful data from these docs in a uniform format"))),(0,n.kt)("li",{parentName:"ul"},"1st version of the app could only work only with DOC files",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"next version able to support CSV files"),(0,n.kt)("li",{parentName:"ul"},"later it can extract PDF files"))),(0,n.kt)("li",{parentName:"ul"},"at some point, you realized that all 3 classes have a lot of similar code",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"while the code for dealing with various data formats was entirely different in all classes",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"the code for data processing and analysis is almost identical"),(0,n.kt)("li",{parentName:"ul"},"would be great to get rid of code duplication",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"and leave the algorithm structure intact"))))))),(0,n.kt)("li",{parentName:"ul"},"there is another problem related to client code that used these classes",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"it had lots of conditionals that picked a proper course of action depending on the class of the processing object"),(0,n.kt)("li",{parentName:"ul"},"if all 3 processing classes had a common interface or a base class",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"one can eliminate the conditionals in client code"),(0,n.kt)("li",{parentName:"ul"},"and use polymorphism when calling methods on a processing object")))))),(0,n.kt)("h2",{id:"solution"},"Solution"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"the pattern suggest that you break down an algorithm into a series of steps",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"turn these steps into methods"),(0,n.kt)("li",{parentName:"ul"},"and put a series of calls to these methods inside a single template method"),(0,n.kt)("li",{parentName:"ul"},"the steps may either be abstract or have some default implementation"),(0,n.kt)("li",{parentName:"ul"},"to use the algorithm, the client is supposed to provide its own subclass",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"implement all abstract steps and override some of the optional ones if needed but not the template method itself"))))),(0,n.kt)("li",{parentName:"ul"},"a base class can be created for all algorithms",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"the class defines a template method consisting of a series of calls to various document processing steps"))),(0,n.kt)("li",{parentName:"ul"},"at first, we can declare all steps abstract",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"forcing the subclasses to provide their own implementations for these methods"),(0,n.kt)("li",{parentName:"ul"},"for this case, subclasses already have all necessary implementations",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"the only thing needed is to adjust signatures of the methods to match the methods of the superclass"))))),(0,n.kt)("li",{parentName:"ul"},"to get rid of duplicate code",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"the code for opening/closing files and extracting/parsing data is different for various data formats",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"no point touching these methods"))),(0,n.kt)("li",{parentName:"ul"},"however, implementation of other steps such as analyzing raw data & composing reports is similar"),(0,n.kt)("li",{parentName:"ul"},"so it can pulled up into the base class where subclasses can share that code"))),(0,n.kt)("li",{parentName:"ul"},"there are 2 types of steps",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"abstract steps must be implemented by every subclass"),(0,n.kt)("li",{parentName:"ul"},"optional steps already have some default implementation, but still can be overridden if needed"))),(0,n.kt)("li",{parentName:"ul"},"there is another type of step, called hooks",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"it is an optional step with an empty body"),(0,n.kt)("li",{parentName:"ul"},"a template method would work even if a hook isn't overridden"),(0,n.kt)("li",{parentName:"ul"},"usually hooks are placed before and after crucial steps of algorithms",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"provding subclasses with additional extension points for an algorithm")))))),(0,n.kt)("h2",{id:"analogy"},"Analogy"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"the template method approach can be used in mass housing construction",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"the architectural plan for building a standard house may contain several extension points that would let a potential owner adjust some details of the resulting house"))),(0,n.kt)("li",{parentName:"ul"},"each building step such as laying the foundation, framing, building walls, installing plumbing and wiring for water and electricity, can be slightly changed to make the resulting house a little bit different from others")),(0,n.kt)("h2",{id:"structure"},"Structure"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Template",src:a(230).Z,width:"734",height:"768"})),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"The Abstract Class declares methods that act as steps of an algorithm, as well as the actual template method which calls these methods in a specific order."),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The steps may either be declared abstract or have some default implementation."))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Concrete Classes can override all of the steps, but not the template method itself."))),(0,n.kt)("h2",{id:"how-to-use"},"How to use"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Use the Template Method pattern when you want to let clients extend only particular steps of an algorithm, but not the whole algorithm or its structure",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The Template Method lets you turn a monolithic algorithm into a series of individual steps which can be easily extended by subclasses while keeping intact the structure defined in a superclass"))),(0,n.kt)("li",{parentName:"ul"},"Use the pattern when you have several classes that contain almost identical algorithms with some minor differences",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"As a result, you might need to modify all classes when the algorithm changes"),(0,n.kt)("li",{parentName:"ul"},"When you turn such an algorithm into a template method, you can also pull up the steps with similar implementations into a superclass, eliminating code duplication"),(0,n.kt)("li",{parentName:"ul"},"Code that varies between subclasses can remain in subclasses")))),(0,n.kt)("h2",{id:"how-to-implement"},"How to implement"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Analyze the target algorithm to see whether you can break it into steps",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"consider which steps are common to all subclasses and which ones will always be unique"))),(0,n.kt)("li",{parentName:"ol"},"create the abstract base class and declare the template method and a set of abstract methods representing the algorithm's steps",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"outline the algorithm's structure in the template method by executing corresponding steps"),(0,n.kt)("li",{parentName:"ul"},"consider making the template method final to prevent final to prevent subclasses from overriding it"))),(0,n.kt)("li",{parentName:"ol"},"it is okay if all steps end by being abstract",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"however, some steps might benefit from having a default implementation"),(0,n.kt)("li",{parentName:"ul"},"subclasses don't have to implement those methods"))),(0,n.kt)("li",{parentName:"ol"},"think of adding hooks between the crucial steps of the algorithm"),(0,n.kt)("li",{parentName:"ol"},"for each variation of the algorithm, create a new concrete subclass",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"it must implement all of the abstract steps, but may also override some of the optional ones")))),(0,n.kt)("h2",{id:"pros-and-cons"},"Pros and Cons"),(0,n.kt)("h3",{id:"pros"},"Pros"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"can let clients override only certain parts of a large algorithm",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"making them less affected by changes that happen to other parts of the algorithm"))),(0,n.kt)("li",{parentName:"ul"},"can pull the duplicate code into a superclass")),(0,n.kt)("h3",{id:"cons"},"Cons"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"some clients may be limited by the provided skeleton of an algorithm"),(0,n.kt)("li",{parentName:"ul"},"you might violate the Liskov Substitution Principle by suppressing a default step implementation via a subclass"),(0,n.kt)("li",{parentName:"ul"},"template methods tend to be harder to maintain the more steps they have")))}u.isMDXComponent=!0},230:(e,t,a)=>{a.d(t,{Z:()=>l});const l=a.p+"assets/images/template-8a81efe3cb812b5123e62bb3d45b776f.png"}}]);