"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[44795],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),h=p(a),m=r,c=h["".concat(s,".").concat(m)]||h[m]||u[m]||i;return a?n.createElement(c,l(l({ref:t},d),{},{components:a})):n.createElement(c,l({ref:t},d))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},87618:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var n=a(83117),r=(a(67294),a(3905));const i={},l="Red-Black Tree",o={unversionedId:"interviewPrep/data_structures/13Trees/redBlackTree/readme",id:"interviewPrep/data_structures/13Trees/redBlackTree/readme",title:"Red-Black Tree",description:"Red-black tree",source:"@site/docs/interviewPrep/data_structures/13Trees/redBlackTree/readme.md",sourceDirName:"interviewPrep/data_structures/13Trees/redBlackTree",slug:"/interviewPrep/data_structures/13Trees/redBlackTree/",permalink:"/docs/interviewPrep/data_structures/13Trees/redBlackTree/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/data_structures/13Trees/redBlackTree/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"B-Trees",permalink:"/docs/interviewPrep/data_structures/13Trees/bTrees/"},next:{title:"TypeScript Example",permalink:"/docs/interviewPrep/data_structures/13Trees/redBlackTree/typescriptExample"}},s={},p=[{value:"Why Red-Black Trees?",id:"why-red-black-trees",level:2},{value:"Comparison with AVL Tree",id:"comparison-with-avl-tree",level:2},{value:"How does a Red-Black Tree ensure balance?",id:"how-does-a-red-black-tree-ensure-balance",level:2},{value:"Applications:",id:"applications",level:2},{value:"Insert and Delete",id:"insert-and-delete",level:2},{value:"Insertion",id:"insertion",level:3},{value:"Insert Fix up",id:"insert-fix-up",level:3}],d={toc:p};function u(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"red-black-tree"},"Red-Black Tree"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Red-black tree",src:a(21865).Z,width:"936",height:"280"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"it is a self-balancing binary search tree with one extra bit of storage per node",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"its color can be either RED or BLACK"),(0,r.kt)("li",{parentName:"ul"},"By constraining the node colors on any simple path from the root to a leaf",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"red-black trees ensure that no such path is more than twice as long as any other, so that the tree is approximately balanced"))))),(0,r.kt)("li",{parentName:"ul"},"Each node of the tree contains the attributes",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"color, value, left, right, and parent"))),(0,r.kt)("li",{parentName:"ul"},"If a child or the parent of a node does not exist, the corresponding pointer attribute of the node contains the value null",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"We regard these nulls as being pointers to leaves (external nodes) of the binary search tree and the normal, key-bearing nodes as being internal nodes of the tree"))),(0,r.kt)("li",{parentName:"ul"},"it is a binary tree that satisfies the following red-black properties",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"Every node is either red or black"),(0,r.kt)("li",{parentName:"ol"},"The root is black"),(0,r.kt)("li",{parentName:"ol"},"all leaf node are black"),(0,r.kt)("li",{parentName:"ol"},"If a node is red, then both its children and parent are black"),(0,r.kt)("li",{parentName:"ol"},"Every path from a node (including root) to any of its descendants NULL nodes has the same number of black nodes"))),(0,r.kt)("li",{parentName:"ul"},"it also has a lemma",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"a tree with n internal nodes has height at most ",(0,r.kt)("inlineCode",{parentName:"li"},"2log (n + 1)"))))),(0,r.kt)("h2",{id:"why-red-black-trees"},"Why Red-Black Trees?"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Most of the BST operations (e.g., search, max, min, insert, delete.. etc) take ",(0,r.kt)("inlineCode",{parentName:"li"},"O(h)")," time where h is the height of the BST"),(0,r.kt)("li",{parentName:"ul"},"The cost of these operations may become ",(0,r.kt)("inlineCode",{parentName:"li"},"O(n)")," for a skewed Binary tree"),(0,r.kt)("li",{parentName:"ul"},"If we make sure that the height of the tree remains ",(0,r.kt)("inlineCode",{parentName:"li"},"O(log n)")," after every insertion and deletion",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"then we can guarantee an upper bound of ",(0,r.kt)("inlineCode",{parentName:"li"},"O(log n)")," for all these operations"))),(0,r.kt)("li",{parentName:"ul"},"The height of a Red-Black tree is always ",(0,r.kt)("inlineCode",{parentName:"li"},"O(log n)")," where n is the number of nodes in the tree")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Method"),(0,r.kt)("th",{parentName:"tr",align:null},"Time Complexity"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Search"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"O(log n)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Insert"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"O(log n)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Delete"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"O(log n)"))))),(0,r.kt)("h2",{id:"comparison-with-avl-tree"},"Comparison with AVL Tree"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The AVL trees are more balanced compared to Red-Black Trees",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"but they may cause more rotations during insertion and deletion"))),(0,r.kt)("li",{parentName:"ul"},"if the application involves frequent insertions and deletions",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"then Red-Black trees should be preferred"))),(0,r.kt)("li",{parentName:"ul"},"if the insertions and deletions are less frequent and search is a more frequent operation",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"then AVL tree should be preferred over the Red-Black Tree")))),(0,r.kt)("h2",{id:"how-does-a-red-black-tree-ensure-balance"},"How does a Red-Black Tree ensure balance?"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"3 nodes combination",src:a(91829).Z,width:"1100",height:"401"})),(0,r.kt)("h2",{id:"applications"},"Applications:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Most of the self-balancing BST library functions like map, multiset, and multimap in C++ ( or java packages like java.util.TreeMap and java.util.TreeSet ) use Red-Black Trees"),(0,r.kt)("li",{parentName:"ul"},"It is used to implement CPU Scheduling Linux",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Completely Fair Scheduler uses it"))),(0,r.kt)("li",{parentName:"ul"},"It is used in the K-mean clustering algorithm in machine learning for reducing time complexity"),(0,r.kt)("li",{parentName:"ul"},"MySQL also uses the Red-Black tree for indexes on tables in order to reduce the searching and insertion time")),(0,r.kt)("h2",{id:"insert-and-delete"},"Insert and Delete"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Tree rotation",src:a(50901).Z,width:"756",height:"236"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"search-tree operations ",(0,r.kt)("inlineCode",{parentName:"p"},"TREE-INSERT")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"TREE-DELETE")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"when run on a red-black tree with n keys, take ",(0,r.kt)("inlineCode",{parentName:"li"},"O(log n)")," time",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Because they modify the tree, the result may violate the red-black properties"),(0,r.kt)("li",{parentName:"ul"},"To restore these properties, we must change the colors of some nodes in the tree and also change the pointer structure"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"We change the pointer structure through rotation"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"which is a local operation in a search tree that preserves the binary-search-tree property"),(0,r.kt)("li",{parentName:"ul"},"When we do a left rotation on a node x",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"we assume that its right child y is not null"),(0,r.kt)("li",{parentName:"ul"},"x may be any node in the tree whose right child is not null"),(0,r.kt)("li",{parentName:"ul"},'The left rotation "pivots" around the link from x to y'),(0,r.kt)("li",{parentName:"ul"},"It makes y the new root of the subtree, with x as ys left child and ys left child as xs right child"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"rotate left example"),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("img",{alt:"Left Tree rotation",src:a(29078).Z,width:"878",height:"618"})),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"rotating element x in a tree T left",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},'After a rotation, the y element "pulls" its right subtree up (elements 19, 20, 22)'),(0,r.kt)("li",{parentName:"ul"},"Left subtree of x (9) stays the same, and left subtree of y becomes right subtree of x")))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"rotateLeft() {\n  let y = this.right;\n  this.right = y.left;\n\n  if (!y.left.isNil) {\n    y.left.parent = this;\n  }\n\n  if (!y.isNil) y.parent = this.parent;\n\n  if (this.parent) {\n    if (this.id === this.parent.left.id) {\n      this.parent.left = y;\n    } else {\n      this.parent.right = y;\n    }\n  } else {\n    this.tree.root = y;\n  }\n\n  y.left = this;\n  if (!this.isNil) this.parent = y;\n}\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"rotate right example"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"rotateRight() {\n  let y = this.left;\n  this.left = y.right;\n\n  if (!y.right.isNil) {\n    y.right.parent = this;\n  }\n\n  if (!y.isNil) y.parent = this.parent;\n\n  if (this.parent) {\n    if (this.id === this.parent.right.id) {\n      this.parent.right = y;\n    } else {\n      this.parent.left = y;\n    }\n  } else {\n    this.tree.root = y;\n  }\n\n  y.right = this;\n  if (!this.isNil) this.parent = y;\n}\n")))),(0,r.kt)("h3",{id:"insertion"},"Insertion"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"To insert a node, first we have to find a place to insert it into"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The new node will always be added as a leaf"),(0,r.kt)("li",{parentName:"ul"},"This means that both of his children are NIL and are black"),(0,r.kt)("li",{parentName:"ul"},"The newly added node will always be red"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"example"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"insertNode(data) {\n  let current, parent, x;\n  current = this.root;\n  parent = null;\n\n  while (!current.isNil) {\n    if (data === current.value) return current;\n\n    parent = current;\n    current = data < current.value ? current.left : current.right;\n  }\n\n  x = new rbNode(this);\n  x.value = data;\n  x.parent = parent;\n  x.isRed = true;\n  x.isNil = false;\n\n  x.left = new rbNode(this);\n  x.right = new rbNode(this);\n\n  if (parent) {\n    if (x.value < parent.value) {\n      parent.left = x;\n    } else {\n      parent.right = x;\n    }\n  } else {\n    this.root = x;\n  }\n\n  this.insertFixup(x);\n\n  return x;\n}\n")))),(0,r.kt)("h3",{id:"insert-fix-up"},"Insert Fix up"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"After insertion, we perform a insertFixup operation defined as following")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"example"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"To perform the fixup, we have to look at the parent, and check if the red-black property is followed"),(0,r.kt)("li",{parentName:"ul"},"If the parent node is black",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"we can exit"))),(0,r.kt)("li",{parentName:"ul"},"If parent node is red",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"we recolor it black and preform a rotation to balance the tree"))),(0,r.kt)("li",{parentName:"ul"},"By inserting a red node with 2 NIL-children, we are keeping the property of black height (property 4)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Although, this could mean that we are breaking the property 3",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"according to which both children of a red node have to be black\nSo, let's look at a situation when a parent of a new node is red, by which the property 3 will be violated")))))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"insertFixup(x) {\n  while (x.id !== this.root.id && x.parent.isRed) {\n    if (x.parent.id === x.parent.parent.left.id) {\n      let y = x.parent.parent.right;\n\n      if (y.isRed) {\n        x.parent.isRed = false;\n        y.isRed = false;\n        x.parent.parent.isRed = true;\n        x = x.parent.parent;\n      } else {\n        if (x.id === x.parent.right.id) {\n          x = x.parent;\n          x.rotateLeft();\n        }\n\n        x.parent.isRed = false;\n        x.parent.parent.isRed = true;\n        x.parent.parent.rotateRight();\n      }\n    } else {\n      let y = x.parent.parent.left;\n\n      if (y.isRed) {\n        x.parent.isRed = false;\n        y.isRed = false;\n        x.parent.parent.isRed = true;\n        x = x.parent.parent;\n      } else {\n        if (x.id === x.parent.left.id) {\n          x = x.parent;\n          x.rotateRight();\n        }\n\n        x.parent.isRed = false;\n        x.parent.parent.isRed = true;\n        x.parent.parent.rotateLeft();\n      }\n    }\n  }\n\n  this.root.isRed = false;\n}\n")))))}u.isMDXComponent=!0},91829:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/3NodedRedBlacktree-d143e2e6a1713e3e8340b6c1bdd8b708.jpg"},21865:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/red-black_tree-26eaa86dc882a0859897b0c762df3c26.jpg"},50901:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tree_rotation1-07d5b8a10773ee5fbafd019fb4a85005.jpg"},29078:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tree_rotation2-72c86f677c17ff55a3bdf2d0341d2eff.jpg"}}]);