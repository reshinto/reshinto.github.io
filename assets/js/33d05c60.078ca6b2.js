"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[2057],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(a),d=i,k=c["".concat(o,".").concat(d)]||c[d]||u[d]||r;return a?n.createElement(k,l(l({ref:t},m),{},{components:a})):n.createElement(k,l({ref:t},m))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=c;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var p=2;p<r;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},20891:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var n=a(87462),i=(a(67294),a(3905));const r={},l="DESIGN PATTERNS: ELEMENTS OF REUSABLE OBJECT-ORIENTED SOFTWARE",s={unversionedId:"interviewPrep/designPatterns/design_pattern_introduction",id:"interviewPrep/designPatterns/design_pattern_introduction",title:"DESIGN PATTERNS: ELEMENTS OF REUSABLE OBJECT-ORIENTED SOFTWARE",description:"Introduction",source:"@site/docs/interviewPrep/designPatterns/design_pattern_introduction.md",sourceDirName:"interviewPrep/designPatterns",slug:"/interviewPrep/designPatterns/design_pattern_introduction",permalink:"/docs/interviewPrep/designPatterns/design_pattern_introduction",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/design_pattern_introduction.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Proxy design pattern",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Proxy/"},next:{title:"Gamma Categorization",permalink:"/docs/interviewPrep/designPatterns/gamma_categorization"}},o={},p=[{value:"Introduction",id:"introduction",level:2},{value:"The Catalog of Design patterns (23 design patterns)",id:"the-catalog-of-design-patterns-23-design-patterns",level:3},{value:"Design patterns can be classified by 2 criteria:",id:"design-patterns-can-be-classified-by-2-criteria",level:3},{value:"How design patterns solve design problems",id:"how-design-patterns-solve-design-problems",level:3},{value:"Finding appropriate objects",id:"finding-appropriate-objects",level:4},{value:"Determining object Granularity",id:"determining-object-granularity",level:4},{value:"Specifying object interfaces",id:"specifying-object-interfaces",level:4},{value:"Specifying object implementations",id:"specifying-object-implementations",level:4},{value:"Class vs Interface inheritance",id:"class-vs-interface-inheritance",level:4},{value:"Programming to an Interface, not an Implementation",id:"programming-to-an-interface-not-an-implementation",level:4},{value:"Putting reuse mechanisms to work: Favor object composition over class inheritance",id:"putting-reuse-mechanisms-to-work-favor-object-composition-over-class-inheritance",level:4},{value:"Delegation",id:"delegation",level:4},{value:"Inheritance vs Parameterized types",id:"inheritance-vs-parameterized-types",level:4},{value:"Relating Run time &amp; Compile time structures",id:"relating-run-time--compile-time-structures",level:4},{value:"Designing for change",id:"designing-for-change",level:4},{value:"How to select a Design Pattern",id:"how-to-select-a-design-pattern",level:3},{value:"How to use a Design Pattern",id:"how-to-use-a-design-pattern",level:3}],m={toc:p};function u(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"design-patterns-elements-of-reusable-object-oriented-software"},"DESIGN PATTERNS: ELEMENTS OF REUSABLE OBJECT-ORIENTED SOFTWARE"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Design should be solve present & future problems & requirements"),(0,i.kt)("li",{parentName:"ul"},"Must avoid redesign, or minimize it"),(0,i.kt)("li",{parentName:"ul"},"try to reuse existing good solutions than to create new solutions"),(0,i.kt)("li",{parentName:"ul"},"What is a DESIGN PATTERN? 1 solution that is able to solve problems a million times over without repetition",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Has 4 essential elements: pattern name, problem, solution, consequences",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Pattern Name: A handle used to describe a design problem, solutions, & consequences in a word or two"),(0,i.kt)("li",{parentName:"ul"},"Problem: describes when to apply the patterns"),(0,i.kt)("li",{parentName:"ul"},"Solution: describes the elements that make up the design, relationships, responsibilities, & collaborations"),(0,i.kt)("li",{parentName:"ul"},"Consequences: the results & trade-offs of applying the pattern")))))),(0,i.kt)("h3",{id:"the-catalog-of-design-patterns-23-design-patterns"},"The Catalog of Design patterns (23 design patterns)"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Abstract Factory:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Provide an interface for creating families of related or dependent objects without specifying their concrete classes"))),(0,i.kt)("li",{parentName:"ol"},"Adapter:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Convert the interface of a class into another interface clients expect"),(0,i.kt)("li",{parentName:"ul"},"Adapter lets classes work together that couldn't otherwise because of incompatible interfaces"))),(0,i.kt)("li",{parentName:"ol"},"Bridge:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Decouple an abstraction from its implementation so that the two can vary independently"))),(0,i.kt)("li",{parentName:"ol"},"Builder:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Separate the construction of a complex object from its representation"),(0,i.kt)("li",{parentName:"ul"},"so that the same construction process can create different representations"))),(0,i.kt)("li",{parentName:"ol"},"Chain of Responsibility:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Avoid coupling the sender of a request to its receiver by giving more than 1 object a chance to handle the request"),(0,i.kt)("li",{parentName:"ul"},"Chain the receiving objects and pass the request along the chain until an object handles it"))),(0,i.kt)("li",{parentName:"ol"},"Command:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Encapsulate a request as an object,"),(0,i.kt)("li",{parentName:"ul"},"thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations"))),(0,i.kt)("li",{parentName:"ol"},"Composite:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Compose objects into tree structures to represent part-whole hierarchies"),(0,i.kt)("li",{parentName:"ul"},"Composite lets clients treat individual objects and compositions of objects uniformly"))),(0,i.kt)("li",{parentName:"ol"},"Decorator:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Attach additional responsibilities to an object dynamically"),(0,i.kt)("li",{parentName:"ul"},"Decorators provide a flexible alternative to subclassing for extending functionality"))),(0,i.kt)("li",{parentName:"ol"},"Facade:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Provide a unified interface to a set of interfaces in a subsystem"),(0,i.kt)("li",{parentName:"ul"},"Facade defines a higher-level interface that makes the subsystem easier to use"))),(0,i.kt)("li",{parentName:"ol"},"Factory Method:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Define an interface for creating an object, but let subclasses decide which class to instantiate"),(0,i.kt)("li",{parentName:"ul"},"Factory method lets a class defer instantiation to subclasses"))),(0,i.kt)("li",{parentName:"ol"},"Flyweight:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Use sharing to support large numbers of fine-grained objects efficiently"))),(0,i.kt)("li",{parentName:"ol"},"Interpreter:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language"))),(0,i.kt)("li",{parentName:"ol"},"Iterator:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation"))),(0,i.kt)("li",{parentName:"ol"},"Mediator:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Define an object that encapsulates how a set of objects interact"),(0,i.kt)("li",{parentName:"ul"},"Mediator promotes loose coupling by keeping objects from referring to each other explicitly,"),(0,i.kt)("li",{parentName:"ul"},"and it lets you vary their interaction independently"))),(0,i.kt)("li",{parentName:"ol"},"Memento:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state later"))),(0,i.kt)("li",{parentName:"ol"},"Observer:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Define a 1 to many dependency between objects so that when 1 object changes state,"),(0,i.kt)("li",{parentName:"ul"},"all its dependents are notified and updated automatically"))),(0,i.kt)("li",{parentName:"ol"},"Prototype:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype"))),(0,i.kt)("li",{parentName:"ol"},"Proxy:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Provide a surrogate or placeholder for another object to control access to it"))),(0,i.kt)("li",{parentName:"ol"},"Singleton:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Ensure a class only has 1 instance, and provide a global point of access to it"))),(0,i.kt)("li",{parentName:"ol"},"State:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Allow an object to alter its behavior when its internal state changes"),(0,i.kt)("li",{parentName:"ul"},"The object will appear to change its class"))),(0,i.kt)("li",{parentName:"ol"},"Strategy:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Define a family of algorithms, encapsulate each 1, and make them interchangeable"),(0,i.kt)("li",{parentName:"ul"},"Strategy lets the algorithm vary independently from clients that use it"))),(0,i.kt)("li",{parentName:"ol"},"Template Method:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Define the skeleton of an algorithm in an operation, deferring some steps to subclasses"),(0,i.kt)("li",{parentName:"ul"},"Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure"))),(0,i.kt)("li",{parentName:"ol"},"Visitor:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Represent an operation to be performed on the elements of an object structure"),(0,i.kt)("li",{parentName:"ul"},"Visitor lets you define a new operation without changing the classes of the elements on which it operates")))),(0,i.kt)("h3",{id:"design-patterns-can-be-classified-by-2-criteria"},"Design patterns can be classified by 2 criteria:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Purpose: reflects what a pattern does",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"have 3 types of purposes:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Creational: To do with the process of object creation",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Ensures that your system is written in terms of interfaces, not implementations"),(0,i.kt)("li",{parentName:"ul"},"Class: Defer some part of object creation to subclasses",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Factory Method"))),(0,i.kt)("li",{parentName:"ul"},"Object: Defer some part of object creation to another object",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Abstract Factory"),(0,i.kt)("li",{parentName:"ul"},"Builder"),(0,i.kt)("li",{parentName:"ul"},"Prototype"),(0,i.kt)("li",{parentName:"ul"},"Singleton"))),(0,i.kt)("li",{parentName:"ul"},"When to use:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"When the system should be independent of how its objects and products are created"),(0,i.kt)("li",{parentName:"ul"},"A set of related objects is designed to be used together"),(0,i.kt)("li",{parentName:"ul"},"Hiding the implementation of a product and only revealing its interface"))))),(0,i.kt)("li",{parentName:"ol"},"Structural: Deal with the composition of classes or objects",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Class: Use inheritance to compose classes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Adapter"))),(0,i.kt)("li",{parentName:"ul"},"Object: Describe ways to assemble objects",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Adapter"),(0,i.kt)("li",{parentName:"ul"},"Bridge"),(0,i.kt)("li",{parentName:"ul"},"Composite"),(0,i.kt)("li",{parentName:"ul"},"Decorator"),(0,i.kt)("li",{parentName:"ul"},"Facade"),(0,i.kt)("li",{parentName:"ul"},"Flyweight"),(0,i.kt)("li",{parentName:"ul"},"Proxy"))))),(0,i.kt)("li",{parentName:"ol"},"Behavioral: Characterize the ways in which classes or objects interact and distribute responsibility",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Class: Use inheritance to describe algorithms and flow of control",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Interpreter"),(0,i.kt)("li",{parentName:"ul"},"Template Method"))),(0,i.kt)("li",{parentName:"ul"},"Object: Describe how a group of objects cooperate to perform a task that no single object can carry out alone",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Chain of Responsibility"),(0,i.kt)("li",{parentName:"ul"},"Command"),(0,i.kt)("li",{parentName:"ul"},"Iterator"),(0,i.kt)("li",{parentName:"ul"},"Mediator"),(0,i.kt)("li",{parentName:"ul"},"Memento"),(0,i.kt)("li",{parentName:"ul"},"Observer"),(0,i.kt)("li",{parentName:"ul"},"State"),(0,i.kt)("li",{parentName:"ul"},"Strategy"),(0,i.kt)("li",{parentName:"ul"},"Visitor"))))))))),(0,i.kt)("li",{parentName:"ol"},"Scope: specifies whether the pattern applies primarily to classes or objects",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Have 2 types: classes, objects",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Class:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Deal with relationships between classes & their subclasses (focus on class relationships)"),(0,i.kt)("li",{parentName:"ul"},"relationships are established through inheritance, so they are static-fixed at compile time"),(0,i.kt)("li",{parentName:"ul"},"Creational",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Factory Method"))),(0,i.kt)("li",{parentName:"ul"},"Structural",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Adapter"))),(0,i.kt)("li",{parentName:"ul"},"Behavioral",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Interpreter"),(0,i.kt)("li",{parentName:"ul"},"Template Method"))))),(0,i.kt)("li",{parentName:"ol"},"Object:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Deal with object relationships, which can be changed at run time and are more dynamic"),(0,i.kt)("li",{parentName:"ul"},"Almost all patterns use inheritance to some extent"),(0,i.kt)("li",{parentName:"ul"},"Creational",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Abstract Factory"),(0,i.kt)("li",{parentName:"ul"},"Builder"),(0,i.kt)("li",{parentName:"ul"},"Prototype"),(0,i.kt)("li",{parentName:"ul"},"Singleton"))),(0,i.kt)("li",{parentName:"ul"},"Structural",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Adapter"),(0,i.kt)("li",{parentName:"ul"},"Bridge"),(0,i.kt)("li",{parentName:"ul"},"Composite"),(0,i.kt)("li",{parentName:"ul"},"Decorator"),(0,i.kt)("li",{parentName:"ul"},"Facade"),(0,i.kt)("li",{parentName:"ul"},"Flyweight"),(0,i.kt)("li",{parentName:"ul"},"Proxy"))),(0,i.kt)("li",{parentName:"ul"},"Behavioral",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Chain of Responsibility"),(0,i.kt)("li",{parentName:"ul"},"Command"),(0,i.kt)("li",{parentName:"ul"},"Iterator"),(0,i.kt)("li",{parentName:"ul"},"Mediator"),(0,i.kt)("li",{parentName:"ul"},"Memento"),(0,i.kt)("li",{parentName:"ul"},"Observer"),(0,i.kt)("li",{parentName:"ul"},"State"),(0,i.kt)("li",{parentName:"ul"},"Strategy"),(0,i.kt)("li",{parentName:"ul"},"Visitor")))))))))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Some patterns are often used together",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Composite is often used with Iterator or Visitor"))),(0,i.kt)("li",{parentName:"ul"},"Some patterns are alternatives",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Prototype is often an alternative to Abstract Factory"))),(0,i.kt)("li",{parentName:"ul"},"Some patterns result in similar designs even though the patterns have different intents",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Composite & Decorator have similar structure diagrams"))),(0,i.kt)("li",{parentName:"ul"},'Another way to organize design patterns is according to how they reference each other in their "related patterns" sections')),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Design Pattern Relationships",src:a(19104).Z,width:"1582",height:"1988"})),(0,i.kt)("h3",{id:"how-design-patterns-solve-design-problems"},"How design patterns solve design problems"),(0,i.kt)("h4",{id:"finding-appropriate-objects"},"Finding appropriate objects"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Hard part about object oriented design is decomposing a system into objects due to many factors:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"encapsulation, granularity, dependency, flexibility, performance, evolution, reusability ..."))),(0,i.kt)("li",{parentName:"ul"},"Object oriented design methodologies favor many different approaches",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"write a problem statement, single out nouns and verbs, create corresponding classes and operations"),(0,i.kt)("li",{parentName:"ul"},"Focus on the collaborations & responsibilities in your system"),(0,i.kt)("li",{parentName:"ul"},"Model the real world & translate the objects found during analysis into design"))),(0,i.kt)("li",{parentName:"ul"},"Many objects in a design come from the analysis model, but often end up with classes that have no counterparts in the real world",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"low-level classes like arrays"),(0,i.kt)("li",{parentName:"ul"},"higher-level classes:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Composite pattern:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"introduces an abstraction for treating objects uniformly that doesn't have a physical counterpart"),(0,i.kt)("li",{parentName:"ul"},"strict modeling of the real world leads to a system that reflects today's realities but not necessarily tomorrow's"),(0,i.kt)("li",{parentName:"ul"},"abstractions that emerge during design are key to making a design flexible"))))))),(0,i.kt)("li",{parentName:"ul"},"Design patterns helps you to identify less-obvious abstractions & the objects that can capture them",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Strategy pattern describes how to implement interchangeable families of algorithms"),(0,i.kt)("li",{parentName:"ul"},"State pattern represents each state of an entity as an object")))),(0,i.kt)("h4",{id:"determining-object-granularity"},"Determining object Granularity"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Design patterns can address the issue of objects being able to vary tremendously in size and number",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Facade pattern: describes how to represent complete subsystems as objects"),(0,i.kt)("li",{parentName:"ul"},"Flyweight pattern: describes how to support huge numbers of objects at the finest granularities"),(0,i.kt)("li",{parentName:"ul"},"Other design patterns describe specific ways of decomposing an object into smaller objects"),(0,i.kt)("li",{parentName:"ul"},"Abstract Factory & Builder patterns: yield objects whose only responsibilities are creating other objects"),(0,i.kt)("li",{parentName:"ul"},"Visitor & Command patterns: yield objects responsible for only implementing a request on anther object or group of object")))),(0,i.kt)("h4",{id:"specifying-object-interfaces"},"Specifying object interfaces"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An object's interface characterizes the complete set of requests that can be sent to the object"),(0,i.kt)("li",{parentName:"ul"},"Any request that matches a signature in the object's interface may be sent to the object",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Interface: the set of all signatures defined by an object's operations",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Signature: the operation's name, objects taken as parameters, and operation's return value declared by an object during an operation"))))),(0,i.kt)("li",{parentName:"ul"},"Design patterns help to define interfaces by identifying their key elements & data type that get sent across an interface"),(0,i.kt)("li",{parentName:"ul"},"Design patterns will also tell you what not to put in the interfaces",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Memento pattern: describes how to encapsulate & save the internal state of an object to allow object restoration later",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"must define 2 interfaces:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"a restricted one that lets clients hold & copy mementos"),(0,i.kt)("li",{parentName:"ul"},"a privileged one that only the original object can use to store & retrieve state in the momento"))))))),(0,i.kt)("li",{parentName:"ul"},"Design patterns specify relationships between interfaces, by requiring some classes to have similar interfaces or placing constraints on the interfaces of some classes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Decorator & Proxy patterns require the interfaces of Decorator & Proxy objects to be identical to the decorated & proxied objects"),(0,i.kt)("li",{parentName:"ul"},"Visitor pattern: visitor interface must reflect all classes of objects that visitors can visit")))),(0,i.kt)("h4",{id:"specifying-object-implementations"},"Specifying object implementations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Object's implementation is defined by its class"),(0,i.kt)("li",{parentName:"ul"},"The class specifies the object's internal data & representation & defines the operations the object can perform"),(0,i.kt)("li",{parentName:"ul"},"Objects are created by instantiating a class (the object is said to be an instance of the class)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Instantiating a class allocates storage for the object's internal data (made up of instance variables)"),(0,i.kt)("li",{parentName:"ul"},"Associates the operations with these data"),(0,i.kt)("li",{parentName:"ul"},"many similar instances of an object can be created by instantiating a class"))),(0,i.kt)("li",{parentName:"ul"},"New classes can be defined in terms of existing classes using inheritance",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"when subclass inherits from parent class, definitions of all data & operations that the class defines are included"),(0,i.kt)("li",{parentName:"ul"},"objects that are instances of the subclass will contain all data defined by the subclass & its parent classes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"they be able to perform all operations defined by this subclass & its parents"))),(0,i.kt)("li",{parentName:"ul"},"Abstract class is one whose main purpose is to define a common interface for its subclasses",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"abstract class will defer some or all of its implementation to operations defined in subclasses"),(0,i.kt)("li",{parentName:"ul"},"hence an abstract class cannot be instantiated"),(0,i.kt)("li",{parentName:"ul"},"abstract operations are operations that an abstract class declares but doesn't implement",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Concrete classes are classes that aren't abstract"))))),(0,i.kt)("li",{parentName:"ul"},"Subclasses can refine & redefine behaviors of their parent classes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"a class may override an operation defined by its parent class",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"overriding gives subclasses a chance to handle requests instead of their parent classes"))))),(0,i.kt)("li",{parentName:"ul"},"Class inheritance lets you define classes simply by extending other classes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Making it easy to define families of objects having related functionality")))))),(0,i.kt)("h4",{id:"class-vs-interface-inheritance"},"Class vs Interface inheritance"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An object's class defines how the object is implemented",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The class defines the object's internal state & the implementation of its operations"),(0,i.kt)("li",{parentName:"ul"},"Object's type only refers to its interface-the set of requests to which it can respond",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"an object can have many types"),(0,i.kt)("li",{parentName:"ul"},"objects of different classes can have the same type"))))),(0,i.kt)("li",{parentName:"ul"},"An object is an instance of a class also implies that the object supports the interface defined by the class"),(0,i.kt)("li",{parentName:"ul"},"Class inheritance vs Interface inheritance (subtyping)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Class inheritance defines an object's implementation in terms of another object's implementation",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"it's a mechanism for code & representation sharing"))),(0,i.kt)("li",{parentName:"ul"},"Interface inheritance (subtyping) describes when an object can be used in place of another"),(0,i.kt)("li",{parentName:"ul"},"Programming languages don't make the distinction explicit",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"2 types:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"inheritance means both interface and implementation inheritance (C++)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"standard way to inherit an interface is to inherit publicly from a class that has (pure) virtual member functions"),(0,i.kt)("li",{parentName:"ul"},"pure interface inheritance can be approximated by inheriting publicly from pure abstract classes"),(0,i.kt)("li",{parentName:"ul"},"pure implementation or class inheritance can be approximated with private inheritance"),(0,i.kt)("li",{parentName:"ul"},"manipulate objects through types defined by abstract classes"))),(0,i.kt)("li",{parentName:"ol"},"inheritance means just implementation inheritance",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"can assign instances of any class to a variable"),(0,i.kt)("li",{parentName:"ul"},"as long as those instances support the operation performed on the value of the variable"),(0,i.kt)("li",{parentName:"ul"},"act as if subclasses were subtypes")))))))))),(0,i.kt)("h4",{id:"programming-to-an-interface-not-an-implementation"},"Programming to an Interface, not an Implementation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Polymorphism depends on inheritance's ability to define families of objects with identical interfaces",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"usually by inheriting from an abstract class"))),(0,i.kt)("li",{parentName:"ul"},"When inheritance is used, all classes derived from an abstract class will share its interface",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this implies that a subclass merely adds or overrides operations & does not hide operations of the parent class"),(0,i.kt)("li",{parentName:"ul"},"all subclasses can then respond to the requests in the interface of this abstract class",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"making them all subtypes of the abstract class"))))),(0,i.kt)("li",{parentName:"ul"},"2 benefits to manipulating objects solely in terms of the interface defined by abstract classes:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"clients are unaware of specific types of objects they use, as long as object adhere to the interface as expected"),(0,i.kt)("li",{parentName:"ol"},"clients are unaware of classes that implement these objects, & only know about abstract classes defining the interface")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this greatly reduces implementation dependencies between subsystems"),(0,i.kt)("li",{parentName:"ul"},"don't declare variables to be instances of particular concrete classes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"instead, commit only to an interface defined by an abstract class")))))),(0,i.kt)("h4",{id:"putting-reuse-mechanisms-to-work-favor-object-composition-over-class-inheritance"},"Putting reuse mechanisms to work: Favor object composition over class inheritance"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Class inheritance & Object Composition are 2 most common techniques for reusing functionality in object oriented systems"),(0,i.kt)("li",{parentName:"ul"},"Inheritance vs Composition",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Class Inheritance:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"lets you define the implementation of 1 class in terms of another's"),(0,i.kt)("li",{parentName:"ul"},"white-box reuse: reuse by subclassing",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'"white-box" refers to visibility',(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"with inheritance, the internals of parent classes are often visible to subclasses"))))),(0,i.kt)("li",{parentName:"ul"},"advantages:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"defined statically at compile time & is straightforward to use"),(0,i.kt)("li",{parentName:"ul"},"makes it easier to modify the implementation being reused",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"when a subclass overrides some but not all operations, it can affect the operations it inherits"))))),(0,i.kt)("li",{parentName:"ul"},"disadvantages:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"can't change the implementations inherited from parent classes at run-time",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"because inheritance is defined at compile time"))),(0,i.kt)("li",{parentName:"ul"},"parent classes often define at least part of their subclasses' physical representation",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"because inheritance exposes a subclass to details of its parent's implementation,"),(0,i.kt)("li",{parentName:"ul"},"therefore, inheritance breaks encapsulation",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"any change in the parent's implementation will force the subclass to change",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"when implementation becomes bound up with the implementation of its parent class"))))),(0,i.kt)("li",{parentName:"ul"},"implementation dependencies can cause problems when trying to reuse a subclass",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"should any aspect of the inherited implementation not be appropriate for new problem domains,"),(0,i.kt)("li",{parentName:"ul"},"the parent class must be rewritten or replaced by something more appropriate"),(0,i.kt)("li",{parentName:"ul"},"this dependency limits flexibility & reusability"))))),(0,i.kt)("li",{parentName:"ul"},"1 solution: inherit only from abstract classes, since they usually provide little or no implementation"))))),(0,i.kt)("li",{parentName:"ul"},"Object Composition: an alternative to class inheritance",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"new functionality is obtained by assembling or composing objects to get more complex functionality"),(0,i.kt)("li",{parentName:"ul"},"requires that the objects being composed have well-defined interfaces"),(0,i.kt)("li",{parentName:"ul"},"black-box reuse: reuse by assembling or composing",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'"black-box" refers to visibility',(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"no internal details of objects are visible"))))),(0,i.kt)("li",{parentName:"ul"},"advantages",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"defined dynamically at run time through objects acquiring references to other objects",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"requires objects to respect each others' interfaces",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"which requires carefully designed interfaces that don't stop you from using 1 object with other"))),(0,i.kt)("li",{parentName:"ul"},"any object can be replaced at run time by another as long as it has the same type"),(0,i.kt)("li",{parentName:"ul"},"fewer implementation dependencies due to an object's implementation being written in terms of object interfaces"))),(0,i.kt)("li",{parentName:"ul"},"helps keep each class encapsulated & focused on 1 task",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"classes & class hierarchies will remain small"),(0,i.kt)("li",{parentName:"ul"},"will be less likely to grow into unmanageable monsters"))))),(0,i.kt)("li",{parentName:"ul"},"disadvantages",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"don't break encapsulation",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"because objects are accessed solely through their interfaces"))),(0,i.kt)("li",{parentName:"ul"},"will have more objects (if fewer classes)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"system's behavior will depend on their interrelationships instead of being defined in one's class"))))),(0,i.kt)("li",{parentName:"ul"},"ideally, shouldn't be creating new components to achieve reuse"),(0,i.kt)("li",{parentName:"ul"},"should be able to get all functionality needed just by assembling existing components through object composition")))))),(0,i.kt)("h4",{id:"delegation"},"Delegation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It is a way of making composition as powerful for reuse as inheritance"),(0,i.kt)("li",{parentName:"ul"},"In delegation, 2 objects are involved in handling a request: a receiving object delegates operations to its delegate",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this is analogous to subclasses deferring requests to parent classes"),(0,i.kt)("li",{parentName:"ul"},"in order to receive the effect similar to inheritance when referring to receiving object through the this (self) variable",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the receiver passes itself to the delegate to let the delegated operation refer to the receiver"))))),(0,i.kt)("li",{parentName:"ul"},"advantage",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"it makes it easy to compose behaviors at run time & to change the way they're composed"))),(0,i.kt)("li",{parentName:"ul"},"disadvantage",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"dynamic, highly parameterized software is harder to understand than more static software"),(0,i.kt)("li",{parentName:"ul"},"there are also run time inefficiencies (but human inefficiencies are more important in the long run)"))),(0,i.kt)("li",{parentName:"ul"},"delegation is a good design choice only when it simplifies more than it complicates",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"effectiveness depends on the context & experience on it"),(0,i.kt)("li",{parentName:"ul"},"delegation works best when it's used in highly stylized ways used in standard patterns",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"State pattern: an object delegates request to a State object that represents its current state",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"purpose is to change the behavior of an object by changing the objects to which it delegates requests"))),(0,i.kt)("li",{parentName:"ul"},"Strategy pattern: an object delegates a specific request to an object that represents a strategy for carrying out the request",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"an object will only have 1 state, but it can have many strategies for different requests"),(0,i.kt)("li",{parentName:"ul"},"purpose is to change the behavior of an object by changing the objects to which it delegates requests"))),(0,i.kt)("li",{parentName:"ul"},"Visitor pattern: the operation that gets performed on each element of an object structure is always delegated to the Visitor object"))),(0,i.kt)("li",{parentName:"ul"},"patterns that use delegation less heavily",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Mediator pattern: introduces an object to mediate communication between other objects",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"sometimes the Mediator object implements operations by forwarding them to other objects"),(0,i.kt)("li",{parentName:"ul"},"other times, it passes along a reference to itself & thus uses true delegation"))),(0,i.kt)("li",{parentName:"ul"},"Chain of Responsibility pattern: handles request by forwarding them from 1 object to another along a chain of objects",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"sometimes this request carries with it a reference to the original object receiving the request (using delegation)"))),(0,i.kt)("li",{parentName:"ul"},"Bridge pattern: decouples an abstraction from its implementation",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"if the abstraction & a particular implementation are closely matched,"),(0,i.kt)("li",{parentName:"ul"},"then the abstraction may simply delegate operations to that implementation"))))))),(0,i.kt)("li",{parentName:"ul"},"Delegation is an extreme example of object composition",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"it shows that you can always replace inheritance with object composition as a mechanism for code reuse")))),(0,i.kt)("h4",{id:"inheritance-vs-parameterized-types"},"Inheritance vs Parameterized types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Parameterized types: another technique for reusing functionality",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'also known as "generics" and "templates"'),(0,i.kt)("li",{parentName:"ul"},"lets you define a type without specifying all the other types it uses",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the unspecified types are supplied as parameters at the point of reuse"))),(0,i.kt)("li",{parentName:"ul"},"gives us a 3rd way (in addition to class inheritance & object composition) to compose behavior in object oriented systems"),(0,i.kt)("li",{parentName:"ul"},"differences between object composition, class inheritance, and parameterized types",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"object composition allows changes of behavior being composed at run time, but requires indirection & can be less efficient"),(0,i.kt)("li",{parentName:"ul"},"class inheritance lets your provide default implementations for operations & lets subclasses override them",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"can not change at run time"))),(0,i.kt)("li",{parentName:"ul"},"parameterized types lets you change the types that a class can use",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"can not change at run time"))))),(0,i.kt)("li",{parentName:"ul"},"Parametrized types aren't needed in languages that doesn't have compile time type checking")))),(0,i.kt)("h4",{id:"relating-run-time--compile-time-structures"},"Relating Run time & Compile time structures"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Run time structure: often bears little resemblance to its code structure",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"it consists of rapidly changing networks of communicating objects"),(0,i.kt)("li",{parentName:"ul"},"Composite pattern & Decorator pattern are useful for building complex run time structures"),(0,i.kt)("li",{parentName:"ul"},"Observer pattern involves run time structures that are often hard to understand unless you know the pattern"),(0,i.kt)("li",{parentName:"ul"},"Chain of Responsibility pattern also results in communication patterns that inheritance doesn't reveal"),(0,i.kt)("li",{parentName:"ul"},"in general, run time structures aren't clear from the code until you understand the patterns"))),(0,i.kt)("li",{parentName:"ul"},"Compile time structure: code structure is frozen at compile time",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"it consists of classes in fixed inheritance relationships"))),(0,i.kt)("li",{parentName:"ul"},"Consider the distinction between object aggregation & acquaintance, & how differently they manifest themselves at compile & run times",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Aggregation: implies that 1 object owns or is responsible for another object",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"implies that an aggregate object & its owner have identical lifetimes"),(0,i.kt)("li",{parentName:"ul"},"aggregation can be implemented by defining member variables that are real instances"),(0,i.kt)("li",{parentName:"ul"},"but is more common to define them as pointers or references to instances"),(0,i.kt)("li",{parentName:"ul"},"tend to be fewer & more permanent than acquaintance"))),(0,i.kt)("li",{parentName:"ul"},"Acquaintance: implies that an object merely knows of another object",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'also called as "association" or the "using" relationship'),(0,i.kt)("li",{parentName:"ul"},"acquainted objects may request operations of each other, but are not responsible for each other"),(0,i.kt)("li",{parentName:"ul"},"acquaintance is a weaker relationship than aggregation & suggest much looser coupling between objects"),(0,i.kt)("li",{parentName:"ul"},"acquaintance is implemented with pointers & references"),(0,i.kt)("li",{parentName:"ul"},"made and remade more frequently, sometimes existing only for the duration of an operation"),(0,i.kt)("li",{parentName:"ul"},"more dynamic, making them more difficult to discern in the source code"))),(0,i.kt)("li",{parentName:"ul"},"aggregation & acquaintance are often implemented in the same way"),(0,i.kt)("li",{parentName:"ul"},"both are determined more by intent than by explicit language mechanism")))),(0,i.kt)("h4",{id:"designing-for-change"},"Designing for change"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Key to maximizing reuse lines is in anticipating new requirements & changes to existing requirements",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"and in designing systems that can evolve accordingly"))),(0,i.kt)("li",{parentName:"ul"},"To design a system that is robust to changes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"need to consider how the system might need to change over its lifetime"),(0,i.kt)("li",{parentName:"ul"},"a design that doesn't take change into account risks major redesign in the future"),(0,i.kt)("li",{parentName:"ul"},"changes might involve class redefinition & implementation, client modification, & retesting"),(0,i.kt)("li",{parentName:"ul"},"redesign affects many parts of software system, & unanticipated changes are expensive"))),(0,i.kt)("li",{parentName:"ul"},"Common causes of redesign and design patterns as solutions",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Creating an object by specifying a class explicitly",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this commits you to an implementation than to an interface, thus complicating future changes"),(0,i.kt)("li",{parentName:"ul"},"solution: create objects indirectly",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Abstract Factory, Factory method, Prototype"))))),(0,i.kt)("li",{parentName:"ol"},"Dependence on specific operations",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this commits you to 1 way of satisfying a request"),(0,i.kt)("li",{parentName:"ul"},"solution: avoid hard coded requests, making it easier to change the way a request gets satisfied at compile and run time",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Chain of Responsibility, Command"))))),(0,i.kt)("li",{parentName:"ol"},"Dependence on hardware & software platform",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"external OS interfaces & APIs are different on different hardware & software platforms"),(0,i.kt)("li",{parentName:"ul"},"software that depends on a particular platform will be harder to port to other platforms"),(0,i.kt)("li",{parentName:"ul"},"difficult to keep it up to data on its native platform"),(0,i.kt)("li",{parentName:"ul"},"solution: important to design the system to limit its platform dependencies",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Abstract Factory, Bridge"))))),(0,i.kt)("li",{parentName:"ol"},"Dependence on object representations or implementations",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"clients knowing how object is represented, stored, located, or implemented might need to be changed when object changes"),(0,i.kt)("li",{parentName:"ul"},"solution: hiding this information from clients keeps changes from cascading",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Abstract Factory, Bridge, Memento, Proxy"))))),(0,i.kt)("li",{parentName:"ol"},"Algorithmic dependencies",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"algorithms are often extended, optimized, and replaced during development & reuse"),(0,i.kt)("li",{parentName:"ul"},"objects that depend on algorithm will have to change when algorithm changes"),(0,i.kt)("li",{parentName:"ul"},"solution: isolate algorithms that are likely to change",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Builder, Iterator, Strategy, Template Method, Visitor"))))),(0,i.kt)("li",{parentName:"ol"},"Tight coupling",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"classes that are tightly coupled are hard to reuse in isolation, since they depend on each other"),(0,i.kt)("li",{parentName:"ul"},"tight coupling leads to monolithic systems, can't change or remove class without understanding & changing other classes"),(0,i.kt)("li",{parentName:"ul"},"System becomes a dense mass that's hard to learn, port, and maintain"),(0,i.kt)("li",{parentName:"ul"},"solution: loose coupling increases the probability that a class can be reused by itself",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"& that a system can be learned, ported, modified, & extended more easily"),(0,i.kt)("li",{parentName:"ul"},"design patterns use techniques such as abstract coupling & layering to promote loosely coupled systems"),(0,i.kt)("li",{parentName:"ul"},"Abstract Factory, Bridge, Chain of Responsibility, Command, Facade, Mediator, Observer"))))),(0,i.kt)("li",{parentName:"ol"},"Extending functionality by subclassing",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"customizing an object by subclassing isn't easy as every new class has a fixed implementation overhead"),(0,i.kt)("li",{parentName:"ul"},"defining a subclass also requires an in depth understanding of the parent class",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"overriding 1 operation might require overriding another"),(0,i.kt)("li",{parentName:"ul"},"an overridden operation might be required to call an inherited operation"),(0,i.kt)("li",{parentName:"ul"},"subclassing can lead to an explosion of classes,"),(0,i.kt)("li",{parentName:"ul"},"because you might have to introduce many new subclasses for even a simple extension"))),(0,i.kt)("li",{parentName:"ul"},"solution: object composition & delegation provide flexible alternatives to inheritance for combining behavior",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"add new functionality to application by composing existing objects in new ways than defining new subclasses of existing classes"),(0,i.kt)("li",{parentName:"ul"},"heavy use of object composition can make designs harder to understand",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"thus design patterns produce designs where you can introduce customized functionality by defining 1 subclass"),(0,i.kt)("li",{parentName:"ul"},"& composing its instances with existing ones"))),(0,i.kt)("li",{parentName:"ul"},"Bridge, Chain of Responsibility, Composite, Decorator, Observer, Strategy"))))),(0,i.kt)("li",{parentName:"ol"},"Inability to alter classes conveniently",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"sometimes have to modify a class that can't be modified conveniently"),(0,i.kt)("li",{parentName:"ul"},"might need the source code, but don't have it"),(0,i.kt)("li",{parentName:"ul"},"any change would require modifying lots of existing subclasses"),(0,i.kt)("li",{parentName:"ul"},"solution: Use Adapter, Decorator, Visitor design patterns during such circumstances"))))),(0,i.kt)("li",{parentName:"ul"},"the role design patterns play in the development of 3 broad classes of software: application programs, toolkits, frameworks",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Application programs",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"internal reuse, maintainability, & extension are high priorities when building apps: document editor or spreadsheet",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"ensures that you don't design & implement more than you have to"))),(0,i.kt)("li",{parentName:"ul"},"design patterns make an app more maintainable when they're used to limit platform dependencies & to layer a system",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"they enhance extensibility by showing you how to extend class hierarchies & how to exploit object composition"))))),(0,i.kt)("li",{parentName:"ol"},"Toolkits",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"a set of related & reusable classes designed to provide useful, general purpose functionality",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"e.g.: a set of collection classes for lists, associative tables, stacks"))),(0,i.kt)("li",{parentName:"ul"},"toolkit is used by writing the main body of the app & calling the code from the toolkit to reuse"),(0,i.kt)("li",{parentName:"ul"},"it does not impose a particular design on the app"),(0,i.kt)("li",{parentName:"ul"},"it just provide functionality that can help the app do its job"),(0,i.kt)("li",{parentName:"ul"},"it also lets you as an implementer avoid recoding common functionality"),(0,i.kt)("li",{parentName:"ul"},"emphasize on code reuse, are object oriented equivalent of subroutine libraries"),(0,i.kt)("li",{parentName:"ul"},"Toolkit design is harder than app design, as toolkits have to work in many apps to be useful",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"moreover, toolkit writer won't know what the will be or special needs of apps designed by others"),(0,i.kt)("li",{parentName:"ul"},"is important to avoid assumptions & dependencies that limits toolkit's flexibility, applicability & effectiveness"))))),(0,i.kt)("li",{parentName:"ol"},"Frameworks",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"it is a set of cooperating classes that make up a reusable design for a specific class of software",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"a framework can be geared toward building graphical editors for different domains"),(0,i.kt)("li",{parentName:"ul"},"another framework can help build compilers for different programming languages & target machines"),(0,i.kt)("li",{parentName:"ul"},"another might help build financial modeling applications"),(0,i.kt)("li",{parentName:"ul"},"A framework can be customized to a particular app",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"by creating app specific subclasses of abstract classes from the framework"))))),(0,i.kt)("li",{parentName:"ul"},"framework is used by reusing main body & writing the code it calls",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"have to write operations with particular names & calling conventions"),(0,i.kt)("li",{parentName:"ul"},"this reduces the design decisions you have to make"),(0,i.kt)("li",{parentName:"ul"},"framework will allow building of apps faster, but apps will have similar structure",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"easier to maintain, are more consistent to users"),(0,i.kt)("li",{parentName:"ul"},"however, will lose creative freedom, since many design decisions have been made for you"))))),(0,i.kt)("li",{parentName:"ul"},"framework dictates the architecture of the app",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"it defines the overall structure, its partitioning into classes & objects"),(0,i.kt)("li",{parentName:"ul"},"the key responsibilities: how classes & objects collaborate"),(0,i.kt)("li",{parentName:"ul"},"the thread of control"),(0,i.kt)("li",{parentName:"ul"},"framework predefine the above design parameters so that the designer can focus on specifics of the app"),(0,i.kt)("li",{parentName:"ul"},"framework captures the design decisions that are common to its application domain"),(0,i.kt)("li",{parentName:"ul"},"thus framework emphasize design reuse over code reuse",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"however, framework will usually include concrete subclasses that can be used immediately"))),(0,i.kt)("li",{parentName:"ul"},"imperative to design the framework to be a flexible & extensible as possible"))),(0,i.kt)("li",{parentName:"ul"},"a framework that addresses loose coupling by using design patterns will achieve high levels of design & code reuse"),(0,i.kt)("li",{parentName:"ul"},"people who know the design patterns the framework uses will gain insight into the framework faster"),(0,i.kt)("li",{parentName:"ul"},"3 major difference between design patterns and frameworks",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Design patterns are more abstract than frameworks",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"frameworks can be embodied in code, but only examples of patterns can be embodied in code"),(0,i.kt)("li",{parentName:"ul"},"adv of framework is that they can be written down in programming languages",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"& can be studied, executed, & reused directly"))),(0,i.kt)("li",{parentName:"ul"},"design patterns have to be implemented each time they're used",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"it also explain the intent, trade-offs, & consequences of a design"))))),(0,i.kt)("li",{parentName:"ol"},"Design patterns are smaller architectural elements than frameworks",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"a typical framework contains several design patterns, but the reverse is never true"))),(0,i.kt)("li",{parentName:"ol"},"Design patterns are less specialized than frameworks",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"frameworks always have a particular application domain",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"a graphical editor framework used in factory simulation, won't be mistaken for a simulation framework"))),(0,i.kt)("li",{parentName:"ul"},"design patterns can be used in nearly any kind of application",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"although specialized design patterns are possible, it won't dictate an app architecture like a framework"))))))),(0,i.kt)("li",{parentName:"ul"},"frameworks are becoming important to allow object oriented systems to achieve the most reuse")))))),(0,i.kt)("h3",{id:"how-to-select-a-design-pattern"},"How to select a Design Pattern"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Consider how design patterns solve design problems"),(0,i.kt)("li",{parentName:"ol"},"Scan intent sections"),(0,i.kt)("li",{parentName:"ol"},"Study how patterns interrelate"),(0,i.kt)("li",{parentName:"ol"},"Study patterns of like purpose"),(0,i.kt)("li",{parentName:"ol"},"Examine a cause of redesign"),(0,i.kt)("li",{parentName:"ol"},"Consider what should be variable in your design",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this is opposite of focusing on cause of redesign"),(0,i.kt)("li",{parentName:"ul"},"consider what you want to be able to change without redesign, instead of what might force a change to a design",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the focus is on encapsulating the concept that varies")))))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Purpose"),(0,i.kt)("th",{parentName:"tr",align:null},"Design Pattern"),(0,i.kt)("th",{parentName:"tr",align:null},"Aspect(s) that can vary"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Creational"),(0,i.kt)("td",{parentName:"tr",align:null},"Abstract Factory"),(0,i.kt)("td",{parentName:"tr",align:null},"families of product objects")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Builder"),(0,i.kt)("td",{parentName:"tr",align:null},"how a composite object gets created")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Factory Method"),(0,i.kt)("td",{parentName:"tr",align:null},"subclass of object that is instantiated")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Prototype"),(0,i.kt)("td",{parentName:"tr",align:null},"class of object that is instantiated")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Singleton"),(0,i.kt)("td",{parentName:"tr",align:null},"the sole instance of a class")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Structural"),(0,i.kt)("td",{parentName:"tr",align:null},"Adapter"),(0,i.kt)("td",{parentName:"tr",align:null},"interface to an object")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Bridge"),(0,i.kt)("td",{parentName:"tr",align:null},"implementation to an object")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Composite"),(0,i.kt)("td",{parentName:"tr",align:null},"structure and composition of an object")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Decorator"),(0,i.kt)("td",{parentName:"tr",align:null},"responsibilities of an object without subclassing")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Facade"),(0,i.kt)("td",{parentName:"tr",align:null},"interface to a subsystem")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Flyweight"),(0,i.kt)("td",{parentName:"tr",align:null},"storage costs of objects")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Proxy"),(0,i.kt)("td",{parentName:"tr",align:null},"how an object is accessed; its location")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Behavioral"),(0,i.kt)("td",{parentName:"tr",align:null},"Chain of Responsibility"),(0,i.kt)("td",{parentName:"tr",align:null},"object that can fulfill a request")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Command"),(0,i.kt)("td",{parentName:"tr",align:null},"when and how a request is fulfilled")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Interpreter"),(0,i.kt)("td",{parentName:"tr",align:null},"grammar and interpretation of a language")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Iterator"),(0,i.kt)("td",{parentName:"tr",align:null},"how an aggregate's elements are accessed, traversed")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Mediator"),(0,i.kt)("td",{parentName:"tr",align:null},"how and which objects interact with each other")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Memento"),(0,i.kt)("td",{parentName:"tr",align:null},"what private information is stored outside an object, and when")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Observer"),(0,i.kt)("td",{parentName:"tr",align:null},"No. of objects that depend on another object; how the dependent objects stay up to date")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"State"),(0,i.kt)("td",{parentName:"tr",align:null},"states of an object")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Strategy"),(0,i.kt)("td",{parentName:"tr",align:null},"an algorithm")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Template Method"),(0,i.kt)("td",{parentName:"tr",align:null},"steps of an algorithm")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Visitor"),(0,i.kt)("td",{parentName:"tr",align:null},"operations that can be applied to object(S) without changing their class(es)")))),(0,i.kt)("h3",{id:"how-to-use-a-design-pattern"},"How to use a Design Pattern"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Read the pattern once through for an overview",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"pay attention to the Applicability & Consequences section to ensure the pattern is right for the problem"))),(0,i.kt)("li",{parentName:"ol"},"Go back & study the Structure, Participants, & Collaborations sections",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"make sure to understand the classes & objects in the pattern & how they related to each other"))),(0,i.kt)("li",{parentName:"ol"},"Look at the Sample Code section to see a concrete example of the pattern in code"),(0,i.kt)("li",{parentName:"ol"},"Choose names for pattern participants that are meaningful in the application context"),(0,i.kt)("li",{parentName:"ol"},"Define the classes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"declare their interfaces,"),(0,i.kt)("li",{parentName:"ul"},"establish their inheritance relationships,"),(0,i.kt)("li",{parentName:"ul"},"define the instance variable that represents data & object references"),(0,i.kt)("li",{parentName:"ul"},"identify existing classes in app that pattern will affect, and modify accordingly"))),(0,i.kt)("li",{parentName:"ol"},"Define application specific names for operations in the pattern",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"use the responsibilities & collaboration associated with each operation as a guide"))),(0,i.kt)("li",{parentName:"ol"},"Implement the operations to carry out the responsibilities & collaborations in the pattern")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Design patterns should not be applied indiscriminately"),(0,i.kt)("li",{parentName:"ul"},"It can complicate design & or cost performance to achieve flexibility & variability by introducing additional levels of indirection"),(0,i.kt)("li",{parentName:"ul"},"Design patterns should only be applied when the flexibility is really needed")))}u.isMDXComponent=!0},19104:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/design_pattern_relationships-3767ac9e67cc2d35693a6bc4552b8f87.png"}}]);