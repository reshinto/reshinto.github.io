"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[83202],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>u});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=o.createContext({}),l=function(e){var n=o.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=l(e.components);return o.createElement(c.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=l(t),u=r,h=d["".concat(c,".").concat(u)]||d[u]||m[u]||a;return t?o.createElement(h,s(s({ref:n},p),{},{components:t})):o.createElement(h,s({ref:n},p))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,s=new Array(a);s[0]=d;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var l=2;l<a;l++)s[l]=t[l];return o.createElement.apply(null,s)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},41561:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var o=t(83117),r=(t(67294),t(3905));const a={},s="C++ Example",i={unversionedId:"interviewPrep/designPatterns/Structural_patterns/Composite/cPlusPlus/readme",id:"interviewPrep/designPatterns/Structural_patterns/Composite/cPlusPlus/readme",title:"C++ Example",description:"",source:"@site/docs/interviewPrep/designPatterns/Structural_patterns/Composite/cPlusPlus/readme.md",sourceDirName:"interviewPrep/designPatterns/Structural_patterns/Composite/cPlusPlus",slug:"/interviewPrep/designPatterns/Structural_patterns/Composite/cPlusPlus/",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Composite/cPlusPlus/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Structural_patterns/Composite/cPlusPlus/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Composite",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Composite/"},next:{title:"C# Example",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Composite/cSharp/"}},c={},l=[],p={toc:l};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"c-example"},"C++ Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <algorithm>\n#include <iostream>\n#include <list>\n#include <string>\n/**\n * Composite Design Pattern\n *\n * Intent: Lets you compose objects into tree structures and then work with\n * these structures as if they were individual objects.\n */\n/**\n * The base Component class declares common operations for both simple and\n * complex objects of a composition.\n */\nclass Component {\n  /**\n   * @var Component\n   */\n protected:\n  Component *parent_;\n  /**\n   * Optionally, the base Component can declare an interface for setting and\n   * accessing a parent of the component in a tree structure. It can also\n   * provide some default implementation for these methods.\n   */\n public:\n  virtual ~Component() {}\n  void SetParent(Component *parent) {\n    this->parent_ = parent;\n  }\n  Component *GetParent() const {\n    return this->parent_;\n  }\n  /**\n   * In some cases, it would be beneficial to define the child-management\n   * operations right in the base Component class. This way, you won\'t need to\n   * expose any concrete component classes to the client code, even during the\n   * object tree assembly. The downside is that these methods will be empty for\n   * the leaf-level components.\n   */\n  virtual void Add(Component *component) {}\n  virtual void Remove(Component *component) {}\n  /**\n   * You can provide a method that lets the client code figure out whether a\n   * component can bear children.\n   */\n  virtual bool IsComposite() const {\n    return false;\n  }\n  /**\n   * The base Component may implement some default behavior or leave it to\n   * concrete classes (by declaring the method containing the behavior as\n   * "abstract").\n   */\n  virtual std::string Operation() const = 0;\n};\n/**\n * The Leaf class represents the end objects of a composition. A leaf can\'t have\n * any children.\n *\n * Usually, it\'s the Leaf objects that do the actual work, whereas Composite\n * objects only delegate to their sub-components.\n */\nclass Leaf : public Component {\n public:\n  std::string Operation() const override {\n    return "Leaf";\n  }\n};\n/**\n * The Composite class represents the complex components that may have children.\n * Usually, the Composite objects delegate the actual work to their children and\n * then "sum-up" the result.\n */\nclass Composite : public Component {\n  /**\n   * @var \\SplObjectStorage\n   */\n protected:\n  std::list<Component *> children_;\n\n public:\n  /**\n   * A composite object can add or remove other components (both simple or\n   * complex) to or from its child list.\n   */\n  void Add(Component *component) override {\n    this->children_.push_back(component);\n    component->SetParent(this);\n  }\n  /**\n   * Have in mind that this method removes the pointer to the list but doesn\'t\n   * frees the\n   *     memory, you should do it manually or better use smart pointers.\n   */\n  void Remove(Component *component) override {\n    children_.remove(component);\n    component->SetParent(nullptr);\n  }\n  bool IsComposite() const override {\n    return true;\n  }\n  /**\n   * The Composite executes its primary logic in a particular way. It traverses\n   * recursively through all its children, collecting and summing their results.\n   * Since the composite\'s children pass these calls to their children and so\n   * forth, the whole object tree is traversed as a result.\n   */\n  std::string Operation() const override {\n    std::string result;\n    for (const Component *c : children_) {\n      if (c == children_.back()) {\n        result += c->Operation();\n      } else {\n        result += c->Operation() + "+";\n      }\n    }\n    return "Branch(" + result + ")";\n  }\n};\n/**\n * The client code works with all of the components via the base interface.\n */\nvoid ClientCode(Component *component) {\n  // ...\n  std::cout << "RESULT: " << component->Operation();\n  // ...\n}\n\n/**\n * Thanks to the fact that the child-management operations are declared in the\n * base Component class, the client code can work with any component, simple or\n * complex, without depending on their concrete classes.\n */\nvoid ClientCode2(Component *component1, Component *component2) {\n  // ...\n  if (component1->IsComposite()) {\n    component1->Add(component2);\n  }\n  std::cout << "RESULT: " << component1->Operation();\n  // ...\n}\n\n/**\n * This way the client code can support the simple leaf components...\n */\n\nint main() {\n  Component *simple = new Leaf;\n  std::cout << "Client: I\'ve got a simple component:\\n";\n  ClientCode(simple);\n  std::cout << "\\n\\n";\n  /**\n   * ...as well as the complex composites.\n   */\n\n  Component *tree = new Composite;\n  Component *branch1 = new Composite;\n\n  Component *leaf_1 = new Leaf;\n  Component *leaf_2 = new Leaf;\n  Component *leaf_3 = new Leaf;\n  branch1->Add(leaf_1);\n  branch1->Add(leaf_2);\n  Component *branch2 = new Composite;\n  branch2->Add(leaf_3);\n  tree->Add(branch1);\n  tree->Add(branch2);\n  std::cout << "Client: Now I\'ve got a composite tree:\\n";\n  ClientCode(tree);\n  std::cout << "\\n\\n";\n\n  std::cout << "Client: I don\'t need to check the components classes even when managing the tree:\\n";\n  ClientCode2(tree, simple);\n  std::cout << "\\n";\n\n  delete simple;\n  delete tree;\n  delete branch1;\n  delete branch2;\n  delete leaf_1;\n  delete leaf_2;\n  delete leaf_3;\n\n  return 0;\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Client: I've got a simple component:\nRESULT: Leaf\n\nClient: Now I've got a composite tree:\nRESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf))\n\nClient: I don't need to check the components classes even when managing the tree:\nRESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf)+Leaf)\n")))}m.isMDXComponent=!0}}]);