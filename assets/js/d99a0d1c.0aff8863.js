"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[43364],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>f});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),p=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=p(e.components);return o.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,l=a(e,["components","mdxType","originalType","parentName"]),h=p(n),f=r,d=h["".concat(c,".").concat(f)]||h[f]||m[f]||i;return n?o.createElement(d,s(s({ref:t},l),{},{components:n})):o.createElement(d,s({ref:t},l))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=h;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a.mdxType="string"==typeof e?e:r,s[1]=a;for(var p=2;p<i;p++)s[p]=n[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},20104:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>a,toc:()=>p});var o=n(83117),r=(n(67294),n(3905));const i={},s="Python Example",a={unversionedId:"interviewPrep/designPatterns/Behavioral_patterns/Visitor/python/readme",id:"interviewPrep/designPatterns/Behavioral_patterns/Visitor/python/readme",title:"Python Example",description:"",source:"@site/docs/interviewPrep/designPatterns/Behavioral_patterns/Visitor/python/readme.md",sourceDirName:"interviewPrep/designPatterns/Behavioral_patterns/Visitor/python",slug:"/interviewPrep/designPatterns/Behavioral_patterns/Visitor/python/",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Visitor/python/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Behavioral_patterns/Visitor/python/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"JavaScript Example",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Visitor/javascript/"},next:{title:"Swift Example",permalink:"/docs/interviewPrep/designPatterns/Behavioral_patterns/Visitor/swift/"}},c={},p=[],l={toc:p};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"python-example"},"Python Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'"""\nVisitor Design Pattern\n\nIntent: Lets you separate algorithms from the objects on which they operate.\n"""\n\n\nfrom __future__ import annotations\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\n\nclass Component(ABC):\n    """\n    The Component interface declares an `accept` method that should take the\n    base visitor interface as an argument.\n    """\n\n    @abstractmethod\n    def accept(self, visitor: Visitor) -> None:\n        pass\n\n\nclass ConcreteComponentA(Component):\n    """\n    Each Concrete Component must implement the `accept` method in such a way\n    that it calls the visitor\'s method corresponding to the component\'s class.\n    """\n\n    def accept(self, visitor: Visitor) -> None:\n        """\n        Note that we\'re calling `visitConcreteComponentA`, which matches the\n        current class name. This way we let the visitor know the class of the\n        component it works with.\n        """\n\n        visitor.visit_concrete_component_a(self)\n\n    def exclusive_method_of_concrete_component_a(self) -> str:\n        """\n        Concrete Components may have special methods that don\'t exist in their\n        base class or interface. The Visitor is still able to use these methods\n        since it\'s aware of the component\'s concrete class.\n        """\n\n        return "A"\n\n\nclass ConcreteComponentB(Component):\n    """\n    Same here: visitConcreteComponentB => ConcreteComponentB\n    """\n\n    def accept(self, visitor: Visitor):\n        visitor.visit_concrete_component_b(self)\n\n    def special_method_of_concrete_component_b(self) -> str:\n        return "B"\n\n\nclass Visitor(ABC):\n    """\n    The Visitor Interface declares a set of visiting methods that correspond to\n    component classes. The signature of a visiting method allows the visitor to\n    identify the exact class of the component that it\'s dealing with.\n    """\n\n    @abstractmethod\n    def visit_concrete_component_a(self, element: ConcreteComponentA) -> None:\n        pass\n\n    @abstractmethod\n    def visit_concrete_component_b(self, element: ConcreteComponentB) -> None:\n        pass\n\n\n"""\nConcrete Visitors implement several versions of the same algorithm, which can\nwork with all concrete component classes.\n\nYou can experience the biggest benefit of the Visitor pattern when using it with\na complex object structure, such as a Composite tree. In this case, it might be\nhelpful to store some intermediate state of the algorithm while executing\nvisitor\'s methods over various objects of the structure.\n"""\n\n\nclass ConcreteVisitor1(Visitor):\n    def visit_concrete_component_a(self, element) -> None:\n        print(f"{element.exclusive_method_of_concrete_component_a()} + ConcreteVisitor1")\n\n    def visit_concrete_component_b(self, element) -> None:\n        print(f"{element.special_method_of_concrete_component_b()} + ConcreteVisitor1")\n\n\nclass ConcreteVisitor2(Visitor):\n    def visit_concrete_component_a(self, element) -> None:\n        print(f"{element.exclusive_method_of_concrete_component_a()} + ConcreteVisitor2")\n\n    def visit_concrete_component_b(self, element) -> None:\n        print(f"{element.special_method_of_concrete_component_b()} + ConcreteVisitor2")\n\n\ndef client_code(components: List[Component], visitor: Visitor) -> None:\n    """\n    The client code can run visitor operations over any set of elements without\n    figuring out their concrete classes. The accept operation directs a call to\n    the appropriate operation in the visitor object.\n    """\n\n    # ...\n    for component in components:\n        component.accept(visitor)\n    # ...\n\n\nif __name__ == "__main__":\n    components = [ConcreteComponentA(), ConcreteComponentB()]\n\n    print("The client code works with all visitors via the base Visitor interface:")\n    visitor1 = ConcreteVisitor1()\n    client_code(components, visitor1)\n\n    print("It allows the same client code to work with different types of visitors:")\n    visitor2 = ConcreteVisitor2()\n    client_code(components, visitor2)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"The client code works with all visitors via the base Visitor interface:\nA + ConcreteVisitor1\nB + ConcreteVisitor1\nIt allows the same client code to work with different types of visitors:\nA + ConcreteVisitor2\nB + ConcreteVisitor2\n")))}m.isMDXComponent=!0}}]);