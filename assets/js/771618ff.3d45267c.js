"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[3598],{32498:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});var a=t(67294),o=t(57735);const s=[{mainQuestion:"How can you improve the following code? Provide explanations as to why your suggested improvement is better.",subQuestions:[],codeExample:"fun bark(dog: Map<String, Any>, dogName: String) {\n    // ...\n}\n\nfun run(dog: Map<String, Any>, dogName: String) {\n    // ...\n}\n\nfun wagTail(dog: Map<String, Any>, dogName: String) {\n    // ...\n}",answer:"",codeAnswer:'// the following code is better because each action function can do its own thing\n// and does not need to keep repeating the same arguments\n\n// declare the following 2 lines as a constant since it will never change\nval dog: Map<String, Any> = mapOf()\nval dogName: String = ""\n\n// removed common arguments\nfun bark() {\n    // ...\n}\n\n// removed common arguments\nfun run() {\n    // ...\n}\n\n// removed common arguments\nfun wagTail() {\n    // ...\n}    \n'},{mainQuestion:"What does this do? Describe the underpinning concepts/features/functionalities that make this possible.",subQuestions:[{question:"What do you get as the return value of fn()?",ans:a.createElement(a.Fragment,null,a.createElement("p",null,"first it will print"," ",a.createElement("b",null,a.createElement("i",null,"Hello stranger! Here's the content:"))),a.createElement("p",null,"then it will return"," ",a.createElement("b",null,a.createElement("i",null,"Promise\xa0{<pending>}"))))},{question:"How to print out the fetched content from fn() , after it is done with its operations?",ans:""}],codeExample:"function maker(x) {\n  return async (url) => {\n    console.log(`Hello ${x}! Here's the content:`)\n    const resp = await fetch(url)\n    const result = await resp.text()\n    return result\n  }\n}\n\nconst fn = maker('stranger')\nfn('https://brave.com')",answer:"    It is a Higher order function because it returns the function as output\n    It is also a closure because it gives access to an outer function's scope from an inner function\n    - The maker is synchronous and returns an Asynchronous function\n    - It takes in an argument x which is used to update the string value inside the anonymous function that is being returned\n    - It allows modification of the inner function contents from the outer function\n    - It allows access to the inner function before being executed, which also allows us to modify the contents of the inner function\n    ",codeAnswer:"function maker(x) {\n  return async (url) => {\n    console.log(`Hello ${x}! Here's the content:`);\n    const resp = await fetch(url);\n    const result = await resp.text();\n    return result;\n  }\n}\n\nasync function run() {\n  const fn = maker(\"stranger\");\n  console.log(await fn('https://brave.com'));\n}\n\nrun();\n"},{mainQuestion:"How can you improve the following code? Provide explanations as to why your suggested improvement is better.",subQuestions:[],codeExample:'class LocalStorage {\n    fun saveFile(input: InputStream, fileName: String) {\n        // ...\n    }\n}\n\nclass CloudStorage {\n    fun saveFile(input: InputStream, fileName: String) {\n        // ...\n    }\n}\n\nfun main(args: Array<String>) {\n    if (args.isNotEmpty() && args.size >= 3) {\n        val file = FileInputStream(args[1])\n        val fileName = args[2]\n        file.use {\n            if (args[0] == "cloud") {\n                val cloud = CloudStorage()\n                cloud.saveFile(it, fileName)\n            } else if (args[0] == "local") {\n                val local = LocalStorage()\n                local.saveFile(it, filename)\n            }\n        }\n    } else {\n        println("Please specify destination type, path to file, and filename.")\n    }\n}',answer:"",codeAnswer:'// ensures all Storage class follow the same format\ninterface StorageInterface {\n    fun saveFile(input: InputStream, fileName: String)\n}\n\n// Overrides the saveFile method from the StorageInterface\nclass LocalStorage : StorageInterface {\n    override fun saveFile(input: InputStream, fileName: String) {\n        // ...\n    }\n}\n\n// Overrides the saveFile method from the StorageInterface\nclass CloudStorage : StorageInterface {\n    override fun saveFile(input: InputStream, fileName: String) {\n        // ...\n    }\n}\n\n// Uses a factory design pattern to return the instance of the desired storage type\n// adding and removing of supported storage type is easy\nclass Storage {\n    companion object {\n       fun getStorage(cloudType: String): StorageInterface {\n           return when (cloudType) {\n               "cloud" -> CloudStorage()\n               else -> LocalStorage()\n           }\n       }\n    }\n}\n\nfun main(args: Array<String>) {\n    if (args.isNotEmpty() && args.size >= 3) {\n        val file = FileInputStream(args[1])\n        val fileName = args[2]\n        file.use {\n            // only need to call these 2 lines of code once and no future modifications are required\n            val storage = Storage.getStorage(args[0])\n            storage.saveFile(it, filename)\n        }\n    } else {\n        println("Please specify destination type, path to file, and filename.")\n    }\n}\n'},{mainQuestion:"Synchronous programming and asynchronous programming",subQuestions:[{question:"What are they?",ans:"They are techniques in how to handle tasks in the program"},{question:"What are their key differences, pros and cons?",ans:"        Key differences:\n          Synchronous: each task gets executed one after another and must wait for its previous task to be completed before it can be executed\n          pros:\n          - easier to understand\n          - supported by all programming languages\n          - easier to manage and debug\n          cons:\n          - blocking: tasks must complete before the next task can be executed\n          - slower and more methodical\n          - if a task fails, the subsequent tasks will not be executed\n          - more resources might be needed to execute the tasks\n\n          Asynchronous: tasks start executing without waiting for a different task to finish \n          pros:\n          - non-blocking: each task can be handled in parallel\n          - failure of one task does not affect the execution of the other tasks\n          - less resources are required to execute the tasks\n          cons:\n          - might be difficult to implement in some programming languages\n          - code can get messy and difficult to debug\n        "},{question:"Which one do you prefer and why?",ans:"        Depends on the problem and the programming language\n        There is no one best answer, its all about understanding the tradeoffs and what problems we are trying to solve\n      "},{question:"When would you use one over the other?",ans:"        When a task requires long computation time, or when the task is required to be non-blocking for better user experience in the UI, Asynchronous will be a better approach\n        For simple apps, Synchronous might be better\n      "}],codeExample:"",answer:"",codeAnswer:""},{mainQuestion:"SQL and NoSQL",subQuestions:[{question:"What are they?",ans:"        SQL stands for Structured Query Language, it is typically used for relational databases\n\n        NoSQL stands for Non-Structured Query Language, it is typically used for non-relational databases\n      "},{question:"What are their key differences, and pros and cons?",ans:"        Key differences:\n        SQL:\n          - Storage: stores data in tables where each row represents an entity, each column represents a data point about that entity\n          - Schema: defined schema, columns must be decided and chosen before data entry\n          - Querying: use SQL\n          - Scalability: vertically scalable, horizontally scalable is also possible but is challenging and time-consuming\n          - Reliability: ACID compliant (Atomicity, Consistency, Isolation, Durability)\n\n        NoSQL:\n          - Storage: have different data storage models (e.g.: key-value, document, graph, wide-column)\n          - Schema: can be schemaless or dynamic\n          - Querying: different databases have different syntax\n          - Scalability: horizontally scalable, a lot of NoSQL tech also distribute data across servers automatically\n          - Reliability: BASE compliant (Basically available, Soft State, Eventual Consistency)\n        "},{question:"Which one do you prefer and why?",ans:"All about tradeoffs, depends on the problem and budget"},{question:"When would you use one over the other?",ans:"        use SQL database if ACID compliance is needed, or when data is structured and unchanging, or when both Consistency and Availability are needed\n        use NoSQL if there is partition, or when rapid development is required, or when data has little to no structure\n      "}],codeExample:"",answer:"",codeAnswer:""},{mainQuestion:"Statically-typed and dynamically-typed programming languages",subQuestions:[{question:"What do they mean?",ans:"        Dynamically-typed Language: resolution of types, members, properties, methods are done at run-time\n        Statically-typed Language: resolution of types, members, properties, methods are done at compile-time\n      "},{question:"Describe their pros and cons.",ans:"        Dynamically-typed Language:\n        - pros: easier to understand, pickup, and write code\n        - cons: lose compile-time checking, have to write more unit tests to ensure app behaves properly at run-time\n        Statically-typed Language:\n        - pros: easier to debug as error messages are provided at compile-time\n        - cons: harder to understand, harder to pickup, harder to write code\n      "},{question:"Which do you generally prefer, and why would you use one over the other?",ans:"        Depends on the use case\n        But generally I would prefer Statically-typed due to the compile-time checking, which makes it easier to debug\n        It is also easier to maintain over the long run\n        "}],codeExample:"",answer:"",codeAnswer:""},{mainQuestion:"Scalability, resilience",subQuestions:[{question:"What sort of approaches might you take to design scalable platforms/systems?",ans:"        use Asynchronous Communication, Queue Automation Tasks, Read Replicas, reduce Write Requests, Cache, Load Balance, integrate performance and Load testing in CICD, plan carefully on choice of database"},{question:"What sort of approaches might you take to build in resilience for the platform/system?",ans:"Implement rolling upgrades, Retry functionality and make services asynchronous, Test in production, use blue green deployment, implement and test redundancy"}],codeExample:"",answer:"",codeAnswer:""},{mainQuestion:"Data, database",subQuestions:[{question:"Why would we need database transactions? Describe situations you can think of where database transactions are necessary, and where they are not.",ans:"        It is required for data integrity\n\n        During an important transaction for example a money transfer from User A to User B, it is either the transaction is completed successfully or it is not\n        If the transaction is not completed, the data is not updated in the database\n        It would not be good to see the money that was transferred to be lost somewhere due to any failures at any point in the process\n\n        Contents such as a user's profile, or a user's cart are not critical and can be updated without a transaction\n        "},{question:"How would you scale access to database, and ensure its resilience and data integrity/consistency at the same time?",ans:"        It would depend on how critical it is to guarantee consistency of replicated data at write time\n        Usually ACID model would be the right approach, just that it would be harder to implement the scaling part\n\n        BASE model would be good for easy scalability, however even if we choose a NoSQL with high consistency, it does not guarantees the write time like ACID does\n\n        If cost is not a concern, using Google Spanner might be a good choice to cover all the requirements\n        "},{question:"How would you do database backups effectively, without resorting to full database dumps all the time?",ans:"        Create a cronjob that periodically backups the database based on the last modified date and time\n        "}],codeExample:"",answer:"",codeAnswer:""},{mainQuestion:"Containers",subQuestions:[{question:"What are they?",ans:"It is a package of softwares that has all the dependencies needed to run a program in any environment"},{question:"What are the pros and cons of using them?",ans:"        Pros:\n        - provide a lightweight, fast, isolated infrastructure to run the app\n        - easy to deploy, scale, and maintain\n        - smaller in size compared to a virtual machine\n\n        Cons:\n        - shares the kernel of the OS, if the kernel becomes vulnerable, all containers will be affected\n        - networking could be tricky to manage\n        - more to manage and monitor for multi-layered infrastructure\n      "}],codeExample:"",answer:"",codeAnswer:""},{mainQuestion:"Dependency injection",subQuestions:[{question:"What is it?",ans:"It is a way to inject dependencies into a class"},{question:"In what ways can this be useful?",ans:"Allows for the replacement of a dependency without modifying any code and reduces the boilerplate code in the business logic"}],codeExample:"",answer:"",codeAnswer:""},{mainQuestion:"Spring framework, Spring Boot",subQuestions:[{question:"What are they?",ans:"Sprint Boot is an extension of the Spring framework, which eliminates the boilerplate configurations required for setting up a Spring app"},{question:"Are you OK working with it as part of daily work?",ans:"I would use the 2 months notice period to get up to speed on it so that I can contribute on the 1st week"}],codeExample:"",answer:"",codeAnswer:""},{mainQuestion:"CSS",subQuestions:[{question:"What are the benefits and caveats of using CSS frameworks?",ans:"        pros:\n        - speeds up development\n        - enables cross-browser functionality\n        - provides clean and symmetrical layouts\n        - enforces good practices\n\n        cons:\n        - less freedom\n        - more code\n        - more rules to follow\n        "}],codeExample:"",answer:"",codeAnswer:""},{mainQuestion:"LESS or SASS",subQuestions:[{question:"What are they good for, and why would you use any of them?",ans:"        - easier to automate repetitive tasks\n        - reduce number of errors and code bloat\n        - able to create reusable code snippets\n        - ensure backward compatibility\n        "}],codeExample:"",answer:"",codeAnswer:""},{mainQuestion:"REST, GraphQL",subQuestions:[{question:"What are these generally used for?",ans:"It is used to get, create, update, or delete a resource"},{question:"What are their differences, and their pros and cons?",ans:"        Differences:\n        - REST has multiple endpoints, whereas GraphQL has a single endpoint\n        - REST is URL-Driven, whereas GraphQL is query-driven\n        - REST uses HTTP verbs to perform a request, whereas GraphQL uses a query language to perform a request with only a POST request\n\n        REST:\n        pros:\n        - easier to implement\n        - no special libraries are required to use when writing on the client side\n        cons:\n        - updating of backend or frontend to filter data is tedious each time there is a requirement change\n        - multiple http calls might be required to get the data if app is complex\n\n        GraphQL:\n        pros:\n        - easy to filter and sort data via GraphQL Schema Definition Language\n        - less http calls are required to get data\n        - responsive and with low latency\n        cons:\n        - higher learning curve\n        - special libraries are required to use when writing on the client side\n        - can be overkill for simple apps\n        - vulnerable to DDoS attacks if server does not have the right protections\n        - monitoring and error reporting is difficult\n        - no default http caching\n        "},{question:"When would you use one over the other?",ans:"        use REST when data fetching is simple, or when the app requires a robust API, with caching and a monitoring system\n\n        use GraphQL when data fetching is nested and complex and for mobile apps\n      "}],codeExample:"",answer:"",codeAnswer:""},{mainQuestion:"React and Vue",subQuestions:[{question:"What are these?",ans:"Both are JavaScript based toolkit systems that help build dynamic user interfaces. They are libraries but when combined with other tools they can become like a framework"},{question:"What are their pros and cons?",ans:"        React\n        pros:\n        - allows flexible and reusable components\n        - large community, more libraries and support\n        - better performance during runtime\n        - open source and backed by facebook\n        - good for complex apps, future extensibility\n        cons:\n        - no specific code structure, dependent on developer to maintain which may lead to messy code\n        - frequent updates to the library, which may lead to code breaks\n        - requires understanding of JavaScript libraries\n\n        Vue\n        pros:\n        - has progressive design: able to gradually migrate existing projects\n        - good with memory allocation and better performance during start up time\n        - tracks dependencies and prevents unnecessary re-renders\n        - more intuitive and easier for beginners\n        - good if need a solution that works as soon as possible\n        cons:\n        - smaller community, lesser libraries and support\n        - purely open source\n      "},{question:"Which ones would you prefer, and why?",ans:"React, already familar with it and is more popular in the job market"},{question:"You OK to work with either or both?",ans:"Yes"}],codeExample:"",answer:"",codeAnswer:""},{mainQuestion:"Mobile-friendly, multiple form-factors",subQuestions:[{question:"How do you develop web applications/pages to be mobile friendly, which can also adapt to multiple screen sizes and devices?",ans:"        - Implement a Responsive Layout\n        - Use media queries to make sure the page is responsive to different screen sizes\n        - Add Viewport Meta tag\n        - Avoid using Cluttered Web Design\n        - Use different designs for web and mobile\n        "}],codeExample:"",answer:"",codeAnswer:""},{mainQuestion:"Converting mock-ups into functional UIs",subQuestions:[{question:"Describe how you would typically convert visual mock-ups into functional UIs.",ans:"        - Identify the colors, fonts, styles, medias, elements and their corresponding interactions, and layout of the mock-up\n        - Create reusable UI components and layouts based on the identified data\n        "}],codeExample:"",answer:"",codeAnswer:""}];function r(e){let{isVisible:n}=e;return a.createElement(a.Fragment,null,n&&s.map((e=>{let{mainQuestion:n,subQuestions:t,codeExample:o,answer:s,codeAnswer:r}=e;return a.createElement("div",{style:{borderBottom:"1px solid red"}},a.createElement("h2",null,n),o&&a.createElement("pre",null,a.createElement("code",null,o)),s&&a.createElement("p",{style:{whiteSpace:"pre-line"}},s),t.length>0&&t.map((e=>{let{question:n,ans:t}=e;return a.createElement(a.Fragment,null,a.createElement("h4",null,n),t&&a.createElement("p",{style:{whiteSpace:"pre-line"}},t))})),r&&a.createElement("pre",null,a.createElement("code",null,r)))})))}function i(){const[e,n]=(0,a.useState)("");return a.createElement(o.Z,null,a.createElement("div",{style:{display:"flex",flexDirection:"column",padding:"2vh",rowGap:"1vh"}},a.createElement(r,{isVisible:""===e})))}}}]);