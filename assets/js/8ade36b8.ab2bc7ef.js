"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[41386],{3905:(e,t,a)=>{a.d(t,{Zo:()=>s,kt:()=>d});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),m=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},s=function(e){var t=m(e.components);return n.createElement(o.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),u=m(a),d=i,c=u["".concat(o,".").concat(d)]||u[d]||h[d]||r;return a?n.createElement(c,l(l({ref:t},s),{},{components:a})):n.createElement(c,l({ref:t},s))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=u;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:i,l[1]=p;for(var m=2;m<r;m++)l[m]=a[m];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},92112:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>p,toc:()=>m});var n=a(83117),i=(a(67294),a(3905));const r={},l="Heap",p={unversionedId:"interviewPrep/data_structures/05Heap/readme",id:"interviewPrep/data_structures/05Heap/readme",title:"Heap",description:"- The (binary) heap data structure is an array object that we can view as a nearly complete binary tree",source:"@site/docs/interviewPrep/data_structures/05Heap/readme.md",sourceDirName:"interviewPrep/data_structures/05Heap",slug:"/interviewPrep/data_structures/05Heap/",permalink:"/docs/interviewPrep/data_structures/05Heap/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/data_structures/05Heap/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Memory",permalink:"/docs/interviewPrep/data_structures/04Memory/"},next:{title:"Logarithm",permalink:"/docs/interviewPrep/data_structures/06Logarithm/"}},o={},m=[{value:"Maintaining the Heap Property",id:"maintaining-the-heap-property",level:2},{value:"Building a Heap",id:"building-a-heap",level:2}],s={toc:m};function h(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},s,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"heap"},"Heap"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The (binary) heap data structure is an array object that we can view as a nearly complete binary tree")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Each node of the tree corresponds to an element of the array")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The tree is completely filled on all levels except possibly the lowest"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"which is filled from the left up to a point"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"An array ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," that represents a heap is an object with two attributes:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"A.length")," gives the number of elements in the array"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"A.heap-size")," represents how many elements in the heap are stored within array ",(0,i.kt)("inlineCode",{parentName:"li"},"A")),(0,i.kt)("li",{parentName:"ul"},"only elements in ",(0,i.kt)("inlineCode",{parentName:"li"},"A[1 .. A.heap-size]"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"where ",(0,i.kt)("inlineCode",{parentName:"li"},"0 \u2264 A.heap-size \u2264 A.length")," are valid elements of the heap"))),(0,i.kt)("li",{parentName:"ul"},"The root of the tree is ",(0,i.kt)("inlineCode",{parentName:"li"},"A[1]")),(0,i.kt)("li",{parentName:"ul"},"given the index i of a node",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"we can easily compute the indices of its parent, left child, and right child:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Parent: ",(0,i.kt)("inlineCode",{parentName:"li"},"i/2")),(0,i.kt)("li",{parentName:"ul"},"Left: ",(0,i.kt)("inlineCode",{parentName:"li"},"2i")),(0,i.kt)("li",{parentName:"ul"},"Right: ",(0,i.kt)("inlineCode",{parentName:"li"},"2i + 1")))))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"There are two kinds of binary heaps"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"max-heaps and min-heaps"),(0,i.kt)("li",{parentName:"ul"},"In both kinds, the values in the nodes satisfy a heap property, the specifics of which depend on the kind of heap"),(0,i.kt)("li",{parentName:"ul"},"In a max-heap, the max-heap property is that for every node i other than the root: ",(0,i.kt)("inlineCode",{parentName:"li"},"A[Parent(i)] \u2265 A[i]"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"max hip has the largest root node and the heap goes down"),(0,i.kt)("li",{parentName:"ul"},"the largest element in a max-heap is stored at the root"),(0,i.kt)("li",{parentName:"ul"},"the subtree rooted at a node contains values no larger than that contained at the node itself"))),(0,i.kt)("li",{parentName:"ul"},"A min-heap is organized in the opposite way",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"min has a minimum root node and goes up"),(0,i.kt)("li",{parentName:"ul"},"the min-heap property is that for every node i other than the root: ",(0,i.kt)("inlineCode",{parentName:"li"},"A[Parent(i)] \u2264 A[i]")),(0,i.kt)("li",{parentName:"ul"},"The smallest element in a min-heap is at the root",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"For the heap sort algorithm, we use max-heaps"),(0,i.kt)("li",{parentName:"ul"},"Min-heaps commonly implement ",(0,i.kt)("inlineCode",{parentName:"li"},"priority queues")))))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"example"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"an array that we can represent as a tree"),(0,i.kt)("li",{parentName:"ul"},"the numbers above the element in the array and the heap are the same, you can see how they are substituted into the leaves"),(0,i.kt)("li",{parentName:"ul"},"It doesn't have to be an array, different programming languages have different data structures",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"it is more convenient to consider it as an array"))),(0,i.kt)("li",{parentName:"ul"},"Array ",(0,i.kt)("inlineCode",{parentName:"li"},"A"),", which represents the heap",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"it also has attributes such as ",(0,i.kt)("inlineCode",{parentName:"li"},"length")," - the number of elements in the array"),(0,i.kt)("li",{parentName:"ul"},"And ",(0,i.kt)("inlineCode",{parentName:"li"},"heap-size"),", the number of elements in the heap"),(0,i.kt)("li",{parentName:"ul"},"The root of the tree is the first element in the array")))),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("img",{alt:"Heap tree",src:a(49582).Z,width:"437",height:"320"})),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("img",{alt:"Heap array",src:a(39667).Z,width:"495",height:"264"})),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"function maxHeapify(A, i) {\n  let l = left(i);\n  let r = right(i);\n\n  if (l <= A.heapSize && A[l] > A[i]) {\n    largest = l;\n  } else {\n    largest = i;\n  }\n\n  if (r <= A.heapSize && A[r] > A[largest]) {\n    largest = r;\n  }\n\n  if (largest != i) {\n    // exchange A[i] with A[largest]\n    [A[i], A[largest]] = [A[largest], A[i]];\n\n    maxHeapify(A[largest]);\n  }\n}\n")))),(0,i.kt)("h2",{id:"maintaining-the-heap-property"},"Maintaining the Heap Property"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In order to maintain the max-heap property, we call the function maxHeapify"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"When it is called, maxHeapify assumes that the binary trees rooted at left(i) and right(i) are max-heaps",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"but that A","[i]"," might be smaller than its children, thus violating the max-heap property"))),(0,i.kt)("li",{parentName:"ul"},"Function maxHeapify lets the value at ",(0,i.kt)("inlineCode",{parentName:"li"},"A[i]"),' "float down" in the max-heap so that the subtree rooted at index i obeys the max-heap property'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"example"),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("img",{alt:"max heapify",src:a(80115).Z,width:"629",height:"454"})),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"heap must somehow support itself",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"when inserting or when deleting elements a heap rebuild should take place",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"this procedure can be called as ",(0,i.kt)("inlineCode",{parentName:"li"},"maxHeapify"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"When it is called, we assume that the left and right nodes are also maxHeap"),(0,i.kt)("li",{parentName:"ul"},"these nodes can be smaller than its children, and we have to let it go down below"),(0,i.kt)("li",{parentName:"ul"},"the second element has ceased to meet the requirement, and we check the left heap until we reach the sheet"),(0,i.kt)("li",{parentName:"ul"},"At each step, the largest of the elements ",(0,i.kt)("inlineCode",{parentName:"li"},"A[i]"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"A[left(i)]"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"A[right(i)]")," is determined, and its index is stored in largest"),(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"A[i]")," is largest, then the subtree rooted at node i is already a max-heap and the procedure terminates"),(0,i.kt)("li",{parentName:"ul"},"Otherwise, one of the two children has the largest element, and ",(0,i.kt)("inlineCode",{parentName:"li"},"A[i]")," is swapped with ",(0,i.kt)("inlineCode",{parentName:"li"},"A[largest]"),", which causes node i and its children to satisfy the max-heap property"),(0,i.kt)("li",{parentName:"ul"},"The node indexed by largest, however, now has the original value ",(0,i.kt)("inlineCode",{parentName:"li"},"A[i]"),", and thus the subtree rooted at largest might violate the max-heap property"),(0,i.kt)("li",{parentName:"ul"},"Consequently, we call maxHeapify recursively on that subtree"))),(0,i.kt)("li",{parentName:"ul"},"The running time of maxHeapify on a subtree of size n rooted at a given node i is the ",(0,i.kt)("inlineCode",{parentName:"li"},"\u0398(1)")," time to fix up the relationships among the elements ",(0,i.kt)("inlineCode",{parentName:"li"},"A[i]"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"A[left(i)]"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"A[right(i)]")),(0,i.kt)("li",{parentName:"ul"},"plus the time to run maxHeapify on a subtree rooted at one of the children of node i (assuming that the recursive call occurs)"),(0,i.kt)("li",{parentName:"ul"},"The children's subtrees each have size at most ",(0,i.kt)("inlineCode",{parentName:"li"},"2n/3")),(0,i.kt)("li",{parentName:"ul"},"the worst case occurs when the bottom level of the tree is exactly half full\u2014and therefore we can describe the running time of maxHeapify by the recurrence:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"O(log n)"))))))))))),(0,i.kt)("h2",{id:"building-a-heap"},"Building a Heap"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The heap should be built using method ",(0,i.kt)("inlineCode",{parentName:"li"},"buildMaxHeap"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"To do this, need to run the entire array through the maxHeapify function"),(0,i.kt)("li",{parentName:"ul"},"the complexity becomes ",(0,i.kt)("inlineCode",{parentName:"li"},"O(n log n)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"have a linear dependency as it applies a function for each element and call maxHeapify itself"),(0,i.kt)("li",{parentName:"ul"},"We can use the procedure maxHeapify in a bottom-up manner to convert an array ",(0,i.kt)("inlineCode",{parentName:"li"},"A[1..n]"),", where ",(0,i.kt)("inlineCode",{parentName:"li"},"n = A.length"),", into a max-heap"),(0,i.kt)("li",{parentName:"ul"},"The elements in the subarray ",(0,i.kt)("inlineCode",{parentName:"li"},"A[(n/2+1)..n]")," are all leaves of the tree, and so each is a 1-element heap to begin with"),(0,i.kt)("li",{parentName:"ul"},"The function buildMaxHeap goes through the remaining nodes of the tree and runs maxHeapify on each one"))))),(0,i.kt)("li",{parentName:"ul"},"We can compute a simple upper bound on the running time of buildMaxHeap",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Each call to maxHeapify costs O(lgn) time"),(0,i.kt)("li",{parentName:"ul"},"Procedure buildMaxHeap makes ",(0,i.kt)("inlineCode",{parentName:"li"},"O(n)")," calls"),(0,i.kt)("li",{parentName:"ul"},"the running time is ",(0,i.kt)("inlineCode",{parentName:"li"},"O(n log n)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This upper bound, though correct, is not asymptotically tight")))))))}h.isMDXComponent=!0},49582:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/heap_1-7a44aa8fb82dce6a7d4d470cab9a979f.png"},39667:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/heap_2-7915e4e11e0b3c17068ad1be69dd0445.png"},80115:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/heap_3-3000b36845c6140d05ab40296961aeb9.png"}}]);