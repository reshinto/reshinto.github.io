"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[6743],{3905:(e,n,r)=>{r.d(n,{Zo:()=>u,kt:()=>d});var t=r(67294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var c=t.createContext({}),l=function(e){var n=t.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},u=function(e){var n=l(e.components);return t.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},f=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),f=l(r),d=i,m=f["".concat(c,".").concat(d)]||f[d]||p[d]||a;return r?t.createElement(m,o(o({ref:n},u),{},{components:r})):t.createElement(m,o({ref:n},u))}));function d(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=f;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var l=2;l<a;l++)o[l]=r[l];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}f.displayName="MDXCreateElement"},88071:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var t=r(87462),i=(r(67294),r(3905));const a={},o="Example 2",s={unversionedId:"interviewPrep/designPatterns/Structural_patterns/Proxy/swift/example2",id:"interviewPrep/designPatterns/Structural_patterns/Proxy/swift/example2",title:"Example 2",description:"",source:"@site/docs/interviewPrep/designPatterns/Structural_patterns/Proxy/swift/example2.md",sourceDirName:"interviewPrep/designPatterns/Structural_patterns/Proxy/swift",slug:"/interviewPrep/designPatterns/Structural_patterns/Proxy/swift/example2",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Proxy/swift/example2",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Structural_patterns/Proxy/swift/example2.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Swift Example",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Proxy/swift/"},next:{title:"TypeScript Example",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Proxy/typescript/"}},c={},l=[],u={toc:l};function p(e){let{components:n,...r}=e;return(0,i.kt)("wrapper",(0,t.Z)({},u,r,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"example-2"},"Example 2"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'import XCTest\n\nclass ProxyRealWorld: XCTestCase {\n\n    /// Proxy Design Pattern\n    ///\n    /// Intent: Provide a surrogate or placeholder for another object to control\n    /// access to the original object or to add other responsibilities.\n    ///\n    /// Example: There are countless ways proxies can be used: caching, logging,\n    /// access control, delayed initialization, etc.\n\n    func testProxyRealWorld() {\n\n        print("Client: Loading a profile WITHOUT proxy")\n        loadBasicProfile(with: Keychain())\n        loadProfileWithBankAccount(with: Keychain())\n\n        print("\\nClient: Let\'s load a profile WITH proxy")\n        loadBasicProfile(with: ProfileProxy())\n        loadProfileWithBankAccount(with: ProfileProxy())\n    }\n\n    func loadBasicProfile(with service: ProfileService) {\n\n        service.loadProfile(with: [.basic], success: { profile in\n            print("Client: Basic profile is loaded")\n        }) { error in\n            print("Client: Cannot load a basic profile")\n            print("Client: Error: " + error.localizedSummary)\n        }\n    }\n\n    func loadProfileWithBankAccount(with service: ProfileService) {\n\n        service.loadProfile(with: [.basic, .bankAccount], success: { profile in\n            print("Client: Basic profile with a bank account is loaded")\n        }) { error in\n            print("Client: Cannot load a profile with a bank account")\n            print("Client: Error: " + error.localizedSummary)\n        }\n    }\n}\n\nenum AccessField {\n\n    case basic\n    case bankAccount\n}\n\nprotocol ProfileService {\n\n    typealias Success = (Profile) -> ()\n    typealias Failure = (LocalizedError) -> ()\n\n    func loadProfile(with fields: [AccessField], success: Success, failure: Failure)\n}\n\nclass ProfileProxy: ProfileService {\n\n    private let keychain = Keychain()\n\n    func loadProfile(with fields: [AccessField], success: Success, failure: Failure) {\n\n        if let error = checkAccess(for: fields) {\n            failure(error)\n        } else {\n            /// Note:\n            /// At this point, the `success` and `failure` closures can be\n            /// passed directly to the original service (as it is now) or\n            /// expanded here to handle a result (for example, to cache).\n\n            keychain.loadProfile(with: fields, success: success, failure: failure)\n        }\n    }\n\n    private func checkAccess(for fields: [AccessField]) -> LocalizedError? {\n        if fields.contains(.bankAccount) {\n            switch BiometricsService.checkAccess() {\n            case .authorized: return nil\n            case .denied: return ProfileError.accessDenied\n            }\n        }\n        return nil\n    }\n}\n\nclass Keychain: ProfileService {\n\n    func loadProfile(with fields: [AccessField], success: Success, failure: Failure) {\n\n        var profile = Profile()\n\n        for item in fields {\n            switch item {\n            case .basic:\n                let info = loadBasicProfile()\n                profile.firstName = info[Profile.Keys.firstName.raw]\n                profile.lastName = info[Profile.Keys.lastName.raw]\n                profile.email = info[Profile.Keys.email.raw]\n            case .bankAccount:\n                profile.bankAccount = loadBankAccount()\n            }\n        }\n\n        success(profile)\n    }\n\n    private func loadBasicProfile() -> [String : String] {\n        /// Gets these fields from a secure storage.\n        return [Profile.Keys.firstName.raw : "Vasya",\n                Profile.Keys.lastName.raw : "Pupkin",\n                Profile.Keys.email.raw : "vasya.pupkin@gmail.com"]\n    }\n\n    private func loadBankAccount() -> BankAccount {\n        /// Gets these fields from a secure storage.\n        return BankAccount(id: 12345, amount: 999)\n    }\n}\n\nclass BiometricsService {\n\n    enum Access {\n        case authorized\n        case denied\n    }\n\n    static func checkAccess() -> Access {\n        /// The service uses Face ID, Touch ID or a plain old password to\n        /// determine whether the current user is an owner of the device.\n\n        /// Let\'s assume that in our example a user forgot a password :)\n        return .denied\n    }\n}\n\nstruct Profile {\n\n    enum Keys: String {\n        case firstName\n        case lastName\n        case email\n    }\n\n    var firstName: String?\n    var lastName: String?\n    var email: String?\n\n    var bankAccount: BankAccount?\n}\n\nstruct BankAccount {\n\n    var id: Int\n    var amount: Double\n}\n\nenum ProfileError: LocalizedError {\n\n    case accessDenied\n\n    var errorDescription: String? {\n        switch self {\n        case .accessDenied:\n            return "Access is denied. Please enter a valid password"\n        }\n    }\n}\n\nextension RawRepresentable {\n\n    var raw: Self.RawValue {\n        return rawValue\n    }\n}\n\nextension LocalizedError {\n\n    var localizedSummary: String {\n        return errorDescription ?? ""\n    }\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Client: Loading a profile WITHOUT proxy\nClient: Basic profile is loaded\nClient: Basic profile with a bank account is loaded\n\nClient: Let's load a profile WITH proxy\nClient: Basic profile is loaded\nClient: Cannot load a profile with a bank account\nClient: Error: Access is denied. Please enter a valid password\n")))}p.isMDXComponent=!0}}]);