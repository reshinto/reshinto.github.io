"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[5469],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>u});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function a(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},l=Object.keys(e);for(o=0;o<l.length;o++)t=l[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(o=0;o<l.length;o++)t=l[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=o.createContext({}),s=function(e){var n=o.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=s(e.components);return o.createElement(d.Provider,{value:n},e.children)},h={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},p=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,d=e.parentName,c=a(e,["components","mdxType","originalType","parentName"]),p=s(t),u=r,f=p["".concat(d,".").concat(u)]||p[u]||h[u]||l;return t?o.createElement(f,i(i({ref:n},c),{},{components:t})):o.createElement(f,i({ref:n},c))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=p;var a={};for(var d in n)hasOwnProperty.call(n,d)&&(a[d]=n[d]);a.originalType=e,a.mdxType="string"==typeof e?e:r,i[1]=a;for(var s=2;s<l;s++)i[s]=t[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}p.displayName="MDXCreateElement"},17383:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>s});var o=t(87462),r=(t(67294),t(3905));const l={},i="TypeScript Example",a={unversionedId:"interviewPrep/data_structures/13Trees/redBlackTree/typescriptExample",id:"interviewPrep/data_structures/13Trees/redBlackTree/typescriptExample",title:"TypeScript Example",description:"utils",source:"@site/docs/interviewPrep/data_structures/13Trees/redBlackTree/typescriptExample.md",sourceDirName:"interviewPrep/data_structures/13Trees/redBlackTree",slug:"/interviewPrep/data_structures/13Trees/redBlackTree/typescriptExample",permalink:"/docs/interviewPrep/data_structures/13Trees/redBlackTree/typescriptExample",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/data_structures/13Trees/redBlackTree/typescriptExample.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Red-Black Tree",permalink:"/docs/interviewPrep/data_structures/13Trees/redBlackTree/"},next:{title:"Design Patterns",permalink:"/docs/interviewPrep/designPatterns/"}},d={},s=[{value:"utils",id:"utils",level:2},{value:"Red Black Node",id:"red-black-node",level:2},{value:"not refactored Red Black Tree example (with parent attribute)",id:"not-refactored-red-black-tree-example-with-parent-attribute",level:2},{value:"refactored Red Black Tree (without parent attribute)",id:"refactored-red-black-tree-without-parent-attribute",level:2}],c={toc:s};function h(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"typescript-example"},"TypeScript Example"),(0,r.kt)("h2",{id:"utils"},"utils"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"enum Colors {\n  Red = 0,\n  Black = 1,\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"enum Compare {\n  LessThan = -1,\n  BiggerThan = 1,\n  Equals = 0,\n}\n\nfunction compare<T>(a: T, b: T): number {\n  if (a === b) {\n    return Compare.Equals;\n  }\n  return a < b ? Compare.LessThan : Compare.BiggerThan;\n}\n")),(0,r.kt)("h2",{id:"red-black-node"},"Red Black Node"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class RedBlackNode<T> extends Node<T> {\n  left: RedBlackNode<T> = null;\n  right: RedBlackNode<T> = null;\n  parent: RedBlackNode<T> = null;\n  color: Colors; // The red-black tree node has a special attribute of color\n\n  constructor(public value: T) {\n    super(value);\n    this.color = Colors.Red; // The default color of the node is red\n  }\n\n  public isRed() {\n    return this.color === Colors.Red;\n  }\n\n  public flipColor() {\n    // solution 1\n    if (this.color === Colors.Red) {\n      this.color = Colors.Black;\n    } else {\n      this.color = Colors.Red;\n    }\n    // solution 2: Bitwise operation inverts the color of the node\n    // this.color = 1 ^ this.color;\n  }\n}\n")),(0,r.kt)("h2",{id:"not-refactored-red-black-tree-example-with-parent-attribute"},"not refactored Red Black Tree example (with parent attribute)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class RedBlackTree<T> extends BinarySearchTree<T> {\n  protected root: RedBlackNode<T> = null;\n\n  /**\n   * Left left case: rotate right\n   *\n   *       b                               a\n   *      / \\                             / \\\n   *     a   e -> rotationRight(b) ->    c   b\n   *    / \\                             / \\\n   *   c   d                           d   e\n   *\n   * @param node Node<T>\n   */\n  private rotationRight(node: RedBlackNode<T>) {\n    const tmp = node.left;\n    node.left = tmp.right;\n    if (tmp.right && tmp.right.value) {\n      tmp.right.parent = node;\n    }\n    tmp.parent = node.parent;\n    if (!node.parent) {\n      this.root = tmp;\n    } else {\n      if (node === node.parent.left) {\n        node.parent.left = tmp;\n      } else {\n        node.parent.right = tmp;\n      }\n    }\n    tmp.right = node;\n    node.parent = tmp;\n  }\n\n  /**\n   * Right right case: rotate left\n   *\n   *     a                              b\n   *    / \\                            / \\\n   *   c   b   -> rotationLeft(a) ->  a   e\n   *      / \\                        / \\\n   *     d   e                      c   d\n   *\n   * @param node Node<T>\n   */\n  private rotationLeft(node: RedBlackNode<T>) {\n    const tmp = node.right;\n    node.right = tmp.left;\n    if (tmp.left && tmp.left.value) {\n      tmp.left.parent = node;\n    }\n    tmp.parent = node.parent;\n    if (!node.parent) {\n      this.root = tmp;\n    } else {\n      if (node === node.parent.left) {\n        node.parent.left = tmp;\n      } else {\n        node.parent.right = tmp;\n      }\n    }\n    tmp.left = node;\n    node.parent = tmp;\n  }\n\n  public insert(value: T) {\n    // special case: first value\n    if (this.root === null) {\n      this.root = new RedBlackNode(value);\n      this.root.color = Colors.Black;\n    } else {\n      const newNode = this.insertNode(this.root, value);\n      this.fixTreeProperties(newNode);\n    }\n  }\n\n  protected insertNode(node: RedBlackNode<T>, value: T): RedBlackNode<T> {\n    if (compare(value, node.value) === Compare.LessThan) {\n      if (node.left === null) {\n        node.left = new RedBlackNode(value);\n        node.left.parent = node;\n        return node.left;\n      } else {\n        return this.insertNode(node.left, value);\n      }\n    } else if (node.right === null) {\n      node.right = new RedBlackNode(value);\n      node.right.parent = node;\n      return node.right;\n    } else {\n      return this.insertNode(node.right, value);\n    }\n  }\n\n  private fixTreeProperties(node: RedBlackNode<T>) {\n    while (\n      node &&\n      node.parent &&\n      node.parent.color === Colors.Red &&\n      node.color !== Colors.Black\n    ) {\n      let parent = node.parent;\n      const grandParent = parent.parent;\n\n      // case A\n      if (grandParent && grandParent.left === parent) {\n        const uncle = grandParent.right;\n\n        // case 1: uncle of node is also red - only recoloring\n        if (uncle && uncle.color === Colors.Red) {\n          grandParent.color = Colors.Red;\n          parent.color = Colors.Black;\n          uncle.color = Colors.Black;\n          node = grandParent;\n        } else {\n          // case 2: node is right child - left rotate\n          if (node === parent.right) {\n            this.rotationLeft(parent);\n            node = parent;\n            parent = node.parent;\n          }\n\n          // case 3: node is left child - right rotate\n          this.rotationRight(grandParent);\n          // swap color\n          parent.color = Colors.Black;\n          grandParent.color = Colors.Red;\n          node = parent;\n        }\n      } else {\n        // case B: parent is right child of grand parent\n\n        const uncle = grandParent.left;\n\n        // case 1: uncle is read - only recoloring\n        if (uncle && uncle.color === Colors.Red) {\n          grandParent.color = Colors.Red;\n          parent.color = Colors.Black;\n          uncle.color = Colors.Black;\n          node = grandParent;\n        } else {\n          // case 2: node is left child - left rotate\n          if (node === parent.left) {\n            this.rotationRight(parent);\n            node = parent;\n            parent = node.parent;\n          }\n\n          // case 3: node is right child - left rotate\n          this.rotationLeft(grandParent);\n          // swap color\n          parent.color = Colors.Black;\n          grandParent.color = Colors.Red;\n          node = parent;\n        }\n      }\n    }\n    this.root.color = Colors.Black;\n  }\n\n  public getRoot() {\n    return this.root;\n  }\n}\n")),(0,r.kt)("h2",{id:"refactored-red-black-tree-without-parent-attribute"},"refactored Red Black Tree (without parent attribute)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class RedBlackTree<T> extends BinarySearchTree<T> {\n  protected root: RedBlackNode<T> = null;\n\n  /**\n   * Left left case: rotate right\n   * Whether it is left-handed or right-handed,\n   * the implementation is similar to the left-handed and right-handed AVL tree\n   *\n   *       a                           c\n   *      / \\                         / \\\n   *     c   b -> rotateRight(a) ->   d   a\n   *    / \\                             / \\\n   *   d   e                           e   b\n   *\n   * @param node Node<T>\n   */\n  private rotateRight(node: RedBlackNode<T>): RedBlackNode<T> {\n    const tmp = node.left;\n    node.left = tmp.right;\n    tmp.right = node;\n    tmp.color = node.color;\n    node.color = Colors.Red;\n    return tmp;\n  }\n\n  /**\n   * Right right case: rotate left\n   *\n   *     b                              d\n   *    / \\                            / \\\n   *   a   d   -> rotateLeft(b) ->    b   e\n   *      / \\                        / \\\n   *     c   e                      a   c\n   *\n   * @param node Node<T>\n   */\n  private rotateLeft(node: RedBlackNode<T>): RedBlackNode<T> {\n    const tmp = node.right;\n    node.right = tmp.left;\n    tmp.left = node;\n    tmp.color = node.color;\n    node.color = Colors.Red;\n    return tmp;\n  }\n\n  /**\n   * @description: Insert element\n   */\n  public insert(value: T) {\n    this.root = this.insertNode(this.root, value);\n    this.root.color = Colors.Black;\n  }\n\n  /**\n   * @description: recursive method to add element\n   */\n  protected insertNode(node: RedBlackNode<T>, value: T): RedBlackNode<T> {\n    // Baseline condition, if inserted into a blank node, insert a red node\n    if (node === null) {\n      let node = new RedBlackNode(value);\n      node.color = Colors.Red;\n      return node;\n    }\n\n    if (compare(value, node.value) === Compare.LessThan) {\n      node.left = this.insertNode(node.left, value);\n    } else if (compare(value, node.value) === Compare.BiggerThan) {\n      node.right = this.insertNode(node.right, value);\n    } else {\n      node.value = value;\n    }\n\n    return this.balance(node);\n  }\n\n  /**\n   * @description: remove minimum element\n   */\n  public deleteMin() {\n    if (this.root) return;\n\n    // If the left and right sides of the root node are black, set the root node to red\n    if (!this.isRed(this.root.left) && !this.isRed(this.root.right))\n      this.root.color = Colors.Red;\n\n    // call recursive method that deletes the smallest value\n    this.root = this.deleteMinNode(this.root);\n    // Finally correct the root node color to black\n    if (this.root) this.root.color = Colors.Black;\n  }\n\n  /**\n   * @description: Recursive method to delete smallest element\n   */\n  private deleteMinNode(node: RedBlackNode<T>): RedBlackNode<T> {\n    if (node.left === null) return null;\n\n    // If the left and right nodes are black, call moveRedLeft\n    if (!this.isRed(node.left) && !this.isRed(node.left.left))\n      node = this.moveRedLeft(node);\n\n    // recursively call to find the smallest value after deletion\n    node.left = this.deleteMinNode(node.left);\n    // Balance nodes after each recursion\n    return this.balance(node);\n  }\n\n  /**\n   * @description: remove max element\n   */\n  public deleteMax() {\n    if (!this.root) return;\n\n    // If all children of the root node are black, set the root node to red\n    if (!this.isRed(this.root.left) && !this.isRed(this.root.right))\n      this.root.color = Colors.Red;\n\n    // Call the recursive method that deletes the largest node and assign to root\n    this.root = this.deleteMaxNode(this.root);\n    // Correct the root node color to black\n    if (this.root) this.root.color = Colors.Black;\n  }\n\n  /**\n   * @description: Recursive method to delete largest element\n   */\n  private deleteMaxNode(node: RedBlackNode<T>): RedBlackNode<T> {\n    // When the left child node is red, rotate right\n    if (this.isRed(node.left)) node = this.rotateRight(node);\n\n    if (node.right === null) return null;\n\n    // If the left and right nodes are black, call moveRedRight\n    if (!this.isRed(node.right) && !this.isRed(node.right.left))\n      node = this.moveRedRight(node);\n\n    // recursively call to find max value after deletion\n    node.right = this.deleteMaxNode(node.right);\n\n    // balance nodes after each recursion\n    return this.balance(node);\n  }\n\n  /**\n   * @description: delete the specified element\n   */\n  public delete(value: T) {\n    // return directly if there is no node\n    if (!this.search(value)) return;\n\n    // If all children of the root node are black, set the root node to red\n    if (!this.isRed(this.root.left) && !this.isRed(this.root.right))\n      this.root.color = Colors.Red;\n\n    // call recursive method to delete node\n    this.root = this.deleteNode(this.root, value);\n    // Correct the root node color to black\n    if (this.root) this.root.color = Colors.Black;\n  }\n\n  /**\n   * @description: Recursive method to delete specified element\n   */\n  private deleteNode(node: RedBlackNode<T>, value: T): RedBlackNode<T> {\n    // if the value is smaller than the current node\n    if (compare(value, node.value) === Compare.LessThan) {\n      if (!this.isRed(node.left) && !this.isRed(node.left?.left))\n        node = this.moveRedLeft(node);\n      // continue recursion\n      node.left = this.deleteNode(node.left, value);\n      // if value is not less than current node\n    } else {\n      if (this.isRed(node.left)) node = this.rotateRight(node);\n\n      // The corresponding node is found and the right child node is empty\n      if (compare(value, node.value) === Compare.Equals && node.right === null)\n        return null;\n\n      // If the left and right nodes are black, call moveRedRight\n      if (!this.isRed(node.right) && !this.isRed(node.right?.left))\n        node = this.moveRedRight(node);\n\n      // The corresponding node is found, and the right child node is not empty\n      if (compare(value, node.value) === Compare.Equals) {\n        const x = this.minNode(node.right);\n        node.value = x.value;\n        node.right = this.deleteMinNode(node.right);\n        // if not found, continue recursion\n      } else {\n        // If the corresponding node is not found, continue recursion\n        node.right = this.deleteNode(node.right, value);\n      }\n    }\n    // balance nodes after each recursion\n    return this.balance(node);\n  }\n\n  /**\n   * @description: return root node\n   */\n  public getRoot(): RedBlackNode<T> {\n    return this.root;\n  }\n\n  /**\n   * @description: fix node color\n   */\n  private flipColors(node: RedBlackNode<T>) {\n    node.flipColor();\n    node.left.flipColor();\n    node.right.flipColor();\n  }\n\n  /**\n   * @description: Balanced tree\n   */\n  private balance(node: RedBlackNode<T>): RedBlackNode<T> {\n    // The core algorithm generates a left-leaning red-black tree through three lines of judgment\n    // Right red and left black, rotate left to rotate the red node to the left\n    if (this.isRed(node.right) && !this.isRed(node.left))\n      node = this.rotateLeft(node);\n    // Left red and left left are also red, rotate right\n    if (this.isRed(node.left) && this.isRed(node.left?.left))\n      node = this.rotateRight(node);\n    // Whether it is rotated out or inserted naturally, as long as the two reds are siblings, they will change color and move the red one layer up\n    if (this.isRed(node.left) && this.isRed(node.right)) this.flipColors(node);\n    return node;\n  }\n\n  /**\n   * @description: If the node is red and the left and right are black, make the left or left child node red\n   */\n  private moveRedLeft(node: RedBlackNode<T>): RedBlackNode<T> {\n    this.flipColors(node);\n    if (this.isRed(node.right.left)) {\n      node.right = this.rotateRight(node.right);\n      node = this.rotateLeft(node);\n      this.flipColors(node);\n    }\n    return node;\n  }\n\n  /**\n   * @description: If the node is red, and the node's right and right-left are black, make the node's right or right child red\n   */\n  private moveRedRight(node: RedBlackNode<T>): RedBlackNode<T> {\n    this.flipColors(node);\n    if (this.isRed(node.left.left)) {\n      node = this.rotateLeft(node);\n      this.flipColors(node);\n    }\n    return node;\n  }\n\n  /**\n   * @description: Determine if the node is red\n   */\n  private isRed(node: RedBlackNode<T>) {\n    // If empty, assume as black\n    // This is very important, equivalent to all black empty nodes at the bottom of the tree\n    if (!node) {\n      return false;\n    }\n    return node.isRed();\n  }\n}\n")))}h.isMDXComponent=!0}}]);