"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[9824],{3905:(e,t,i)=>{i.d(t,{Zo:()=>c,kt:()=>u});var n=i(67294);function a(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function l(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function o(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?l(Object(i),!0).forEach((function(t){a(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):l(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function s(e,t){if(null==e)return{};var i,n,a=function(e,t){if(null==e)return{};var i,n,a={},l=Object.keys(e);for(n=0;n<l.length;n++)i=l[n],t.indexOf(i)>=0||(a[i]=e[i]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)i=l[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(a[i]=e[i])}return a}var r=n.createContext({}),d=function(e){var t=n.useContext(r),i=t;return e&&(i="function"==typeof e?e(t):o(o({},t),e)),i},c=function(e){var t=d(e.components);return n.createElement(r.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var i=e.components,a=e.mdxType,l=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=d(i),u=a,h=m["".concat(r,".").concat(u)]||m[u]||p[u]||l;return i?n.createElement(h,o(o({ref:t},c),{},{components:i})):n.createElement(h,o({ref:t},c))}));function u(e,t){var i=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=i.length,o=new Array(l);o[0]=m;var s={};for(var r in t)hasOwnProperty.call(t,r)&&(s[r]=t[r]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var d=2;d<l;d++)o[d]=i[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,i)}m.displayName="MDXCreateElement"},62201:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>d});var n=i(87462),a=(i(67294),i(3905));const l={},o="Linked Lists",s={unversionedId:"interviewPrep/data_structures/08LinkedLists/readme",id:"interviewPrep/data_structures/08LinkedLists/readme",title:"Linked Lists",description:"- consists of nodes, each with some value and a pointer to the next node in the linked list",source:"@site/docs/interviewPrep/data_structures/08LinkedLists/readme.md",sourceDirName:"interviewPrep/data_structures/08LinkedLists",slug:"/interviewPrep/data_structures/08LinkedLists/",permalink:"/docs/interviewPrep/data_structures/08LinkedLists/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/data_structures/08LinkedLists/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Array",permalink:"/docs/interviewPrep/data_structures/07Array/"},next:{title:"Hash Tables",permalink:"/docs/interviewPrep/data_structures/09HashTables/"}},r={},d=[{value:"Singly Linked List",id:"singly-linked-list",level:2},{value:"standard operations and their complexities",id:"standard-operations-and-their-complexities",level:3},{value:"Initialize a linked list: O(n) time, O(n) space",id:"initialize-a-linked-list-on-time-on-space",level:4},{value:"Accessing the head: O(1) time, O(1) space",id:"accessing-the-head-o1-time-o1-space",level:4},{value:"Accessing the tail: O(n) time, O(1) space",id:"accessing-the-tail-on-time-o1-space",level:4},{value:"Accessing a middle node: O(n) time, O(1) space",id:"accessing-a-middle-node-on-time-o1-space",level:4},{value:"Inserting / Removing the head: O(1) time, O(1) space",id:"inserting--removing-the-head-o1-time-o1-space",level:4},{value:"Inserting / Removing the tail: O(n) to access + O(1) to modify time, O(1) space",id:"inserting--removing-the-tail-on-to-access--o1-to-modify-time-o1-space",level:4},{value:"Inserting / Removing a middle node: O(n) to access + O(1) to modify time, O(1) space",id:"inserting--removing-a-middle-node-on-to-access--o1-to-modify-time-o1-space",level:4},{value:"Searching for a value: O(n) time, O(1) space",id:"searching-for-a-value-on-time-o1-space",level:4},{value:"Traverse a linked list: O(n) time, O(1) space",id:"traverse-a-linked-list-on-time-o1-space",level:4},{value:"Copy a linked list: O(n) time, O(n) space",id:"copy-a-linked-list-on-time-on-space",level:4},{value:"Doubly Linked List",id:"doubly-linked-list",level:2},{value:"standard operations and their time complexities",id:"standard-operations-and-their-time-complexities",level:3},{value:"Initialize a linked list: O(n) time, O(n) space",id:"initialize-a-linked-list-on-time-on-space-1",level:4},{value:"Accessing the head: O(1) time, O(1) space",id:"accessing-the-head-o1-time-o1-space-1",level:4},{value:"Accessing the tail: O(1) time, O(1) space",id:"accessing-the-tail-o1-time-o1-space",level:4},{value:"Accessing a middle node: O(n) time, O(1) space",id:"accessing-a-middle-node-on-time-o1-space-1",level:4},{value:"Inserting / Removing the head: O(1) time, O(1) space",id:"inserting--removing-the-head-o1-time-o1-space-1",level:4},{value:"Inserting / Removing the tail: O(1) time, O(1) space",id:"inserting--removing-the-tail-o1-time-o1-space",level:4},{value:"Inserting / Removing a middle node: O(n) to access + O(1) to modify time, O(1) space",id:"inserting--removing-a-middle-node-on-to-access--o1-to-modify-time-o1-space-1",level:4},{value:"Searching for a value: O(n) time, O(1) space",id:"searching-for-a-value-on-time-o1-space-1",level:4},{value:"Traverse a linked list: O(n) time, O(1) space",id:"traverse-a-linked-list-on-time-o1-space-1",level:4},{value:"Copy a linked list: O(n) time, O(n) space",id:"copy-a-linked-list-on-time-on-space-1",level:4},{value:"Circular Linked List",id:"circular-linked-list",level:2}],c={toc:d};function p(e){let{components:t,...i}=e;return(0,a.kt)("wrapper",(0,n.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"linked-lists"},"Linked Lists"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"consists of nodes, each with some value and a pointer to the next node in the linked list"),(0,a.kt)("li",{parentName:"ul"},"a linked list node's value and next node are typically stored in ",(0,a.kt)("inlineCode",{parentName:"li"},"value")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"next")," properties"),(0,a.kt)("li",{parentName:"ul"},"the 1st node in a linked list is referred to as the ",(0,a.kt)("inlineCode",{parentName:"li"},"head")," of the linked list"),(0,a.kt)("li",{parentName:"ul"},"the last node in a linked list, whose ",(0,a.kt)("inlineCode",{parentName:"li"},"next")," property points to the ",(0,a.kt)("inlineCode",{parentName:"li"},"null")," value is known as the ",(0,a.kt)("inlineCode",{parentName:"li"},"tail")," of the linked list"),(0,a.kt)("li",{parentName:"ul"},"linked lists differs from an array is in how it's implemented and how it's stored in memory",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"basically it would store each node (1 memory slot) with their pointer (1 memory slot) back to back",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"the pointer stores the memory address of the next node"),(0,a.kt)("li",{parentName:"ul"},"each node and their respective pointers are not stored back to back with the other nodes and pointers in the memory"),(0,a.kt)("li",{parentName:"ul"},"they are linked together via their pointers"),(0,a.kt)("li",{parentName:"ul"},"in the case of a singly linked list, the last node would point to the memory address that contains the null value")))))),(0,a.kt)("h2",{id:"singly-linked-list"},"Singly Linked List"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"visual representation of a singly linked list whoses nodes hold integer values",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 -> 1 -> 2 -> 3 -> null")))),(0,a.kt)("li",{parentName:"ul"},"a singly linked list typically exposes its head to its user for easy access",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"while finding a node in a singly linked list involves traversing through all of the nodes leading up to the node in question (as opposed to instant access with an array)",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"adding or removing nodes involves overwriting ",(0,a.kt)("inlineCode",{parentName:"li"},"next")," pointers (assuming that you have access to the node right before the node that you're adding or removing)")))))),(0,a.kt)("h3",{id:"standard-operations-and-their-complexities"},"standard operations and their complexities"),(0,a.kt)("h4",{id:"initialize-a-linked-list-on-time-on-space"},"Initialize a linked list: O(n) time, O(n) space"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"this will create 2n memory slots, 1 for the node and 1 for the pointer"),(0,a.kt)("li",{parentName:"ul"},"it will also need to allocate the n chunks of memory thus will take n time")),(0,a.kt)("h4",{id:"accessing-the-head-o1-time-o1-space"},"Accessing the head: O(1) time, O(1) space"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"space is not affected")),(0,a.kt)("h4",{id:"accessing-the-tail-on-time-o1-space"},"Accessing the tail: O(n) time, O(1) space"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"requires to traverse the linked list to get the node"),(0,a.kt)("li",{parentName:"ul"},"space is not affected")),(0,a.kt)("h4",{id:"accessing-a-middle-node-on-time-o1-space"},"Accessing a middle node: O(n) time, O(1) space"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"requires to traverse the linked list to get the node"),(0,a.kt)("li",{parentName:"ul"},"space is not affected")),(0,a.kt)("h4",{id:"inserting--removing-the-head-o1-time-o1-space"},"Inserting / Removing the head: O(1) time, O(1) space"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"none of the nodes are required to be shifted, therefore it only requires changing of the head reference which is only for 1 node making it constant time and space effort")),(0,a.kt)("h4",{id:"inserting--removing-the-tail-on-to-access--o1-to-modify-time-o1-space"},"Inserting / Removing the tail: O(n) to access + O(1) to modify time, O(1) space"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"requires traversing through the list before any changing of reference could be done, therefore time is linear to traverse but modification is constant")),(0,a.kt)("h4",{id:"inserting--removing-a-middle-node-on-to-access--o1-to-modify-time-o1-space"},"Inserting / Removing a middle node: O(n) to access + O(1) to modify time, O(1) space"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"requires traversing through the list before any changing of reference could be done, therefore time is linear to traverse but modification is constant")),(0,a.kt)("h4",{id:"searching-for-a-value-on-time-o1-space"},"Searching for a value: O(n) time, O(1) space"),(0,a.kt)("h4",{id:"traverse-a-linked-list-on-time-o1-space"},"Traverse a linked list: O(n) time, O(1) space"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"space is not affected")),(0,a.kt)("h4",{id:"copy-a-linked-list-on-time-on-space"},"Copy a linked list: O(n) time, O(n) space"),(0,a.kt)("h2",{id:"doubly-linked-list"},"Doubly Linked List"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"similar to a singly linked list, except that each node in a doubly linked list also has a pointer to the previous node",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"the previous node is typically stored in a ",(0,a.kt)("inlineCode",{parentName:"li"},"prev")," property"))),(0,a.kt)("li",{parentName:"ul"},"just as the ",(0,a.kt)("inlineCode",{parentName:"li"},"next")," property of a doubly linked list's ",(0,a.kt)("inlineCode",{parentName:"li"},"tail")," points to the ",(0,a.kt)("inlineCode",{parentName:"li"},"null")," value, the ",(0,a.kt)("inlineCode",{parentName:"li"},"prev")," property of a doubly linked list ",(0,a.kt)("inlineCode",{parentName:"li"},"head")," also points to the ",(0,a.kt)("inlineCode",{parentName:"li"},"null")," value"),(0,a.kt)("li",{parentName:"ul"},"visual representation of a doubly linked list whoses nodes hold integer values",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"null <-> 0 <-> 1 <-> 2 <-> 3 <-> null")))),(0,a.kt)("li",{parentName:"ul"},"a doubly linked list typically exposes both its head and tail to its user",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"it also behaves very similarly to a singly linked list")))),(0,a.kt)("h3",{id:"standard-operations-and-their-time-complexities"},"standard operations and their time complexities"),(0,a.kt)("h4",{id:"initialize-a-linked-list-on-time-on-space-1"},"Initialize a linked list: O(n) time, O(n) space"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"this will create 2n memory slots, 1 for the node and 1 for the pointer"),(0,a.kt)("li",{parentName:"ul"},"it will also need to allocate the n chunks of memory thus will take n time")),(0,a.kt)("h4",{id:"accessing-the-head-o1-time-o1-space-1"},"Accessing the head: O(1) time, O(1) space"),(0,a.kt)("h4",{id:"accessing-the-tail-o1-time-o1-space"},"Accessing the tail: O(1) time, O(1) space"),(0,a.kt)("h4",{id:"accessing-a-middle-node-on-time-o1-space-1"},"Accessing a middle node: O(n) time, O(1) space"),(0,a.kt)("h4",{id:"inserting--removing-the-head-o1-time-o1-space-1"},"Inserting / Removing the head: O(1) time, O(1) space"),(0,a.kt)("h4",{id:"inserting--removing-the-tail-o1-time-o1-space"},"Inserting / Removing the tail: O(1) time, O(1) space"),(0,a.kt)("h4",{id:"inserting--removing-a-middle-node-on-to-access--o1-to-modify-time-o1-space-1"},"Inserting / Removing a middle node: O(n) to access + O(1) to modify time, O(1) space"),(0,a.kt)("h4",{id:"searching-for-a-value-on-time-o1-space-1"},"Searching for a value: O(n) time, O(1) space"),(0,a.kt)("h4",{id:"traverse-a-linked-list-on-time-o1-space-1"},"Traverse a linked list: O(n) time, O(1) space"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"space is not affected")),(0,a.kt)("h4",{id:"copy-a-linked-list-on-time-on-space-1"},"Copy a linked list: O(n) time, O(n) space"),(0,a.kt)("h2",{id:"circular-linked-list"},"Circular Linked List"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"a linked list that has no clear ",(0,a.kt)("inlineCode",{parentName:"li"},"head")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"tail"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"because its ",(0,a.kt)("inlineCode",{parentName:"li"},"tail")," points to its ",(0,a.kt)("inlineCode",{parentName:"li"},"head")),(0,a.kt)("li",{parentName:"ul"},"forming a closed circle"))),(0,a.kt)("li",{parentName:"ul"},"it can be either singly circular linked list or a doubly circular linked list")))}p.isMDXComponent=!0}}]);