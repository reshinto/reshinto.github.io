"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[68858],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=o.createContext({}),l=function(e){var n=o.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=l(e.components);return o.createElement(c.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(t),h=r,u=d["".concat(c,".").concat(h)]||d[h]||m[h]||i;return t?o.createElement(u,a(a({ref:n},p),{},{components:t})):o.createElement(u,a({ref:n},p))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=d;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var l=2;l<i;l++)a[l]=t[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},43666:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var o=t(83117),r=(t(67294),t(3905));const i={},a="C# Example",s={unversionedId:"interviewPrep/designPatterns/Structural_patterns/Composite/cSharp/readme",id:"interviewPrep/designPatterns/Structural_patterns/Composite/cSharp/readme",title:"C# Example",description:"Example",source:"@site/docs/interviewPrep/designPatterns/Structural_patterns/Composite/cSharp/readme.md",sourceDirName:"interviewPrep/designPatterns/Structural_patterns/Composite/cSharp",slug:"/interviewPrep/designPatterns/Structural_patterns/Composite/cSharp/",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Composite/cSharp/",draft:!1,editUrl:"https://github.com/reshinto/reshinto.github.io/blob/dev/docs/interviewPrep/designPatterns/Structural_patterns/Composite/cSharp/readme.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"C++ Example",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Composite/cPlusPlus/"},next:{title:"Go Example",permalink:"/docs/interviewPrep/designPatterns/Structural_patterns/Composite/go/"}},c={},l=[],p={toc:l};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"c-example"},"C# Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'// Composite Design Pattern\n//\n// Intent: Lets you compose objects into tree structures and then work with\n// these structures as if they were individual objects.\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace RefactoringGuru.DesignPatterns.Composite.Conceptual\n{\n    // The base Component class declares common operations for both simple and\n    // complex objects of a composition.\n    abstract class Component\n    {\n        public Component() { }\n\n        // The base Component may implement some default behavior or leave it to\n        // concrete classes (by declaring the method containing the behavior as\n        // "abstract").\n        public abstract string Operation();\n\n        // In some cases, it would be beneficial to define the child-management\n        // operations right in the base Component class. This way, you won\'t\n        // need to expose any concrete component classes to the client code,\n        // even during the object tree assembly. The downside is that these\n        // methods will be empty for the leaf-level components.\n        public virtual void Add(Component component)\n        {\n            throw new NotImplementedException();\n        }\n\n        public virtual void Remove(Component component)\n        {\n            throw new NotImplementedException();\n        }\n\n        // You can provide a method that lets the client code figure out whether\n        // a component can bear children.\n        public virtual bool IsComposite()\n        {\n            return true;\n        }\n    }\n\n    // The Leaf class represents the end objects of a composition. A leaf can\'t\n    // have any children.\n    //\n    // Usually, it\'s the Leaf objects that do the actual work, whereas Composite\n    // objects only delegate to their sub-components.\n    class Leaf : Component\n    {\n        public override string Operation()\n        {\n            return "Leaf";\n        }\n\n        public override bool IsComposite()\n        {\n            return false;\n        }\n    }\n\n    // The Composite class represents the complex components that may have\n    // children. Usually, the Composite objects delegate the actual work to\n    // their children and then "sum-up" the result.\n    class Composite : Component\n    {\n        protected List<Component> _children = new List<Component>();\n\n        public override void Add(Component component)\n        {\n            this._children.Add(component);\n        }\n\n        public override void Remove(Component component)\n        {\n            this._children.Remove(component);\n        }\n\n        // The Composite executes its primary logic in a particular way. It\n        // traverses recursively through all its children, collecting and\n        // summing their results. Since the composite\'s children pass these\n        // calls to their children and so forth, the whole object tree is\n        // traversed as a result.\n        public override string Operation()\n        {\n            int i = 0;\n            string result = "Branch(";\n\n            foreach (Component component in this._children)\n            {\n                result += component.Operation();\n                if (i != this._children.Count - 1)\n                {\n                    result += "+";\n                }\n                i++;\n            }\n\n            return result + ")";\n        }\n    }\n\n    class Client\n    {\n        // The client code works with all of the components via the base\n        // interface.\n        public void ClientCode(Component leaf)\n        {\n            Console.WriteLine($"RESULT: {leaf.Operation()}\\n");\n        }\n\n        // Thanks to the fact that the child-management operations are declared\n        // in the base Component class, the client code can work with any\n        // component, simple or complex, without depending on their concrete\n        // classes.\n        public void ClientCode2(Component component1, Component component2)\n        {\n            if (component1.IsComposite())\n            {\n                component1.Add(component2);\n            }\n\n            Console.WriteLine($"RESULT: {component1.Operation()}");\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Client client = new Client();\n\n            // This way the client code can support the simple leaf\n            // components...\n            Leaf leaf = new Leaf();\n            Console.WriteLine("Client: I get a simple component:");\n            client.ClientCode(leaf);\n\n            // ...as well as the complex composites.\n            Composite tree = new Composite();\n            Composite branch1 = new Composite();\n            branch1.Add(new Leaf());\n            branch1.Add(new Leaf());\n            Composite branch2 = new Composite();\n            branch2.Add(new Leaf());\n            tree.Add(branch1);\n            tree.Add(branch2);\n            Console.WriteLine("Client: Now I\'ve got a composite tree:");\n            client.ClientCode(tree);\n\n            Console.Write("Client: I don\'t need to check the components classes even when managing the tree:\\n");\n            client.ClientCode2(tree, leaf);\n        }\n    }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Client: I get a simple component:\nRESULT: Leaf\n\nClient: Now I've got a composite tree:\nRESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf))\n\nClient: I don't need to check the components classes even when managing the tree:\nRESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf)+Leaf)\n")))}m.isMDXComponent=!0}}]);